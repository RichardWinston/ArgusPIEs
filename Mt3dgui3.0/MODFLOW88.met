# 
# Template modified from:
# MOC3D Export Template Version 1.0
# Modified by Richard Winston 7/22/98
# 
# Modified from MODFLOW Template 1.4
# 
# Changes made by Argus Interware are marked by the initials YBI or RBW.
# 
Evaluate expression: MODFLOW_RF_Clear_Files()
Define Variable: InitialHeadName [String]
Define Variable: InitialHeadChoice [Boolean]
Set Variable: InitialHeadName:= "@edInitial@"
Set Variable: InitialHeadChoice:= @cbInitial@
Define Variable: ContinueSimulation [Boolean]
Define Variable: PIEVersionOK [Boolean]
# New Variables, RBW 7/22/98
Define Variable: Calibrate [Boolean]
Set Variable: Calibrate:= 0
Define Variable: UseCalibration [Boolean]
Set Variable: UseCalibration:= 0
If: IsNumber(Calibrate)
	Set Variable: UseCalibration:= Calibrate
End if
Define Variable: HeadPrintStyle [Boolean]
Define Variable: PrintMOC3DLocations [Boolean]
Set Variable: PrintMOC3DLocations:= @rgMOC3DConcFormat@
Define Variable: DrawdownPrintStyle [Boolean]
Define Variable: HeadPrintFormat [Integer]
Define Variable: DrawdownPrintFormat [Integer]
Define Variable: CalcElev [Boolean]
Define Variable: ThisConductance [Real]
Define Variable: AreaBoundaryInBlock [Boolean]
Define Variable: CurrentColumn [Integer]
Define Variable: CurrentRow [Integer]
Define Variable: Dummy [Real]
Define Variable: LayconString [String]
Define Variable: LayIndex [Integer]
Define Variable: DivIndex [Integer]
Define Variable: PeriodIndex [Integer]
Define Variable: StepIndex [Integer]
Define Variable: ListIndex [Integer]
Define Variable: ConcentrationList [Integer]
Define Variable: CurrentWellCount [Integer]
Define Variable: MaxWells [Integer]
Define Variable: CurrentDrainCount [Integer]
Define Variable: MaxDrains [Integer]
Define Variable: CurrentRiverCount [Integer]
Define Variable: MaxRivers [Integer]
Define Variable: CurrentGHBCount [Integer]
Define Variable: MaxGHBs [Integer]
Define Variable: TopElevationList [Integer]
Define Variable: BottomElevationList [Real]
Define Variable: ThicknessList [Integer]
Define Variable: KzList [Integer]
Define Variable: TempThickListStart [Integer]
Define Variable: TempThickIndex [Integer]
Define Variable: TempKzListStart [Integer]
Define Variable: TempKzListIndex [Integer]
Define Variable: ResultList [Integer]
Define Variable: CellThickness [Real]
Define Variable: LayerThickness [Real]
Define Variable: LayerTop [Real]
Define Variable: ProgressMax [Integer]
# End New Variables, RBW 7/22/98
Evaluate expression: MODFLOW_L_Initialize()
# 
# Define root filename for MODFLOW files:
Define Variable: FileName [String]
# 
# Define variables for exporting packages
Define Variable: RunMoc3d [Integer]
Define Variable: ExportBAS [Integer]
Define Variable: ExportOC [Integer]
Define Variable: ExportBCF [Integer]
Define Variable: ExportRIV [Integer]
Define Variable: ExportRCH [Integer]
Define Variable: ExportWEL [Integer]
Define Variable: ExportDRN [Integer]
Define Variable: ExportEVT [Integer]
Define Variable: ExportGHB [Integer]
Define Variable: ExportSOL [Integer]
# 
# Set variables for exporting packages (0 prohibits export of package, != 0 enables export of package)
Set Variable: RunMoc3d:= @cbUseSolute@
Set Variable: ExportBAS:= @cbExpBAS@
Set Variable: ExportOC:= @cbExpOC@
Set Variable: ExportBCF:= @cbExpBCF@
Set Variable: ExportRIV:= @cbExpRIV@
Set Variable: ExportRCH:= @cbExpRCH@
Set Variable: ExportWEL:= @cbExpWEL@
Set Variable: ExportDRN:= @cfExpDRN@
Set Variable: ExportEVT:= @cbExpEVT@
Set Variable: ExportGHB:= @cbExpGHB@
Set Variable: ExportSOL:= @cbExpMatrix@
# 
# Define error flags
Define Variable: err_geo [Integer]
Define Variable: err_bcf_1 [Integer]
Define Variable: err_rch_1 [Integer]
Define Variable: err_evt_1 [Integer]
Define Variable: err_ghb_1 [Integer]
Define Variable: err_ghb_2 [Integer]
Define Variable: err_riv_1 [Integer]
Define Variable: err_riv_2 [Integer]
Define Variable: err_riv_3 [Integer]
Define Variable: err_riv_4 [Integer]
Define Variable: err_drn_1 [Integer]
Define Variable: err_drn_2 [Integer]
Define Variable: err_drn_3 [Integer]
Define Variable: err_drn_4 [Integer]
Define Variable: err_wel_1 [Integer]
Define Variable: err_wel_2 [Integer]
Define Variable: err_moc_1 [Integer]
# 
# Initialize Error flags
Set Variable: err_geo:= 0
Set Variable: err_bcf_1:= 0
Set Variable: err_rch_1:= 0
Set Variable: err_evt_1:= 0
Set Variable: err_ghb_1:= 0
Set Variable: err_ghb_2:= 0
Set Variable: err_riv_1:= 0
Set Variable: err_riv_2:= 0
Set Variable: err_riv_3:= 0
Set Variable: err_riv_4:= 0
Set Variable: err_drn_1:= 0
Set Variable: err_drn_2:= 0
Set Variable: err_drn_3:= 0
Set Variable: err_drn_4:= 0
Set Variable: err_wel_1:= 0
Set Variable: err_wel_2:= 0
Set Variable: err_moc_1:= 0
# 
# Define heading for export
Define Variable: Heading1 [String]
Define Variable: Heading2 [String]
# 
# Define ITMUNI, IAPART & ISTRT
Define Variable: ITMUNI [Integer]
Define Variable: IAPART [Integer]
Define Variable: ISTRT [Integer]
# 
# Define variable OPTION (FREE=none, FREE CHTOCH=flow between adjacent constant head cells is calculated)
Define Variable: OPTION [String]
Define Variable: CHTOCH [Boolean]
# 
# Define HNOFLO
Define Variable: HNOFLO [Real]
# 
# Define ISS (0=transient, 1=steady-state)
Define Variable: ISS [Integer]
# 
# Define variables and flags for rewetting package (HDRY, IWDFLG, WETFCT, IWETIT, IHDWET)
Define Variable: HDRY [Real]
Define Variable: IWDFLG [Integer]
Define Variable: WETFCT [Real]
Define Variable: IWETIT [Integer]
Define Variable: IHDWET [Integer]
# 
# Define flags for stress packages (0 = package is NOT executed, 1 = package is executed):
Define Variable: WellChoice [Integer]
Define Variable: RechargeChoice [Integer]
Define Variable: DrainChoice [Integer]
Define Variable: RiverChoice [Integer]
Define Variable: EvapotranspirationChoice [Integer]
Define Variable: GeneralHeadChoice [Integer]
# MOC3D
Define Variable: ExportTRANS [Integer]
Define Variable: ExportOBS [Integer]
Define Variable: TransportFlag [Integer]
Define Variable: Transport [Integer]
# 
# Define flags for steady or transient stresses (0=steady, 1=transient)
Define Variable: SteadyWell [Integer]
Define Variable: SteadyRecharge [Integer]
Define Variable: SteadyDrain [Integer]
Define Variable: SteadyRiver [Integer]
Define Variable: SteadyEVT [Integer]
Define Variable: SteadyGHB [Integer]
# 
# Define recharge option (NRCHOP=1 recharge only to the top grid layer, =2 vertical distribution of recharge specified from recharge elevation, =3 recharge applied to highest active cell in vertical dimension)
# (Assume recharge elevation is constant for entire simulation)
Define Variable: NRCHOP [Integer]
# 
# Define recharge option (NEVTOP=1 ET calculated only at top grid layer, =2 vertical distribution of ET specified from ET surface)
# (Assume ET surface and ET extinction depth are constant for entire simulation)
Define Variable: NEVTOP [Integer]
# 
# Define flag for output of head into an external file (0 = none, 1 = formatted, 2 = binary):
Define Variable: OutputHead [Integer]
# 
# Define flag for output of drawdown into an external file (0 = none, 1 = formatted, 2 = binary):
Define Variable: OutputDrawdown [Integer]
# 
# Define flag for writing file of cell-by-cell flows (0 = separate files, 1 = single file);
Define Variable: OneCBCFile [Integer]
# 
# Define flag for printing compact budget files (0 = regular, 1 = compact)
Define Variable: CompactBudget [Integer]
# 
# Define flag for writing cell-by-cell flow from each stress package (0 = do not write, 1 = write)
Define Variable: IBCFCB [Integer]
Define Variable: IWELCB [Integer]
Define Variable: IRCHCB [Integer]
Define Variable: IDRNCB [Integer]
Define Variable: IRIVCB [Integer]
Define Variable: IEVTCB [Integer]
Define Variable: IGHBCB [Integer]
Define Variable: OutputBudget [Integer]
# 
# Define flag for frequency of printing head, drawdown and budget information in external files (0 = none, -1 = last timestep of stress period, N = every Nth timestep):
Define Variable: FreqHeadFile [Integer]
Define Variable: FreqDrawdownFile [Integer]
Define Variable: FreqBudgetFile [Integer]
# 
# Define flags for frequency of output in listing file (0 = none, -1 = last timestep of stress period, N = every Nth timestep):
Define Variable: FreqHeadList [Integer]
Define Variable: FreqDrawdownList [Integer]
Define Variable: FreqBudgetList [Integer]
# 
# Define flag for matrix solver: (1 = SOR, 2 = SIP, 3 = PCG, 4 = DE4)
Define Variable: SolverChoice [Integer]
# 
# Define variables for SOR solver (SolverChoice=3)
# MXITER: Maximum number of outer iterations
Define Variable: SOR_MXITER [Integer]
# ACCL: Acceleration parameter
Define Variable: SOR_ACCL [Real]
# HCLOSE: Maximum absolute change in head used to check convergence.
Define Variable: SOR_HCLOSE [Real]
# IPRSOR: Printout interval for SOR.
Define Variable: SOR_IPRSOR [Integer]
# 
# Define variables for SIP solver (SolverChoice=0)
# MXITER: Maximum number of outer iterations
Define Variable: SIP_MXITER [Integer]
# NPARM: Number of iteration parameters
Define Variable: SIP_NPARM [Integer]
# ACCL: Acceleration parameter
Define Variable: SIP_ACCL [Real]
# HCLOSE: Maximum absolute change in head used to check convergence.
Define Variable: SIP_HCLOSE [Real]
# IPCALC: Flag to indicate seed for calculating iteration parameters (0=seed entered by user, 1=seed calculated at start of simulation)
Define Variable: SIP_IPCALC [Integer]
# WSEED: Seed for calculating iteration paramters
Define Variable: SIP_WSEED [Real]
# IPRSIP: Printout interval for SIP.
Define Variable: SIP_IPRSIP [Integer]
# 
# Define variable for PCG solver (SolverChoice=2)
# MXITER: Maximum number of outer iterations
Define Variable: PCG_MXITER [Integer]
# ITER1: Maximum number of inner iterations
Define Variable: PCG_ITER1 [Integer]
# NPCOND: Flag used to select matrix preconditioning method: 1=Modified incomplete Cholesky, 2=Polynomial
Define Variable: PCG_NPCOND [Real]
# HCLOSE: Maximum absolute change in head used to check convergence.
Define Variable: PCG_HCLOSE [Real]
# RCLOSE: Maximum absolute change in residual used to check convergence.
Define Variable: PCG_RCLOSE [Real]
# RELAX: Relation parameter used with NPCOND=1
Define Variable: PCG_RELAX [Real]
# NBPOL: Flag used when NPCOND=2 to indicate whether the estimate of the upper bound of the max eignevalue is 2, or will be calculated. NBPOL=2 specifies max eigenvalue as 2, NBPOL!=2 calculates estimate. (Not used for NBPOL!=2)
Define Variable: PCG_NBPOL [Integer]
# IPRPCG: Printout interval for PCG
Define Variable: PCG_IPRPCG [Integer]
# MUTPCG: Flag to control printing from solver, MUTPCG=0 print solver information, MUTPCG=1 only print iteration, MUTPCG=2 suppresses all printing.
Define Variable: PCG_MUTPCG [Integer]
# IPCGCD: Flag used for NPCOND=1 to control whether same Cholesky decomposition is used for multiple calls to PCG.
Define Variable: PCG_DAMP [Real]
# 
# Define variables for DE4 solver (SolverChoice=1)
# ITMX: maximum number of iterations
Define Variable: DE4_ITMX [Integer]
# MXUP: maximum number of equations in upper part
Define Variable: DE4_MXUP [Integer]
# MXLOW: maximum number of equations in lower part
Define Variable: DE4_MXLOW [Integer]
# MXBW: maximum bandwidth
Define Variable: DE4_MXBW [Integer]
# IFREQ: flag indicating frequency of change in coefficient matrix (1=flow equations are linear, 2=flow equations are linear but coefficients of simulated head may change at the beginning of stress period, 3=nonlinear flow equations)
Define Variable: DE4_IFREQ [Integer]
# MUTD4: Flag indicating printing at convergence (0=number of iterations printed & maximum head change, 1=number of iterations printed, 2=no information printed)
Define Variable: DE4_MUTD4 [Integer]
# ACCL: acceleration parameter
Define Variable: DE4_ACCL [Real]
# HCLOSE: convergence criteria for head
Define Variable: DE4_HCLOSE [Real]
# IPRD4: time step interval when printing out convergence information
Define Variable: DE4_IPRD4 [Integer]
# 
Define Variable: MOC_ISLAY1 [Integer]
Define Variable: MOC_ISLAY2 [Integer]
Define Variable: MOC_ISROW1 [Integer]
Define Variable: MOC_ISROW2 [Integer]
Define Variable: MOC_ISCOL1 [Integer]
Define Variable: MOC_ISCOL2 [Integer]
Define Variable: MOC_NODISP [Integer]
Define Variable: MOC_DECAY [Real]
Define Variable: MOC_DIFFUS [Real]
Define Variable: MOC_INTRPL [Integer]
Define Variable: MOC_CNOFLO [Real]
Define Variable: MOC_INCRCH [Integer]
Define Variable: MOC_IOBSFL [Integer]
# 
Define Variable: MOC_NPMAX [Integer]
Define Variable: MOC_CELDIS [Real]
Define Variable: MOC_FZERO [Real]
Define Variable: MOC_NPCUST [Integer]
Define Variable: MOC_NPTPND [Integer]
Define Variable: MOC_NPTPNDError [Boolean]
# 
Define Variable: MOC_CNC_OPT [Integer]
Define Variable: MOC_NPNTCL [Integer]
Define Variable: MOC_NPNTCLN [Integer]
Define Variable: MOC_VEL_OPT [Integer]
Define Variable: MOC_NPNTVL [Integer]
Define Variable: MOC_NPNTVLN [Integer]
Define Variable: MOC_NPNTDL [Integer]
Define Variable: MOC_NPNTDLN [Integer]
Define Variable: MOC_PRT_OPT [Integer]
Define Variable: MOC_NPNTPL [Integer]
Define Variable: MOC_NPNTPLN [Integer]
Define Variable: MOC_NSLAY [Integer]
Define Variable: MOC_CINFLBefore [Real]
Define Variable: MOC_CINFLAfter [Real]
# MOCIMP
Define Variable: MOC_EPSSLV [Real]
Define Variable: MOC_FDTMTH [Real]
Define Variable: MOC_IDIREC [Integer]
Define Variable: MOC_MAXIT [Integer]
Define Variable: MOC_NCXIT [Integer]
# 
Define Variable: MOC_NUMOBS [Integer]
Define Variable: NColsSub [Integer]
Define Variable: NRowsSub [Integer]
Define Variable: NLaySub [Integer]
Define Variable: FirstLay [Integer]
Define Variable: LastLay [Integer]
# 
# Define total number of model layers
Define Variable: NumLay [Integer]
# 
# Define number of geologic units in simulation
Define Variable: NumGeo [Integer]
Define Variable: TopSimul [Integer]
Define Variable: BotSimul [Integer]
# 
# Define dummy variables for looping and checking
Define Variable: i [Integer]
Define Variable: j [Integer]
Define Variable: k [Integer]
Define Variable: n [Integer]
Define Variable: ocflag [Integer]
Define Variable: M [Integer]
Define Variable: TempValue1 [Real]
Define Variable: TempValue2 [Real]
Define Variable: TempValue3 [Real]
Define Variable: TempValue4 [Real]
Define Variable: WD [Real]
Define Variable: WT [Real]
Define Variable: WB [Real]
Define Variable: TML [Real]
Define Variable: BML [Real]
# 
Define Variable: SegmentLength [Real]
Define Variable: ContourArea [Real]
# 
# added on June 16, 1997
Define Variable: L [Integer]
Define Variable: Lay_Flag [Integer]
Define Variable: Block_Num [Integer]
Define Variable: Block_Flag [Integer]
Define Variable: ok [Integer]
Define Variable: Test [Real]
# 
Define Variable: err_point [Integer]
Define Variable: err_line [Integer]
Define Variable: err_area1 [Integer]
Define Variable: err_area2 [Integer]
# 
Define Variable: GHB_MXBND [Integer]
Define Variable: RIV_MXRIVR [Integer]
Define Variable: DRN_MXDRN [Integer]
Define Variable: WEL_MXWELL [Integer]
Define Variable: DumRow [Integer]
Define Variable: DumCol [Integer]
Define Variable: DumLay [Integer]
# 
Define Variable: RunMODFLOW [Integer]
Define Variable: FreqHeadFileChoice [Integer]
Define Variable: FreqDrawdownFileChoice [Integer]
Define Variable: FreqBudFileChoice [Integer]
Define Variable: FreqHeadListChoice [Integer]
Define Variable: FreqDrawdownListChoice [Integer]
Define Variable: FreqBudListChoice [Integer]
# 
Set Variable: HeadPrintStyle:= @comboHeadPrintStyle@
Set Variable: DrawdownPrintStyle:= @comboDrawdownPrintStyle@
Set Variable: HeadPrintFormat:= @comboHeadPrintFormat@ + 1
Set Variable: DrawdownPrintFormat:= @comboDrawdownPrintFormat@ + 1
# 
Set Variable: FileName:= "@adeFileName@"
# 
Set Variable: Heading1:= "@adeTitle1@"
Set Variable: Heading2:= "@adeTitle2@"
# 
Set Variable: NumLay:= 0
Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
	Set Variable: NumLay:= NumLay+MODFLOW_SIMUL(LayIndex)*MODFLOW_NDIV(LayIndex)
End loop
# 
Set Variable: ITMUNI:= @comboTimeUnits@
Set Variable: IAPART:= @comboIAPART@
Set Variable: ISTRT:= @comboISTRT@
Set Variable: HNOFLO:= @adeHNOFLO@
# 
Set Variable: OPTION:= "FREE"
Set Variable: CHTOCH:= @cbCHTOCH@
If: CHTOCH
	Set Variable: OPTION:= OPTION + ", CHTOCH"
End if
# 
Set Variable: ISS:= @comboSteady@
Set Variable: HDRY:= @adeHDRY@
Set Variable: IWDFLG:= @comboWetCap@
Set Variable: WETFCT:= @adeWettingFact@
Set Variable: IWETIT:= @adeWetIterations@
Set Variable: IHDWET:= @comboWetEq@
# 
# Set variables for choice of stress packages and output control:
# 
Set Variable: WellChoice:= @cbWEL@&@cbWELRetain@
Set Variable: RechargeChoice:= @cbRCH@&@cbRCHRetain@
Set Variable: DrainChoice:= @cbDRN@&@cbDRNRetain@
Set Variable: RiverChoice:= @cbRIV@&@cbRIVRetain@
Set Variable: EvapotranspirationChoice:= @cbEVT@&@cbEVTRetain@
Set Variable: GeneralHeadChoice:= @cbGHB@&@cbGHBRetain@
# 
Define Variable: RechargeTest [Boolean]
Define Variable: SYTest [Boolean]
Define Variable: SsTest [Boolean]
# 
# MOC3D
# Set variable for exporting package (0 prohibits export of package, != 0 enables export of package)
Set Variable: ExportTRANS:= @cbExpCONC@
Set Variable: ExportOBS:= @cbExpOBS@
Set Variable: Transport:= @cbMOC3D@
Set Variable: TransportFlag:= Transport
If: Transport
	Set Variable: Transport:= Transport + @rgMOC3DSolver@
End if
# 
Set Variable: SteadyWell:= @comboWelSteady@
Set Variable: SteadyRecharge:= @comboRchSteady@
Set Variable: SteadyDrain:= @comboDrnSteady@
Set Variable: SteadyRiver:= @comboRivSteady@
Set Variable: SteadyEVT:= @comboEvtSteady@
Set Variable: SteadyGHB:= @comboGhbSteady@
# 
Set Variable: NRCHOP:= @comboRchOpt@ + 1
Set Variable: NEVTOP:= @comboEvtOption@ + 1
# 
Set Variable: OutputHead:= @comboExportHead@
Set Variable: OutputDrawdown:= @comboExportDrawdown@
# 
Set Variable: OneCBCFile:= @cbOneFlowFile@
Set Variable: CompactBudget:= @cbFlowBudget@
# 
Set Variable: IBCFCB:= @cbFlowBCF@
Set Variable: IWELCB:= @cbFlowWel@
Set Variable: IRCHCB:= @cbFlowRCH@
Set Variable: IDRNCB:= @cbFlowDrn@
Set Variable: IRIVCB:= @cbFlowRiv@
Set Variable: IEVTCB:= @cbFlowEVT@
Set Variable: IGHBCB:= @cbFlowGHB@
If: ((IBCFCB=1|(WellChoice=1&IWELCB=1)|(RechargeChoice=1&IRCHCB=1)|(DrainChoice=1&IDRNCB=1)|(RiverChoice=1&IRIVCB=1)|(EvapotranspirationChoice=1&IEVTCB=1)|(GeneralHeadChoice=1&IGHBCB=1)))
	Set Variable: OutputBudget:= 1
End if
# 
Set Variable: FreqHeadFileChoice:= @comboHeadPrintFreq@
If: FreqHeadFileChoice=0
	Set Variable: FreqHeadFile:= 0
Else
	If: FreqHeadFileChoice=1
		Set Variable: FreqHeadFile:= @adeHeadPrintFreq@
	Else
		Set Variable: FreqHeadFile:= -1
	End if
End if
# Set Variable: FreqHeadFile:= @HDEXP@
Set Variable: FreqDrawdownFileChoice:= @comboDrawdownPrintFreq@
If: FreqDrawdownFileChoice=0
	Set Variable: FreqDrawdownFile:= 0
Else
	If: FreqDrawdownFileChoice=1
		Set Variable: FreqDrawdownFile:= @adeDrawdownPrintFreq@
	Else
		Set Variable: FreqDrawdownFile:= -1
	End if
End if
# Set Variable: FreqDrawdownFile:= @DNEXP@
Set Variable: FreqBudFileChoice:= @comboBudPrintFreq@
If: FreqBudFileChoice=0
	Set Variable: FreqBudgetFile:= 0
Else
	If: FreqBudFileChoice=1
		Set Variable: FreqBudgetFile:= @adeBudPrintFreq@
	Else
		Set Variable: FreqBudgetFile:= -1
	End if
End if
# Set Variable: FreqBudgetFile:= @FLOWEXP@
# 
Set Variable: FreqHeadListChoice:= @comboHeadExportFreq@
If: FreqHeadListChoice=0
	Set Variable: FreqHeadList:= 0
Else
	If: FreqHeadListChoice=1
		Set Variable: FreqHeadList:= @adeHeadExportFreq@
	Else
		Set Variable: FreqHeadList:= -1
	End if
End if
# Set Variable: FreqHeadList:= @HDLIST@
Set Variable: FreqDrawdownListChoice:= @comboDrawdownExportFreq@
If: FreqDrawdownListChoice=0
	Set Variable: FreqDrawdownList:= 0
Else
	If: FreqDrawdownListChoice=1
		Set Variable: FreqDrawdownList:= @adeDrawdownExportFreq@
	Else
		Set Variable: FreqDrawdownList:= -1
	End if
End if
# Set Variable: FreqDrawdownList:= @DNLIST@
Set Variable: FreqBudListChoice:= @comboBudExportFreq@
If: FreqBudListChoice=0
	Set Variable: FreqBudgetList:= 0
Else
	If: FreqBudListChoice=1
		Set Variable: FreqBudgetList:= @adeBudExportFreq@
	Else
		Set Variable: FreqBudgetList:= -1
	End if
End if
# Set Variable: FreqBudgetList:= @BUDGETLIST@
# 
Set Variable: SolverChoice:= @rgSolMeth@
# 
# Set variables for SOR solver (SolverChoice=3)
Set Variable: SOR_MXITER:= @adeSORMaxIter@
Set Variable: SOR_ACCL:= @adeSORAccl@
Set Variable: SOR_HCLOSE:= @adeSORConv@
Set Variable: SOR_IPRSOR:= @adeSORPri@
# 
# Set variables for SIP solver (SolverChoice=0)
Set Variable: SIP_MXITER:= @adeSIPMaxIter@
Set Variable: SIP_NPARM:= @adeSIPNumParam@
Set Variable: SIP_ACCL:= @adeSIPAcclParam@
Set Variable: SIP_HCLOSE:= @adeSIPConv@
Set Variable: SIP_IPCALC:= @comboSIPIterSeed@
Set Variable: SIP_WSEED:= @adeSIPIterSeed@
Set Variable: SIP_IPRSIP:= @adeSIPPrint@
# 
# Set variables for PCG solver (SolverChoice=2)
Set Variable: PCG_MXITER:= @adePCGMaxOuter@
Set Variable: PCG_ITER1:= @adePCGMaxInner@
Set Variable: PCG_NPCOND:= @comboPCGPrecondMeth@ +1
Set Variable: PCG_HCLOSE:= @adePCGMaxHeadChange@
Set Variable: PCG_RCLOSE:= @adePCGMaxResChange@
Set Variable: PCG_RELAX:= @adePCGRelax@
Set Variable: PCG_NBPOL:= @comboPCGEigenValue@ + 1
Set Variable: PCG_IPRPCG:= @adePCGPrintInt@
Set Variable: PCG_MUTPCG:= @comboPCGPrint@
Set Variable: PCG_DAMP:= @adePCGDamp@
# 
# Set variables for DE4 solver (SolverChoice=1)
Set Variable: DE4_ITMX:= @adeDE4MaxIter@
Set Variable: DE4_MXUP:= @adeDE4MaxUp@
Set Variable: DE4_MXLOW:= @adeDE4MaxLow@
Set Variable: DE4_MXBW:= @adeDE4Band@
Set Variable: DE4_IFREQ:= @comboDE4Freq@ + 1
Set Variable: DE4_MUTD4:= @comboDE4Print@
Set Variable: DE4_ACCL:= @adeDE4Accl@
Set Variable: DE4_HCLOSE:= @adeDE4Conv@
Set Variable: DE4_IPRD4:= @adeDE4TimeStep@
# Set MOC3D variables
Set Variable: MOC_ISLAY1:= @adeMOC3DLay1@
Set Variable: MOC_ISLAY2:= @adeMOC3DLay2@
If: MOC_ISLAY2=-1
	Set Variable: MOC_ISLAY2:= MODFLOW_NLAY()
End if
Set Variable: MOC_ISROW1:= MOC_ISROW1()
Set Variable: MOC_ISROW2:= MOC_ISROW2()
Set Variable: MOC_ISCOL1:= MOC_ISCOL1()
Set Variable: MOC_ISCOL2:= MOC_ISCOL2()
Set Variable: MOC_NODISP:= @cbMOC3DNoDisp@
Set Variable: MOC_DECAY:= @adeMOC3DDecay@
Set Variable: MOC_DIFFUS:= @adeMOC3DDiffus@
Set Variable: MOC_INTRPL:= @comboMOC3DInterp@ + 1
Set Variable: MOC_CNOFLO:= @adeMOC3DCnoflow@
Set Variable: MOC_INCRCH:= -@comboMOC3DReadRech@
Set Variable: MOC_IOBSFL:= @comboMOC3DSaveWell@
# 
Set Variable: MOC_NPMAX:= @adeMOC3DMaxParticles@
Set Variable: MOC_CELDIS:= @adeMOC3DMaxFrac@
Set Variable: MOC_FZERO:= @adeMOC3DLimitActiveCells@
Set Variable: MOC_NPCUST:= @cbCustomParticle@
Set Variable: MOC_NPTPND:= @edMOC3DInitParticles@
# 
Set Variable: MOC_CNC_OPT:= @comboMOC3DConcFileType@
Set Variable: MOC_NPNTCL:= @comboMOC3DConcFreq@
Set Variable: MOC_NPNTCLN:= @adeMOC3DConcFreq@
Set Variable: MOC_VEL_OPT:= @comboMOC3DVelFileType@
Set Variable: MOC_NPNTVL:= @comboMOC3DVelFreq@
Set Variable: MOC_NPNTVLN:= @adeMOC3DVelFreq@
Set Variable: MOC_NPNTDL:= @comboMOC3DDispFreq@
Set Variable: MOC_NPNTDLN:= @adeMOC3DDispFreq@
Set Variable: MOC_PRT_OPT:= @comboMOC3DPartFileType@
Set Variable: MOC_NPNTPL:= @comboMOC3DPartFreq@
Set Variable: MOC_NPNTPLN:= @adeMOC3DPartFreq@
Set Variable: MOC_NSLAY:= @adeMOCNumLayers@
# Set Variable: MOC_CINFLBefore:= @MOC_CINFLBefore@
# Set Variable: MOC_CINFLAfter:= @MOC_CINFLAfter@
Set Variable: NColsSub:= MOC_ISCOL2-MOC_ISCOL1+1
Set Variable: NRowsSub:= MOC_ISROW2-MOC_ISROW1+1
Set Variable: NLaySub:= MOC_ISLAY2-MOC_ISLAY1+1
Define Variable: RowHeightList [Integer]
Define Variable: ColumnWidthList [Integer]
Define Variable: RowIndex [Integer]
Define Variable: ColumnIndex [Integer]
Define Variable: MinRow [Real]
Define Variable: MaxRow [Real]
Define Variable: MinColumn [Real]
Define Variable: MaxColumn [Real]
Define Variable: FirstRowHeight [Real]
Define Variable: FirstColumnWidth [Real]
Define Variable: CurrentRowHeight [Real]
Define Variable: CurrentColumnWidth [Real]
Define Variable: ObservationIndex [Integer]
# 
Define Variable: Dimensions [Integer]
Set Variable: MOC_NPTPNDError:= 0
If: RunMoc3d&!MOC_NPCUST
	Set Variable: Dimensions:= 0
	If: NLaySub>1
		Set Variable: Dimensions:= Dimensions + 1
	End if
	If: NRowsSub>1
		Set Variable: Dimensions:= Dimensions + 1
	End if
	If: NColsSub>1
		Set Variable: Dimensions:= Dimensions + 1
	End if
	If: Dimensions=1
		If: !((MOC_NPTPND=1)|(MOC_NPTPND=2)|(MOC_NPTPND=3)|(MOC_NPTPND=4))
			Set Variable: MOC_NPTPNDError:= 1
		End if
	End if
	If: Dimensions=2
		If: !((MOC_NPTPND=1)|(MOC_NPTPND=4)|(MOC_NPTPND=9)|(MOC_NPTPND=16))
			Set Variable: MOC_NPTPNDError:= 1
		End if
	End if
	If: Dimensions=3
		If: !((MOC_NPTPND=1)|(MOC_NPTPND=8)|(MOC_NPTPND=27))
			Set Variable: MOC_NPTPNDError:= 1
		End if
	End if
End if
# MOCIMP
Set Variable: MOC_EPSSLV:= @adeMOCTolerance@
Set Variable: MOC_FDTMTH:= @adeMOCWeightFactor@
Set Variable: MOC_IDIREC:= @comboMOC3D_IDIREC@ + 1
Set Variable: MOC_MAXIT:= @adeMOCMaxIter@
Set Variable: MOC_NCXIT:= @adeMOCNumIter@
# 
# MODPATH Variables
Define Variable: MODFLOWLayer [Integer]
Define Variable: MODPATHChoice [Boolean]
Define Variable: RechargeITOP [Integer]
Define Variable: EvapITOP [Integer]
# 
Set Variable: MODPATHChoice:= @cbMODPATH@
Set Variable: RechargeITOP:= @comboMODPATH_RechargeITOP@
Set Variable: EvapITOP:= @comboMODPATH_EvapITOP@
# 
Set Variable: RunMODFLOW:= @rbRun@
# 
Set Variable: NumGeo:= 0
Set Variable: TopSimul:= 0
Set Variable: BotSimul:= 0
# 
Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
	If: MODFLOW_SIMUL(LayIndex)!=0&TopSimul=0
		Set Variable: TopSimul:= LayIndex
	End if
End loop
# 
Loop for: Variable LayIndex from: MODFLOW_NLAY() to: 1 step: -1
	If: MODFLOW_SIMUL(LayIndex)!=0&BotSimul=0
		Set Variable: BotSimul:= LayIndex
	End if
End loop
# 
# Stream package variables
Define Variable: StreamChoice [Boolean]
Set Variable: StreamChoice:= @cbSTR@
Define Variable: ExportStreams [Boolean]
Set Variable: ExportStreams:= @cbExpStr@
Define Variable: ElevationAboveTopError [Boolean]
Define Variable: ElevationBelowBottomError [Boolean]
Define Variable: TributaryMaxAllowed [Integer]
Define Variable: StreamSegmentCount [Integer]
Define Variable: StreamSegmentList [Integer]
Define Variable: SortedStreamSegmentList [Integer]
Define Variable: StreamUnitList [Integer]
Define Variable: StreamTributaryList [Integer]
Define Variable: StreamIndex [Integer]
Define Variable: StreamIndex2 [Real]
Define Variable: Tributary2DArray [Integer]
Define Variable: TributaryIndex [Integer]
Define Variable: TributaryCount [Integer]
Define Variable: not_ok [Boolean]
Define Variable: StreamsSteady [Boolean]
Set Variable: StreamsSteady:= !@comboStreamOption@
Define Variable: StreamTop [Real]
Define Variable: DownstreamStreamTop [Real]
Define Variable: StreamBottom [Real]
Define Variable: DownstreamStreamBottom [Real]
Define Variable: StreamStage [Real]
Define Variable: DownstreamStreamStage [Real]
Define Variable: StreamConductance [Real]
Define Variable: Width [Real]
Define Variable: DownstreamWidth [Real]
Define Variable: ICALC [Integer]
Set Variable: ICALC:= @cbStreamCalcFlow@
Define Variable: UseTributaries [Boolean]
Set Variable: UseTributaries:= @cbStreamTrib@
Define Variable: UseDiversions [Boolean]
Set Variable: UseDiversions:= @cbStreamDiversions@
Set Variable: StreamSegmentList:= MODFLOW_L_CreateNewList()
Set Variable: SortedStreamSegmentList:= MODFLOW_L_CreateNewList()
Set Variable: StreamTributaryList:= MODFLOW_L_CreateNewList()
Set Variable: TributaryMaxAllowed:= 10
Set Variable: StreamUnitList:= MODFLOW_L_CreateNewList()
Define Variable: StreamProperties3DArray [Integer]
Define Variable: CurrentStream [Integer]
Define Variable: BlockIndex [Integer]
Define Variable: BlockListCount [Integer]
Define Variable: BlockTop [Real]
Define Variable: BlockBottom [Real]
Define Variable: StreamUnit [Integer]
Define Variable: CurrentStreamReachCount [Integer]
Define Variable: MaxStreamReachCount [Integer]
Define Variable: ISTCB1 [Integer]
Set Variable: ISTCB1:= @cbFlowSTR@
Define Variable: ISTCB2 [Integer]
Set Variable: ISTCB2:= @cbFlowSTR2@
Define Variable: NTRIB [Integer]
Define Variable: NTRIBCurrent [Integer]
Define Variable: NDIV [Integer]
# ModelLengthUnits = 0 -> m
# ModelLengthUnits = 1 -> ft
Define Variable: ModelLengthUnits [Integer]
Set Variable: ModelLengthUnits:= @comboModelUnits@
Define Variable: StreamCONST [Real]
Set Variable: StreamCONST:= 1
If: ICALC&StreamChoice
	If: ITMUNI=0
		Alert: "Error: You must specify the time unit to calculate the stage height in the stream package. Check the Time Tab of the Edit Project Info Dialog box."
	End if
	If: ITMUNI=1
		If: ModelLengthUnits
			Set Variable: StreamCONST:= 1.486
		Else
			Set Variable: StreamCONST:= 1
		End if
	End if
	If: ITMUNI=2
		If: ModelLengthUnits
			Set Variable: StreamCONST:= 89.16
		Else
			Set Variable: StreamCONST:= 60
		End if
	End if
	If: ITMUNI=3
		If: ModelLengthUnits
			Set Variable: StreamCONST:= 5349.6
		Else
			Set Variable: StreamCONST:= 3600
		End if
	End if
	If: ITMUNI=4
		If: ModelLengthUnits
			Set Variable: StreamCONST:= 128390.4
		Else
			Set Variable: StreamCONST:= 86400
		End if
	End if
	If: ITMUNI=5
		If: ModelLengthUnits
			Set Variable: StreamCONST:= 46784593
		Else
			Set Variable: StreamCONST:= 31447600
		End if
	End if
End if
Define Variable: FlowIndex [Integer]
Set Variable: FlowIndex:= 0
Define Variable: UpstreamStageIndex [Integer]
Set Variable: UpstreamStageIndex:= 1
Define Variable: DownstreamStageIndex [Integer]
Set Variable: DownstreamStageIndex:= 2
Define Variable: ConductivityIndex [Integer]
Set Variable: ConductivityIndex:= 3
Define Variable: UpstreamTopElevIndex [Integer]
Set Variable: UpstreamTopElevIndex:= 4
Define Variable: DownstreamTopElevIndex [Integer]
Set Variable: DownstreamTopElevIndex:= 5
Define Variable: UpstreamBotElevIndex [Integer]
Set Variable: UpstreamBotElevIndex:= 6
Define Variable: DownstreamBotElevIndex [Integer]
Set Variable: DownstreamBotElevIndex:= 7
Define Variable: UpstreamWidthIndex [Integer]
Set Variable: UpstreamWidthIndex:= 8
Define Variable: DownstreamWidthIndex [Integer]
Set Variable: DownstreamWidthIndex:= 9
Define Variable: SlopeIndex [Integer]
Set Variable: SlopeIndex:= 10
Define Variable: RoughnessIndex [Integer]
Set Variable: RoughnessIndex:= 11
Define Variable: InterpolateStage [Integer]
Set Variable: InterpolateStage:= 12
Define Variable: InterpolateTopElev [Integer]
Set Variable: InterpolateTopElev:= 13
Define Variable: InterpolateBottomElev [Integer]
Set Variable: InterpolateBottomElev:= 14
Define Variable: InterpolateWidth [Integer]
Set Variable: InterpolateWidth:= 15
# 
# 
# HFB Variables
Define Variable: HFBChoice [Boolean]
Set Variable: HFBChoice:= @cbHFB@
Define Variable: ExportHFB [Boolean]
Set Variable: ExportHFB:= @cbExpHFB@
Define Variable: BarrierIndex [Integer]
Define Variable: CellIndex [Integer]
Define Variable: ColumnCount [Integer]
Define Variable: RowCount [Integer]
Define Variable: Row1 [Integer]
Define Variable: Row2 [Integer]
Define Variable: Column1 [Integer]
Define Variable: Column2 [Integer]
Define Variable: CurrentBarrierCount [Integer]
Define Variable: TotalBarrierCount [Integer]
Define Variable: HYDCHR [Real]
Define Variable: AverageCellThickness [Real]
Set Variable: ColumnCount:= NumColumns()
Set Variable: RowCount:= NumRows()
# 
# Modflow 88 variables
Define Variable: FormatString [String]
Evaluate expression: 0
# 
# Lake Variables
Define Variable: UnitTop [Real]
Define Variable: UnitBottom [Real]
Define Variable: LayerBottom [Real]
Define Variable: LakebedTop [Real]
Define Variable: LakebedBottom [Real]
Define Variable: LocalKz [Real]
Define Variable: CrossSectionalArea [Real]
Define Variable: LocalBottom [Real]
Define Variable: FoundLakeCell [Boolean]
Define Variable: FoundLakeBottomCell3DList [Real]
Define Variable: MasterLakeList [Integer]
Define Variable: MasterLakeListSize [Integer]
Define Variable: LakeColumnListsStart [Integer]
Define Variable: LakeRowListsStart [Integer]
Define Variable: LakeLayerListStart [Integer]
Define Variable: LakeNodeTypeListStart [Integer]
Define Variable: LakeTopElevListStart [Integer]
Define Variable: LakeBotElevListStart [Integer]
Define Variable: LakeAreaListStart [Integer]
Define Variable: LakeHydCondListStart [Integer]
Define Variable: LakeNumber [Integer]
Define Variable: LakeIndex [Integer]
Define Variable: MaxInflowSegments [Integer]
Define Variable: MaxOutflowSegments [Integer]
Define Variable: SegmentIndex [Integer]
Define Variable: NSTRIN [Integer]
Define Variable: NSTROUT [Integer]
Define Variable: NRATEQ [Integer]
Define Variable: NODES [Integer]
Define Variable: NLAKES [Integer]
Define Variable: MaxRateEq [Integer]
Define Variable: RateEqIndex [Integer]
Define Variable: NSUBSTEPS [Integer]
Define Variable: ILKCBC [Integer]
Define Variable: ILKOUT [Integer]
Define Variable: SteadyLake [Integer]
Define Variable: LakeChoice [Boolean]
Define Variable: LakeBotCondChoice [Integer]
Define Variable: LakeSideCondChoice [Integer]
# Index1, Column
# Index2, Row
# Index3, 1=top, 2=bottom
Define Variable: LakeElevations3DList [Integer]
Set Variable: LakeChoice:= @cbLAK@
Set Variable: ILKCBC:= @cbExpLakFlow@
If: ILKCBC
	Set Variable: ILKCBC:= 66
End if
Set Variable: ILKOUT:= @cbPrintLake@
If: ILKOUT
	Set Variable: ILKOUT:= 67
End if
Set Variable: MaxRateEq:= @adeMaxLakEquations@
Set Variable: SteadyLake:= @comboLAKSteady@
Set Variable: NSUBSTEPS:= @adeLakeNumSubSteps@
Set Variable: LakeBotCondChoice:= @comboLakeBottomCond@
Set Variable: LakeSideCondChoice:= @comboLakeSideCond@
# 
# 
Set Variable: ColumnCount:= NumColumns()
Set Variable: RowCount:= NumRows()
# 
Set Variable: CalcElev:= 0
If: RunMoc3d
	Set Variable: CalcElev:= 1
End if
If: ExportBCF
	Set Variable: CalcElev:= 1
End if
If: ExportRCH&RechargeChoice
	Set Variable: CalcElev:= 1
End if
If: ExportEVT&EvapotranspirationChoice
	Set Variable: CalcElev:= 1
End if
If: ExportRIV&RiverChoice
	Set Variable: CalcElev:= 1
End if
If: ExportDRN&DrainChoice
	Set Variable: CalcElev:= 1
End if
If: ExportStreams&StreamChoice
	Set Variable: CalcElev:= 1
End if
If: ExportHFB&HFBChoice
	Set Variable: CalcElev:= 1
End if
If: LakeChoice
	Set Variable: CalcElev:= 1
End if
Set Variable: ProgressMax:= 1
If: CalcElev
	Set Variable: ProgressMax:= ProgressMax + 3*MODFLOW_NLAY()
End if
If: NumLay>1
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NLAY()
End if
# If: TransportFlag=1 & Transport>0
# 	Set Variable: ProgressMax:= ProgressMax + MOC_ISLAY2 - MOC_ISLAY1 + 1
# 	If: ExportOBS!=0
# 		Set Variable: ProgressMax:= ProgressMax + MOC_ISLAY2 - MOC_ISLAY1 + 1
# 	End if
# End if
If: ExportBAS!=0
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NLAY() * 2 + MODFLOW_NPER()
End if
If: ExportOC!=0
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER()
End if
If: ExportBCF!=0
	Set Variable: ProgressMax:= ProgressMax + 3 * MODFLOW_NLAY()
End if
If: RechargeChoice!=0&ExportRCH!=0
	Set Variable: ProgressMax:= ProgressMax + 1
	If: NRCHOP=2
		Set Variable: ProgressMax:= ProgressMax + 1
	End if
	If: MODFLOW_NPER()>=2
		Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER() - 1
	End if
End if
If: EvapotranspirationChoice!=0&ExportEVT!=0
	Set Variable: ProgressMax:= ProgressMax + 3
	If: NEVTOP=2
		Set Variable: ProgressMax:= ProgressMax + 1
	End if
	If: MODFLOW_NPER()>=2
		Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER() - 1
	End if
End if
If: GeneralHeadChoice!=0&ExportGHB!=0
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER()
End if
If: RiverChoice!=0&ExportRIV!=0
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER()
End if
If: DrainChoice!=0&ExportDRN!=0
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER()
End if
If: WellChoice!=0&ExportWEL!=0
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER()
End if
If: ExportHFB&HFBChoice
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NLAY()
End if
If: TransportFlag=1
	If: Transport>0
		If: ExportTRANS!=0
			Set Variable: ProgressMax:= ProgressMax + 3 * (MOC_ISLAY2 - MOC_ISLAY1 + 1)
			If: RechargeChoice!=0
				Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER()
			End if
			If: ExportOBS!=0
				If: MOC_NUMOBS>0
					Set Variable: ProgressMax:= ProgressMax + MOC_ISLAY2 - MOC_ISLAY1 + 1
				End if
			End if
		End if
	End if
End if
If: LakeChoice
	Set Variable: ProgressMax:= ProgressMax + 2*MODFLOW_NLAY()
End if
Set Variable: PIEVersionOK:= MODFLOW_ProgressBarCheckVersion(1, 2, 0, 0)
If: IsNAN(PIEVersionOK)
	Alert: "Error: MODFLOW Progress Bar PIE is not installed!"
	If: !PIEVersionOK
		Alert: "Error: MODFLOW Progress Bar PIE is not up to date! Check that the correct version is installed and that there are not multiple copies of it."
	End if
End if
Evaluate expression: MODFLOW_ProgressBarInitialize(ProgressMax, 1)
Evaluate expression: MODFLOW_ProgressBarAddLine("Error and warning messages")
If: MOC_NPTPNDError
	Evaluate expression: MODFLOW_ProgressBarAddLine("Initial number of particles per cell for MOC3D is invalid")
End if
If: TopSimul=0&BotSimul=0
	Set Variable: err_geo:= 1
	# Alert: "No geologic units are specified for simulation!"
	Evaluate expression: MODFLOW_ProgressBarAddLine("No geologic units are specified for simulation!")
End if
# 
If: Transport&TransportFlag&RunMoc3d
	Set Variable: RowHeightList:= MODFLOW_L_CreateNewList()
	Set Variable: ColumnWidthList:= MODFLOW_L_CreateNewList()
	Loop for: Variable RowIndex from: MOC_ISROW1-1 to: MOC_ISROW2-1 step: 1
		Evaluate expression: MODFLOW_L_AddToList(RowHeightList, NthRowHeight(RowIndex))
	End loop
	Loop for: Variable ColumnIndex from: MOC_ISCOL1-1 to: MOC_ISCOL2-1 step: 1
		Evaluate expression: MODFLOW_L_AddToList(ColumnWidthList, NthColumnWidth(ColumnIndex))
	End loop
	If: !MODFLOW_L_IsSingPrecUniform(ColumnWidthList)
		Evaluate expression: MODFLOW_ProgressBarAddLine("Error: Column widths are not uniform in the MOC3D subgrid.")
	End if
	If: !MODFLOW_L_IsSingPrecUniform(RowHeightList)
		Evaluate expression: MODFLOW_ProgressBarAddLine("Error: Row heights are not uniform in the MOC3D subgrid.")
	End if
End if
Set Variable: FirstRowHeight:= NthRowHeight(1)
Set Variable: MinRow:= FirstRowHeight
Set Variable: MaxRow:= FirstRowHeight
Set Variable: FirstColumnWidth:= NthColumnWidth(1)
Set Variable: MinColumn:= FirstRowHeight
Set Variable: MaxColumn:= FirstColumnWidth
Loop for: Rows
	Set Variable: CurrentRowHeight:= NthRowHeight($Row$)
	Set Variable: CurrentRow:= $Row$
	If: CurrentRowHeight>MaxRow
		Set Variable: MaxRow:= CurrentRowHeight
	End if
	If: CurrentRowHeight<MinRow
		Set Variable: MinRow:= CurrentRowHeight
	End if
	If: ((CurrentRowHeight / FirstRowHeight)>1.5)|((FirstRowHeight / CurrentRowHeight)>1.5)
		Evaluate expression: MODFLOW_ProgressBarAddLine("Warning: Ratio of adjacent row heights exceeds the recommended maximum of 1.5 for Rows " +CurrentRow + " and " + (CurrentRow -1))
	End if
	Set Variable: FirstRowHeight:= CurrentRowHeight
End loop
Loop for: Columns
	Set Variable: CurrentColumnWidth:= NthColumnWidth($Column$)
	Set Variable: CurrentColumn:= $Column$
	If: CurrentColumnWidth>MaxColumn
		Set Variable: MaxColumn:= CurrentColumnWidth
	End if
	If: CurrentColumnWidth<MinColumn
		Set Variable: MinColumn:= CurrentColumnWidth
	End if
	If: ((CurrentColumnWidth / FirstColumnWidth)>1.5)|((FirstColumnWidth / CurrentColumnWidth)>1.5)
		Evaluate expression: MODFLOW_ProgressBarAddLine("Warning: Ratio of adjacent column widths exceeds the recommended maximum of 1.5 for Columns " + CurrentColumn + " and " + (CurrentColumn -1))
	End if
	Set Variable: FirstColumnWidth:= CurrentColumnWidth
End loop
If: (MaxColumn / MinRow)>10
	Evaluate expression: MODFLOW_ProgressBarAddLine("Warning: the ratio of the column width to row height exceeds the recomended maximum of 10 in some cases.")
End if
If: (MaxRow / MinColumn)>10
	Evaluate expression: MODFLOW_ProgressBarAddLine("Warning: the ratio of the row height to column width exceeds the recomended maximum of 10 in some cases.")
End if
# 
Set Variable: NumGeo:= BotSimul-TopSimul+1
Set Variable: ConcentrationList:= MODFLOW_L_CreateNewList()
Set Variable: TopElevationList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), MODFLOW_NLAY())
Set Variable: BottomElevationList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), MODFLOW_NLAY())
Set Variable: ThicknessList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), MODFLOW_NLAY())
Evaluate expression: MODFLOW_ProgressBarSetMessage("Evaluating Top Elevations")
Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
	If: ContinueSimulation
		Loop for: Blocks
			Evaluate expression: MODFLOW_L_SetOneBased3DListItem(TopElevationList, Column(), Row(), LayIndex, Elev Top Unit[LayIndex])
		End loop
	End if
End loop
Set Variable: KzList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), MODFLOW_NLAY())
If: ContinueSimulation
	If: CalcElev
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Evaluate expression: MODFLOW_ProgressBarSetMessage("Evaluating Top Elevations of Unit " + LayIndex)
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				Redirect output to: Dummy
					Export matrix: MODFLOW_L_SetOneBased3DListItem(TopElevationList, Column(), Row(), LayIndex, Elev Top Unit[LayIndex]) [G0]
				End file
				Evaluate expression: MODFLOW_Delete_File("Dummy")
			End if
		End loop
		If: ContinueSimulation
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Evaluate expression: MODFLOW_ProgressBarSetMessage("Evaluating Bottom Elevations of Unit " + LayIndex)
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation
					Redirect output to: Dummy
						Export matrix: MODFLOW_L_SetOneBased3DListItem(BottomElevationList, Column(), Row(), LayIndex, Elev Bot Unit[LayIndex]) [G0]
						If: MODFLOW_SIMUL(LayIndex)
							Export matrix: MODFLOW_L_SetOneBased3DListItem(ThicknessList, Column(), Row(), LayIndex, (MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex))/MODFLOW_NDIV(LayIndex)) [G0]
						Else
							Export matrix: MODFLOW_L_SetOneBased3DListItem(ThicknessList, Column(), Row(), LayIndex, (MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex))) [G0]
						End if
						Export matrix: If((MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)<=0)&IBOUND Unit[LayIndex], MODFLOW_ProgressBarAddLine("Negative or zero unit thickness at Unit " + LayIndex + "; Column: " + Column() + "; Row: " + Row()), 0) [G0]
					End file
					Evaluate expression: MODFLOW_Delete_File("Dummy")
				End if
			End loop
		End if
		Evaluate expression: MODFLOW_ProgressBarSetMessage("Checking for elevation errors")
		If: ContinueSimulation
			If: MODFLOW_NLAY() > 1
				Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY()-1 step: 1
					Redirect output to: Dummy
						If: MODFLOW_SpecVcont(LayIndex)
							Export matrix: If(MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)>MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex + 1)&IBOUND Unit[LayIndex]&IBOUND Unit[LayIndex+1], MODFLOW_ProgressBarAddLine("Bottom elevation at Column: " + Column() + "; Row: " + Row() + "; Unit: " + LayIndex + "is less than the top elevation of the unit beneath it."), 0) [G0]
						Else
							Export matrix: If(MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)!=MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex + 1)&IBOUND Unit[LayIndex]&IBOUND Unit[LayIndex+1], MODFLOW_ProgressBarAddLine("Bottom elevation at Column: " + Column() + "; Row: " + Row() + "; Unit: " + LayIndex + "is different from the top elevation of the unit beneath it."), 0) [G0]
						End if
					End file
					Evaluate expression: MODFLOW_Delete_File("Dummy")
				End loop
			End if
		End if
	End if
End if
If: ContinueSimulation
	If: NumLay>1
		Evaluate expression: MODFLOW_ProgressBarSetMessage("Evaluating Kz")
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				Redirect output to: Dummy
					Export matrix: MODFLOW_L_SetOneBased3DListItem(KzList, Column(), Row(), LayIndex, Kz Unit[LayIndex]) [G0]
					Export matrix: If(MODFLOW_L_GetFromOneBased3DList(KzList, Column(), Row(), LayIndex)<=0&IBOUND Unit[LayIndex], MODFLOW_ProgressBarAddLine("Negative or zero vertical hydraulic conductivity at Unit " + LayIndex + "; Column: " + Column() + "; Row: " + Row()), 0) [G0]
				End file
				Evaluate expression: MODFLOW_Delete_File("Dummy")
			End if
		End loop
	End if
End if
# 
# ----------------------------------------------------
# Specification of NameFile so that MODFLOW will run without prompting from screen.
# ----------------------------------------------------
If: ContinueSimulation
	Redirect output to: modflow.bf
		Start a new line
			Export expression: FileName [G0]
		End line
	End file
End if
# ----------------------------------------------------
# 
# ----------------------------------------------------
# Unit Numbers Used
# 10 MODFLOW Listing file
# 11 Basic Package File
# 12 Output Control File
# 13 BCF File
# 14 Recharge File
# 15 River File
# 16 Well File
# 17 Drain File
# 18 GHB File
# 19 EVT File
# 20 SIP File
# 21 SOR File
# 22 binary head file
# 23 formatted head file
# 24 binary drawdown file
# 25 formatted drawdown file
# 27 River budget file
# 28 Recharge budget file
# 29 Well budget file
# 30 Drain budget file
# 31 EVT budget file
# 32 GHB budget file
# 33 budget file
# 34 PCG File
# 35 DE4 File
# 36 Stream budget file 1
# 37 Stream budget file 2
# 38 HFB file
# 39 FHB budget file
# 40 FHB file
# 41 Stream file
# 42 Initial head source file
# 65 Lake File
# 66 Lake cell-by-cell budget file
# 67 Lake stage/budget file
# 70 MOC3D information file
# 
# The NameFile is not used in MODFLOW 88 but this can serve as a useful reference
# 
If: ContinueSimulation
	Redirect output to: @adeFileName@
		# The NameFile is the list of filenames being used in the MODFLOW simulation. These filenames are for specifying where output is to bewritten and where information is to be read.
		Start a new line
			# File for LISTING results of MODFLOW simulation
			Export expression: "LIST 10 "+FileName+".lst" [G0]
		End line
		Start a new line
			# File for reading BASIC package information
			Export expression: "BAS 11 "+FileName+".bas" [G0]
		End line
		Start a new line
			# File for reading OUTPUT CONTROL information
			Export expression: "OC 12 "+FileName+".oc" [G0]
		End line
		Start a new line
			# File for reading BCF package information
			Export expression: "BCF 13 "+FileName+".bcf" [G0]
		End line
		If: InitialHeadChoice
			Start a new line
				# File for reading initial heads
				Export expression: "DATA(BINARY) 42 " + InitialHeadName [G0]
			End line
		End if
		# 
		If: WellChoice=1
			Start a new line
				# File for reading WEL package information
				Export expression: "WEL 16 "+FileName+".wel" [G0]
			End line
		End if
		# 
		If: RechargeChoice=1
			Start a new line
				# File for reading RCH package information
				Export expression: "RCH 14 "+FileName+".rch" [G0]
			End line
		End if
		# 
		If: DrainChoice=1
			Start a new line
				# File for reading DRN package information
				Export expression: "DRN 17 "+FileName+".drn" [G0]
			End line
		End if
		# 
		If: RiverChoice=1
			Start a new line
				# File for reading RIV package information
				Export expression: "RIV 15 "+FileName+".riv" [G0]
			End line
		End if
		# 
		If: EvapotranspirationChoice=1
			Start a new line
				# File for reading EVT package information
				Export expression: "EVT 19 "+FileName+".evt" [G0]
			End line
		End if
		# 
		If: GeneralHeadChoice=1
			Start a new line
				# File for reading GHB package information
				Export expression: "GHB 18 "+FileName+".ghb" [G0]
			End line
		End if
		# 
		If: HFBChoice=1
			Start a new line
				# File for reading HFB package information
				Export expression: "HFB 38 "+FileName+".hfb" [G0]
			End line
		End if
		# 
		If: StreamChoice
			Start a new line
				# file for the stream package
				Export expression: "STR 41 " + Filename + ".str" [G0]
			End line
		End if
		If: LakeChoice
			Start a new line
				# file for the lake package
				Export expression: "LAK 65 " + Filename + ".lak" [G0]
			End line
		End if
		If: LakeChoice&ILKOUT
			Start a new line
				# file for the lake stage/budget file
				Export expression: "DATA 67 " + Filename + ".lbd" [G0]
			End line
		End if
		If: SolverChoice=0
			Start a new line
				# File for reading SIP package information
				Export expression: "SIP 20 "+FileName+".sip" [G0]
			End line
		End if
		# 
		If: SolverChoice=3
			Start a new line
				# File for reading SOR package information
				Export expression: "SOR 21 "+FileName+".sor" [G0]
			End line
		End if
		# 
		If: SolverChoice=2
			Start a new line
				# File for reading PCG information:
				Export expression: "PCG 34 "+FileName+".pcg" [G0]
			End line
		End if
		# 
		If: SolverChoice=1
			Start a new line
				# File for reading DE4 information:
				Export expression: "DE4 35 "+FileName+".de4" [G0]
			End line
		End if
		# 
		If: TransportFlag=1
			If: Transport>0
				If: RunMoc3d!=0
					Start a new line
						# File for reading MOC3D information:
						Export expression: "CONC 70 "+FileName+".mcn" [G0]
					End line
				Else
					Start a new line
						# File for reading MOC3D information:
						Export expression: "#CONC 70 "+FileName+".mcn" [G0]
					End line
				End if
			End if
		End if
		# 
		If: OutputHead=1
			Start a new line
				# File for writing heads in text format
				Export expression: "DATA(BINARY) 23 "+FileName+".bhd" [G0]
			End line
		End if
		# 
		If: OutputHead=2
			Start a new line
				# File for writing heads in binary format
				Export expression: "DATA(BINARY) 22 "+FileName+".bhd" [G0]
				Evaluate expression: MODFLOW_Delete_File(FileName+".bhd")
			End line
		End if
		# 
		If: OutputDrawdown=1
			Start a new line
				# File for writing drawdown in text format
				Export expression: "DATA(BINARY) 25 "+FileName+".bdn" [G0]
			End line
		End if
		# 
		If: OutputDrawdown=2
			Start a new line
				# File for writing drawdown in binary format
				Export expression: "DATA(BINARY) 24 "+FileName+".bdn" [G0]
				Evaluate expression: MODFLOW_Delete_File(FileName+".bdn")
			End line
		End if
		# 
		If: (OneCBCFile=1 & (IBCFCB=1|(WellChoice=1&IWELCB=1)|(RechargeChoice=1&IRCHCB=1)|(DrainChoice=1&IDRNCB=1)|(RiverChoice=1&IRIVCB=1)|(EvapotranspirationChoice=1&IEVTCB=1)|(GeneralHeadChoice=1&IGHBCB=1)|(StreamChoice=1&ISTCB1=1)|(LakeChoice=1&ILKCBC>0)))
			Start a new line
				# File for writing binary cell by cell flows
				Export expression: "DATA(BINARY) 33 "+FileName+".bud" [G0]
				Evaluate expression: MODFLOW_Delete_File(FileName+".bud")
			End line
		Else
			If: IBCFCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 33 "+FileName+".bud" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bud")
				End line
			End if
			If: WellChoice=1&IWELCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 29 "+FileName+".bwe" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bwe")
				End line
			End if
			If: RechargeChoice=1&IRCHCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 28 "+FileName+".brc" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".brc")
				End line
			End if
			If: DrainChoice=1&IDRNCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 30 "+FileName+".bdr" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bdr")
				End line
			End if
			If: RiverChoice=1&IRIVCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 27 "+FileName+".bri" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bri")
				End line
			End if
			If: EvapotranspirationChoice=1&IEVTCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 31 "+FileName+".bev" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bev")
				End line
			End if
			If: GeneralHeadChoice=1&IGHBCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 32 "+FileName+".bgh" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bgh")
				End line
			End if
			If: StreamChoice=1&ISTCB1=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 36 "+FileName+".bs1" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bs1")
				End line
			End if
			If: LakeChoice=1&ILKCBC>0
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 66 "+FileName+".blk" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".blk")
				End line
			End if
		End if
		If: StreamChoice=1&ISTCB2=1
			Start a new line
				# File for writing binary cell by cell flows
				Export expression: "DATA(BINARY) 37 "+FileName+".bs2" [G0]
				Evaluate expression: MODFLOW_Delete_File(FileName+".bs2")
			End line
		End if
	End file
End if
# 
# MOC3D Initialization
# Calculate layers in subgrid
If: ContinueSimulation
	Set Variable: n:= 1
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		If: LayIndex=MOC_ISLAY1
			Set Variable: FirstLay:= n
		End if
		If: LayIndex=MOC_ISLAY2
			Set Variable: LastLay:= n+MODFLOW_NDIV(LayIndex)-1
		End if
		Set Variable: n:= n+MODFLOW_NDIV(LayIndex)
	End loop
End if
# Set the number of columns in the subgrid for looping on matrix export
If: ContinueSimulation
	Set Variable: NColsSub:= MOC_ISCOL2-MOC_ISCOL1+1
	If: TransportFlag=1 & Transport>0
		Evaluate expression: MODFLOW_ProgressBarSetMessage("Evaluating concentrations at specified head boundaries")
		# MOC3D Concentration associated with constant-head cells calculation
		# Need even if ExportTRANS=0!!
		# Evaluate expression: MODFLOW_MOC_StartZones()
		Loop for: Variable LayIndex from: MOC_ISLAY1 to: MOC_ISLAY2 step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				If: MODFLOW_SIMUL(LayIndex)!=0
					Redirect output to: Dummy
						Export matrix: If(MODFLOW FD Grid.IBOUND Unit[LayIndex]<0, MODFLOW_L_AddToList(ConcentrationList, Interpolate(Prescribed Head Unit[LayIndex].Concentration)), 0) [G0]
					End file
					Evaluate expression: MODFLOW_Delete_File("Dummy")
				End if
			End if
		End loop
		If: ContinueSimulation
			Evaluate expression: MODFLOW_L_SortList(ConcentrationList)
			Evaluate expression: MODFLOW_L_EliminateDuplicates(ConcentrationList)
			# MOC3D NUMOBS calculation
			If: ExportOBS!=0
				Evaluate expression: MODFLOW_ProgressBarSetMessage("Evaluating MOC3D observations")
				Set Variable: MOC_NUMOBS:= 0
				Loop for: Variable LayIndex from: MOC_ISLAY1 to: MOC_ISLAY2 step: 1
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						If: LayIndex=MOC_ISLAY1
							Set Variable: M:= 0
						Else
							Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
						End if
						If: MODFLOW_SIMUL(LayIndex)!=0
							Loop for: Variable k from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								Loop for: Blocks
									Loop for: Objects in layer: MOC3D Observation Wells
										Loop for: Variable i from: 1 to: 5 step: 1
											Set Variable: WD:= MOC3D Observation Wells.Elevation[i]
											If: WD!=$N/A
												Set Variable: TempValue2:= Elevation Top Unit[LayIndex]
												Set Variable: TempValue3:= (TempValue2-Elevation Bottom Unit[LayIndex])/MODFLOW_NDIV(LayIndex)
												Set Variable: TML:= TempValue2-(DivIndex-1)*TempValue3
												Set Variable: BML:= TempValue2-DivIndex*TempValue3
												If: IsNumber(WD) & TML>WD & BML<=WD
													Set Variable: MOC_NUMOBS:= MOC_NUMOBS+1
												End if
											End if
										End loop
									End loop
								End loop
							End loop
						End if
					End if
				End loop
			End if
		End if
	End if
End if
# ----------------------------------------------------
# Basic Package:
# ----------------------------------------------------
If: ContinueSimulation
	If: ExportBAS!=0
		Evaluate expression: MODFLOW_ProgressBarSetMessage("Basic Package")
		Redirect output to: @adeFileName@.bas
			Start a new line
				Export expression: Heading1 [G0]
			End line
			Start a new line
				Export expression: Heading2 [G0]
			End line
			Start a new line
				Export expression: NumLay [I10]
				Export expression: NumRows() [I10]
				Export expression: NumColumns() [I10]
				Export expression: MODFLOW_NPER() [I10]
				Export expression: ITMUNI [I10]
			End line
			Start a new line
				Export expression: 13; [I3]
				If: WellChoice
					Export expression: 16; [I2]
				Else
					Export expression: 0; [I2]
				End if
				If: DrainChoice
					Export expression: 17; [I2]
				Else
					Export expression: 0; [I2]
				End if
				If: RiverChoice
					Export expression: 15; [I2]
				Else
					Export expression: 0; [I2]
				End if
				If: EvapotranspirationChoice
					Export expression: 19; [I2]
				Else
					Export expression: 0; [I2]
				End if
				Export expression: 0; [I2]
				Export expression: 0; [I2]
				If: RechargeChoice
					Export expression: 14; [I2]
				Else
					Export expression: 0; [I2]
				End if
				If: SolverChoice=0
					Export expression: 20; [I2]
				Else
					Export expression: 0; [I2]
				End if
				If: SolverChoice=1
					Export expression: 35; [I2]
				Else
					Export expression: 0; [I2]
				End if
				If: SolverChoice=3
					Export expression: 21; [I2]
				Else
					Export expression: 0; [I2]
				End if
				Export expression: 12; [I2]
				If: SolverChoice=2
					Export expression: 34; [I2]
				Else
					Export expression: 0; [I2]
				End if
				Export expression: 0; [I2]
				If: LakeChoice
					Export expression: 65; [I2]
				Else
					Export expression: 0; [I2]
				End if
				Export expression: 0; [I2]
				Export expression: 0; [I2]
				If: StreamChoice
					Export expression: 41; [I2]
				Else
					Export expression: 0; [I2]
				End if
				Export expression: 0; [I2]
				Export expression: 0; [I2]
				Export expression: 0; [I2]
				Export expression: 0; [I2]
				Export expression: 0; [I2]
				Export expression: 0; [I2]
			End line
			Start a new line
				Export expression: IAPART [I10]
				Export expression: ISTRT [I10]
			End line
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation
					If: MODFLOW_SIMUL(LayIndex)!=0
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Start a new line
								Export expression: 11 [I10]
								Export expression: 1 [I10]
								Set Variable: FormatString:= " (I5, " + (NumColumns()-1) + "I6)"
								Export expression: FormatString [G20]
								Export expression: 1 [I10]
							End line
							If: TransportFlag=1 & Transport>1 & LayIndex>=MOC_ISLAY1 & LayIndex<=MOC_ISLAY2
								# MOC3D case
								Export matrix: MODFLOW FD Grid.IBOUND Unit[LayIndex] * if(MODFLOW FD Grid.IBOUND Unit[LayIndex]>=0,1,MODFLOW_L_IndexOf(ConcentrationList, Interpolate(Prescribed Head Unit[LayIndex].Concentration))) [I5]
							Else
								Export matrix: MODFLOW FD Grid.IBOUND Unit[LayIndex] [I5]
							End if
						End loop
					End if
				End if
			End loop
			If: ContinueSimulation
				Start a new line
					Export expression: HNOFLO [G10]
				End line
			End if
			If: ContinueSimulation
				Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						If: MODFLOW_SIMUL(LayIndex)!=0
							If: InitialHeadChoice
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Start a new line
										# Export expression: "EXTERNAL 42 1. (BINARY) " [G0]
										# Export expression: 2 [I5]
										Export expression: 42 [I10]
										Export expression: 1. [G10]
										Set Variable: FormatString:= "                    "
										Export expression: FormatString [G20]
										Export expression: 2 [I10]
									End line
								End loop
							Else
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Start a new line
										Export expression: 11 [I10]
										Export expression: 1. [G10]
										Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
										Export expression: FormatString [G20]
										Export expression: 0 [I10]
									End line
									Export matrix: MODFLOW FD Grid.Initial Head Unit[LayIndex] [E13.5]
								End loop
							End if
						End if
					End if
				End loop
			End if
			If: ContinueSimulation
				Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						Start a new line
							Export expression: MODFLOW_PERLEN(PeriodIndex) [G10]
							Export expression: MODFLOW_NSTP(PeriodIndex) [I10]
							Export expression: MODFLOW_TSMULT(PeriodIndex) [G10]
						End line
					End if
				End loop
			End if
		End file
	End if
End if
# ----------------------------------------------------
# Output Control Package:
# ----------------------------------------------------
If: ContinueSimulation
	If: ExportOC!=0
		Evaluate expression: MODFLOW_ProgressBarSetMessage("Output Control")
		Redirect output to: @adeFileName@.oc
			Start a new line
				Export expression: 0 [I10]
				Export expression: 0 [I10]
				If: OutputHead
					If: OutputHead=1
						Export expression: 23 [I10]
					Else
						Export expression: 22 [I10]
					End if
				Else
					Export expression: 0 [I10]
				End if
				If: OutputDrawdown
					If: OutputDrawdown=1
						Export expression: 25 [I10]
					Else
						Export expression: 24 [I10]
					End if
				Else
					Export expression: 0 [I10]
				End if
			End line
			Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation
					Loop for: Variable StepIndex from: 1 to: MODFLOW_NSTP(PeriodIndex) step: 1
						Set Variable: ocflag:= 0
						If: FreqHeadList!=0
							If: (FreqHeadList<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqHeadList>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqHeadList)=0))
								Set Variable: ocflag:= 1
							End if
						End if
						# Check for printing drawdown in listing file
						If: FreqDrawdownList!=0
							If: (FreqDrawdownList<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqDrawdownList>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqDrawdownList)=0))
								Set Variable: ocflag:= 1
							End if
						End if
						# Check for printing budget in listing file
						If: FreqBudgetList!=0
							If: (FreqBudgetList<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqBudgetList>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqBudgetList)=0))
								Set Variable: ocflag:= 1
							End if
						End if
						# Check for writing head to file
						If: OutputHead!=0&FreqHeadFile!=0
							If: (FreqHeadFile<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqHeadFile>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqHeadFile)=0))
								Set Variable: ocflag:= 1
							End if
						End if
						# Check for writing drawdown to file
						If: OutputDrawdown!=0&FreqDrawdownFile!=0
							If: (FreqDrawdownFile<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqDrawdownFile>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqDrawdownFile)=0))
								Set Variable: ocflag:= 1
							End if
						End if
						# Check for writing budget to file
						If: OutputBudget=1&FreqBudgetFile!=0
							If: (FreqBudgetFile<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqBudgetFile>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex,FreqBudgetFile)=0))
								Set Variable: ocflag:= 1
							End if
						End if
						# If ocflag=1, write items to be output for period & timestep
						Start a new line
							Export expression: 0 [I10]
							If: (ocflag=1)&OutputHead
								Export expression: 1 [I10]
							Else
								Export expression: 0 [I10]
							End if
							If: (ocflag=1)&OutputDrawdown
								Export expression: 1 [I10]
							Else
								Export expression: 0 [I10]
							End if
							If: (ocflag=1)&OutputBudget
								Export expression: 1 [I10]
							Else
								Export expression: 0 [I10]
							End if
						End line
						Start a new line
							Export expression: 0 [I10]
							If: (ocflag=1)&OutputHead
								Export expression: 1 [I10]
							Else
								Export expression: 0 [I10]
							End if
							If: (ocflag=1)&OutputDrawdown
								Export expression: 1 [I10]
							Else
								Export expression: 0 [I10]
							End if
							If: (ocflag=1)&OutputBudget
								Export expression: 1 [I10]
							Else
								Export expression: 0 [I10]
							End if
						End line
						Start a new line
							If: (ocflag=1)&OutputHead
								Export expression: 1 [I10]
							Else
								Export expression: 0 [I10]
							End if
							If: (ocflag=1)&OutputDrawdown
								Export expression: 1 [I10]
							Else
								Export expression: 0 [I10]
							End if
							If: (ocflag=1)&OutputHead
								Export expression: 1 [I10]
							Else
								Export expression: 0 [I10]
							End if
							If: (ocflag=1)&OutputDrawdown
								Export expression: 1 [I10]
							Else
								Export expression: 0 [I10]
							End if
						End line
					End loop
				End if
			End loop
		End file
	End if
End if
# ----------------------------------------------------
# Block-Centered Flow Package:
# ----------------------------------------------------
If: ContinueSimulation
	If: ExportBCF!=0
		Evaluate expression: MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package")
		Redirect output to: @adeFileName@.bcf
			Evaluate expression: MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Item 1")
			# Data item 1
			Start a new line
				Export expression: ISS [I10]
				If: IBCFCB=0
					Export expression: 0 [I10]
				End if
				If: IBCFCB!=0
					Export expression: 33 [I10]
				End if
				Export expression: HDRY [G10]
				Export expression: IWDFLG [I10]
				Export expression: WETFCT [G10]
				Export expression: IWETIT [I10]
				Export expression: IHDWET [I10]
			End line
			# Data item 2
			Set Variable: ModflowLayer:= 0
			Set Variable: LayconString:= ""
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Evaluate expression: MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: LAYCON")
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation
					If: MODFLOW_SIMUL(LayIndex)!=0
						If: MODFLOW_LAYCON(LayIndex)=1&LayIndex!=TopSimul
							Set Variable: err_bcf_1:= 1
							# Alert: "Only the top simulated geologic unit can be unconfined!"
							Evaluate expression: MODFLOW_ProgressBarAddLine("Layer " + LayIndex + " is unconfined but only the top simulated geologic unit can be unconfined!")
						End if
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Set Variable: ModflowLayer:= ModflowLayer + 1
							If: MODFLOW_LAYCON(LayIndex)=1&DivIndex!=1
								Set Variable: LayconString:= LayconString + MODFLOW_AVEMETHOD(LayIndex)
								Set Variable: LayconString:= LayconString + 3
							Else
								Set Variable: LayconString:= LayconString + MODFLOW_AVEMETHOD(LayIndex)
								Set Variable: LayconString:= LayconString + MODFLOW_LAYCON(LayIndex)
							End if
							If: ModflowLayer = 40
								Start a new line
									Export expression: LayconString [G0]
									Set Variable: LayconString:= ""
								End line
							End if
						End loop
					End if
				End if
			End loop
			If: ContinueSimulation
				If: ModflowLayer != 40
					Start a new line
						Export expression: LayconString [G0]
					End line
				End if
			End if
			Evaluate expression: MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Anisotropy")
			# Data item 3
			If: ContinueSimulation
				Start a new line
					Export expression: 13 [I10]
					Export expression: 1. [G10]
					Set Variable: FormatString:= " (E13.5)"
					Export expression: FormatString [G20]
					Export expression: 0 [I10]
				End line
			End if
			If: ContinueSimulation
				Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						If: MODFLOW_SIMUL(LayIndex)!=0
							Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								Start a new line
									Export expression: MODFLOW_TRPY(LayIndex) [E13.5]
								End line
							End loop
						End if
					End if
				End loop
			End if
			# Data item 4
			If: ContinueSimulation
				Start a new line
					Export expression: 13 [I10]
					Export expression: 1. [G10]
					Set Variable: FormatString:= " (E13.5)"
					Export expression: FormatString [G20]
					Export expression: 0 [I10]
				End line
				Evaluate expression: MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Columns positions")
				Loop for: Columns
					If: $Column$<NumColumns()
						Start a new line
							Export expression: Abs(NthColumnPos($Column$+1)-NthColumnPos($Column$)) [E13.5]
						End line
					End if
				End loop
				# Data item 5
				Start a new line
					Export expression: 13 [I10]
					Export expression: 1. [G10]
					Set Variable: FormatString:= " (E13.5)"
					Export expression: FormatString [G20]
					Export expression: 0 [I10]
				End line
				Evaluate expression: MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Row positions")
				Loop for: Rows
					If: $Row$<NumRows()
						Start a new line
							Export expression: Abs(NthRowPos($Row$+1)-NthRowPos($Row$)) [E13.5]
						End line
					End if
				End loop
			End if
			If: ContinueSimulation
				Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						If: MODFLOW_SIMUL(LayIndex)!=0
							If: ISS=0
								Evaluate expression: MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Storage parameters")
							End if
							Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								If: ISS=0
									# Data item 6
									Evaluate expression: MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: storage")
									If: ((MODFLOW_LAYCON(LayIndex)=1)&(DivIndex=1))
										Start a new line
											Export expression: 13 [I10]
											Export expression: 1. [G10]
											Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
											Export expression: FormatString [G20]
											Export expression: 0 [I10]
										End line
									Else
										Start a new line
											Export expression: 13 [I10]
											Export expression: 1. [G10]
											Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
											Export expression: FormatString [G20]
											Export expression: 0 [I10]
										End line
									End if
									# Modified June 16, 1997
									If: MODFLOW_LAYCON(LayIndex)=0
										Export matrix: MODFLOW FD Grid.Sp_Storage Unit[LayIndex]*MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex) [E13.5]
									End if
									If: ((MODFLOW_LAYCON(LayIndex)=1)&(MODFLOW_NDIV(LayIndex)>1))|MODFLOW_LAYCON(LayIndex)=2|MODFLOW_LAYCON(LayIndex)=3
										Export matrix: MODFLOW FD Grid.Sp_Storage Unit[LayIndex]*MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex) [E13.5]
									End if
									If: ((MODFLOW_LAYCON(LayIndex)=1)&(MODFLOW_NDIV(LayIndex)=1))
										Export matrix: MODFLOW FD Grid.Sp_Yield Unit[LayIndex] [E13.5]
									End if
								End if
								If: MODFLOW_LAYCON(LayIndex)=0|MODFLOW_LAYCON(LayIndex)=2
									# Data item 7
									Start a new line
										Export expression: 13 [I10]
										Export expression: 1. [G10]
										Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
										Export expression: FormatString [G20]
										Export expression: 0 [I10]
									End line
									Evaluate expression: MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Transmissivity " + LayIndex)
									Export matrix: MODFLOW FD Grid.Kx Unit[LayIndex]*MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex) [E13.5]
								Else
									# Data item 8
									# YBI: note that the next matrix is different for each sub division!
									Start a new line
										Export expression: 13 [I10]
										Export expression: 1. [G10]
										Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
										Export expression: FormatString [G20]
										Export expression: 0 [I10]
									End line
									Evaluate expression: MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Hydraulic conductivity")
									Export matrix: MODFLOW FD Grid.Kx Unit[LayIndex] [E13.5]
									# Data item 9
									Start a new line
										Export expression: 13 [I10]
										Export expression: 1. [G10]
										Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
										Export expression: FormatString [G20]
										Export expression: 0 [I10]
									End line
									Export matrix: MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-DivIndex*(MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)) [E13.5]
								End if
								# Data item 10
								If: DivIndex<MODFLOW_NDIV(LayIndex)|LayIndex<MODFLOW_NLAY()
									Start a new line
										Export expression: 13 [I10]
										Export expression: 1. [G10]
										Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
										Export expression: FormatString [G20]
										Export expression: 0 [I10]
									End line
									Evaluate expression: MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: VCONT")
									If: DivIndex<MODFLOW_NDIV(LayIndex)
										If: MODFLOW_SpecVcont(LayIndex)
											Export matrix: Vert Cond Unit[LayIndex] [E13.5]
										Else
											Export matrix: MODFLOW FD Grid.Kz Unit[LayIndex]/(MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)) [E13.5]
										End if
									Else
										If: MODFLOW_SpecVcont(LayIndex)
											Export matrix: Vert Cond Unit[LayIndex] [E13.5]
										Else
											Set Variable: ocflag:= 0
											Loop for: Variable k from: LayIndex+1 to: BotSimul step: 1
												If: MODFLOW_SIMUL(k)!=0&ocflag=0
													Set Variable: M:= k
													Set Variable: ocflag:= 1
												End if
											End loop
											Set Variable: ResultList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), 1)
											Loop for: Variable k from: LayIndex to: M step: 1
												Set Variable: TempThickListStart:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), 1)
											End loop
											Set Variable: TempThickListStart:= TempThickListStart - (M - LayIndex)
											Loop for: Variable k from: LayIndex to: M step: 1
												Set Variable: TempKzListStart:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), 1)
											End loop
											Set Variable: TempKzListStart:= TempKzListStart - (M - LayIndex)
											Set Variable: TempThickIndex:= TempThickListStart - 1
											Set Variable: TempKzListIndex:= TempKzListStart - 1
											Loop for: Variable k from: LayIndex to: M step: 1
												Set Variable: TempThickIndex:= TempThickIndex + 1
												Set Variable: TempKzListIndex:= TempKzListIndex + 1
												Redirect output to: Dummy
													Export matrix: MODFLOW_L_SetOneBased3DListItem(TempThickIndex, Column(), Row(), 1, MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), k)) [E13.5]
													Export matrix: MODFLOW_L_SetOneBased3DListItem(TempKzListIndex, Column(), Row(), 1, MODFLOW_L_GetFromOneBased3DList(KzList, Column(), Row(), k)) [E13.5]
												End file
												Evaluate expression: MODFLOW_Delete_File("Dummy")
												If: (k=LayIndex)|(k=M)
													Evaluate expression: MODFLOW_L_Multipy3DByConstant(TempThickIndex, TempThickIndex, 0.5)
												End if
											End loop
											Loop for: Blocks
												Set Variable: ocflag:= 1
												Set Variable: TempThickIndex:= TempThickListStart - 1
												Set Variable: TempKzListIndex:= TempKzListStart - 1
												Set Variable: DumCol:= Column()
												Set Variable: DumRow:= Row()
												Loop for: Variable k from: LayIndex to: M step: 1
													If: ocflag
														Set Variable: TempThickIndex:= TempThickIndex + 1
														Set Variable: TempKzListIndex:= TempKzListIndex + 1
														Set Variable: TempValue1:= MODFLOW_L_GetFromOneBased3DList(TempThickIndex, DumCol, DumRow, 1)
														Set Variable: TempValue2:= MODFLOW_L_GetFromOneBased3DList(TempKzListIndex, DumCol, DumRow, 1)
														If: (TempValue1=0)|(TempValue2=0)
															Evaluate expression: MODFLOW_L_SetOneBased3DListItem(ResultList, DumCol, DumRow, 1, 0)
															Set Variable: ocflag:= 0
														Else
															Evaluate expression: MODFLOW_L_SetOneBased3DListItem(ResultList, DumCol, DumRow, 1, TempValue1 / TempValue2 + MODFLOW_L_GetFromOneBased3DList(ResultList, DumCol, DumRow, 1))
														End if
													End if
												End loop
											End loop
											Evaluate expression: MODFLOW_L_Invert3DListMembers(ResultList, ResultList)
											Export matrix: MODFLOW_L_GetFromOneBased3DList(ResultList, Column(), Row(), 1) [E13.5]
											Evaluate expression: MODFLOW_L_FreeA3DList(ResultList)
											Set Variable: TempThickIndex:= TempThickListStart - 1
											Set Variable: TempKzListIndex:= TempKzListStart - 1
											Loop for: Variable k from: LayIndex to: M step: 1
												Set Variable: TempThickIndex:= TempThickIndex + 1
												Set Variable: TempKzListIndex:= TempKzListIndex + 1
												Evaluate expression: MODFLOW_L_FreeA3DList(TempThickIndex)
												Evaluate expression: MODFLOW_L_FreeA3DList(TempKzListIndex)
											End loop
										End if
									End if
								End if
								Redirect output to: Dummy
									Export matrix: If(MODFLOW FD Grid.Kx Unit[LayIndex]<0, MODFLOW_ProgressBarAddLine("Error: Kx in Unit " + LayIndex + ", Row " + Row() + ", Column " + Column() + " is negative."), 0) [G0]
								End file
								Evaluate expression: MODFLOW_Delete_File("Dummy")
								# Data item 11
								If: ISS=0&(MODFLOW_LAYCON(LayIndex)=2|MODFLOW_LAYCON(LayIndex)=3|(MODFLOW_LAYCON(LayIndex)=1&DivIndex>1))
									Start a new line
										Export expression: 13 [I10]
										Export expression: 1. [G10]
										Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
										Export expression: FormatString [G20]
										Export expression: 0 [I10]
									End line
									If: ((MODFLOW_LAYCON(LayIndex)=1)&(MODFLOW_NDIV(LayIndex)>1))|MODFLOW_LAYCON(LayIndex)=2|MODFLOW_LAYCON(LayIndex)=3
										If: ((MODFLOW_LAYCON(LayIndex)=1)&(MODFLOW_NDIV(LayIndex)>1))
											Export matrix: MODFLOW FD Grid.Sp_Yield Unit[LayIndex] [E13.5]
										End if
									Else
										Export matrix: MODFLOW FD Grid.Sp_Yield Unit[LayIndex] [E13.5]
									End if
									Redirect output to: Dummy
										Export matrix: If((MODFLOW FD Grid.Sp_Yield Unit[LayIndex]>1)|(MODFLOW FD Grid.Sp_Yield Unit[LayIndex]<0), MODFLOW_ProgressBarAddLine("Error: Specific Yield in Unit " + LayIndex + ", Row " + Row() + ", Column " + Column() + " is negative or greater than 1."), 0) [G0]
									End file
									Evaluate expression: MODFLOW_Delete_File("Dummy")
								End if
								# Data item 12
								If: MODFLOW_LAYCON(LayIndex)=2|MODFLOW_LAYCON(LayIndex)=3|(MODFLOW_LAYCON(LayIndex)=1&DivIndex>1)
									Start a new line
										Export expression: 13 [I10]
										Export expression: 1. [G10]
										Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
										Export expression: FormatString [G20]
										Export expression: 0 [I10]
									End line
									# Export matrix: MODFLOW FD Grid.Elev Top Unit[LayIndex]-(DivIndex-1)*(MODFLOW FD Grid.Thickness Unit[LayIndex]/MODFLOW_NDIV(LayIndex)) [E13.5]
									Export matrix: MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-(DivIndex-1)*(MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)) [E13.5]
								End if
								# Data item 13
								If: IWDFLG!=0&(MODFLOW_LAYCON(LayIndex)=1|MODFLOW_LAYCON(LayIndex)=3)
									Start a new line
										Export expression: 13 [I10]
										Export expression: 1. [G10]
										Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
										Export expression: FormatString [G20]
										Export expression: 0 [I10]
									End line
									Export matrix: MODFLOW FD Grid.Wetting Unit[LayIndex] [E13.5]
								End if
							End loop
						End if
					End if
				End loop
			End if
		End file
	End if
End if
# ----------------------------------------------------
# Recharge Package:
# ----------------------------------------------------
If: ContinueSimulation
	If: RechargeChoice!=0&ExportRCH!=0
		Evaluate expression: MODFLOW_ProgressBarSetMessage("Recharge Package")
		Redirect output to: @adeFileName@.rch
			Start a new line
				# Export NRCHOP
				Export expression: NRCHOP [I10]
				If: IRCHCB>0&OneCBCFile=1
					Export expression: 33; [I10]
				End if
				If: IRCHCB>0&OneCBCFile=0
					Export expression: 28; [I10]
				End if
				If: IRCHCB=0
					Export expression: 0; [I10]
				End if
				If: MODPATHChoice
					Export expression: RechargeITOP [G0]
				End if
			End line
			# Stress period 1
			Start a new line
				Export expression: 1 [I10]
				If: NRCHOP=2
					Export expression: 1 [I10]
				End if
				If: NRCHOP!=2
					Export expression: -1 [I10]
				End if
			End line
			# Export Recharge flux for stress period 1
			Start a new line
				Export expression: 14 [I10]
				Export expression: 1. [G10]
				Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
				Export expression: FormatString [G20]
				Export expression: 0 [I10]
			End line
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				Export matrix: Recharge.Stress1 [E13.5]
				# Export Layer number of recharge if NRCHOP=2
				If: NRCHOP=2
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						Start a new line
							Export expression: 14 [I10]
							Export expression: 1 [G10]
							Set Variable: FormatString:= " (I5, " + (NumColumns()-1) + "I6)"
							Export expression: FormatString [G20]
							Export expression: 0 [I10]
						End line
						If: @cbRechLayer@
							Export matrix: Recharge Layer [I5]
						Else
							Loop for: Blocks
								Set Variable: ocflag:= 0
								If: Recharge.Stress1!=0&(Recharge Elevation<=MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), 1)&Recharge Elevation>MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), MODFLOW_NLAY()))
									Set Variable: M:= 0
									Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
										If: ocflag=0
											If: LayIndex=1
												Set Variable: M:= 0
											Else
												Set Variable: M:= M+MODFLOW_NDIV(LayIndex-1)*MODFLOW_SIMUL(LayIndex-1)
											End if
											If: Recharge Elevation<=MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)&Recharge Elevation>MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
												Set Variable: ocflag:= 1
												If: MODFLOW_SIMUL(LayIndex)!=0
													Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
														Set Variable: CellThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
														If: (Recharge Elevation<=MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-(DivIndex-1)*CellThickness)&(Recharge Elevation>(MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-DivIndex*CellThickness))
															Set Variable: k:= M+DivIndex
															Start a new line
																Export expression: k [I5]
															End line
														End if
													End loop
												Else
													Start a new line
														Set Variable: err_rch_1:= 1
														# Alert: "Recharge elevation is located in a non-simulated geologic unit!"
														Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + Column() + " and Row " + Row() +  ", recharge elevation is located in a non-simulated geologic unit!")
														Export expression: 999 [I5]
													End line
												End if
											End if
										End if
									End loop
								Else
									Start a new line
										Export expression: 1 [I10]
									End line
								End if
							End loop
						End if
					End if
				End if
			End if
			If: MODFLOW_NPER()>=2
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation
					Loop for: Variable PeriodIndex from: 2 to: MODFLOW_NPER() step: 1
						If: SteadyRecharge=0
							Start a new line
								Export expression: -1 [I10]
								Export expression: -1 [I10]
							End line
						Else
							Start a new line
								Export expression: 1 [I10]
								# assume recharge elevation does not change if NRCHOP=2
								Export expression: -1 [I10]
							End line
							# Export Recharge flux for stress period
							Start a new line
								Export expression: 14 [I10]
								Export expression: 1. [G10]
								Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
								Export expression: FormatString [G20]
								Export expression: 0 [I10]
							End line
							Export matrix: Recharge.Stress[PeriodIndex] [E13.5]
							Set Variable: RechargeTest:= 0
							Loop for: Blocks
								If: Recharge.Stress[PeriodIndex]<0
									Set Variable: RechargeTest:= 1
								End if
							End loop
							If: RechargeTest
								Evaluate expression: MODFLOW_ProgressBarAddLine("Warning: one or more recharge values in Stress Period " + PeriodIndex + " is negative.")
							End if
						End if
					End loop
				End if
			End if
		End file
	End if
End if
# ----------------------------------------------------
# Export for EVT Package:
# ----------------------------------------------------
If: ContinueSimulation
	If: EvapotranspirationChoice!=0&ExportEVT!=0
		Evaluate expression: MODFLOW_ProgressBarSetMessage("Evapotranspiration Package")
		Redirect output to: @adeFileName@.evt
			Start a new line
				# Export NEVTOP
				Export expression: NEVTOP [I10]
				If: IEVTCB>0&OneCBCFile=1
					Export expression: 33; [I10]
				End if
				If: IEVTCB>0&OneCBCFile=0
					Export expression: 31; [I10]
				End if
				If: IEVTCB=0
					Export expression: 0; [I10]
				End if
				If: MODPATHChoice
					Export expression: EvapITOP [G0]
				End if
			End line
			# Stress period 1
			Start a new line
				Export expression: 1 [I10]
				Export expression: 1 [I10]
				Export expression: 1 [I10]
				If: NEVTOP=2
					Export expression: 1 [I10]
				End if
				If: NEVTOP!=2
					Export expression: -1 [I10]
				End if
			End line
			# Export ET surface for stress period 1
			Start a new line
				Export expression: 19 [I10]
				Export expression: 1. [G10]
				Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
				Export expression: FormatString [G20]
				Export expression: 0 [I10]
			End line
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				Export matrix: Evapotranspiration [E13.5]
				# Export ET rate for stress period 1
				Start a new line
					Export expression: 19 [I10]
					Export expression: 1. [G10]
					Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
					Export expression: FormatString [G20]
					Export expression: 0 [I10]
				End line
			End if
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				Export matrix: Evapotranspiration.EVT Flux Stress1 [E13.5]
				# Export ET extinction depth for stress period 1
				Start a new line
					Export expression: 19 [I10]
					Export expression: 1. [G10]
					Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
					Export expression: FormatString [G20]
					Export expression: 0 [I10]
				End line
			End if
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				Export matrix: Evapotranspiration.EVT Extinction Depth [E13.5]
				# Export Layer number where ET is removed if NEVTOP=2
				If: NEVTOP=2
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						Start a new line
							Export expression: 19 [I10]
							Export expression: 1 [G10]
							Set Variable: FormatString:= " (I5, " + (NumColumns()-1) + "I6)"
							Export expression: FormatString [G20]
							Export expression: 0 [I10]
						End line
						If: @cbETLayer@
							Export matrix: ET Layer [I5]
						Else
							Loop for: Blocks
								Set Variable: ocflag:= 0
								If: Evapotranspiration.EVT Flux Stress1!=0&(ET Surface Elevation<=MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), 1)&ET Surface Elevation>MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), MODFLOW_NLAY()))
									Set Variable: M:= 0
									Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
										If: ocflag=0
											If: LayIndex=1
												Set Variable: M:= 0
											Else
												Set Variable: M:= M+MODFLOW_NDIV(LayIndex-1)*MODFLOW_SIMUL(LayIndex-1)
											End if
											If: ET Surface Elevation<=MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)&ET Surface Elevation>MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
												Set Variable: ocflag:= 1
												If: MODFLOW_SIMUL(LayIndex)!=0
													Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
														Set Variable: CellThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
														If: ET Surface Elevation<=(MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-(DivIndex-1)*CellThickness)&ET Surface Elevation>(MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-DivIndex*CellThickness)
															Set Variable: k:= M+DivIndex
															Start a new line
																Export expression: k [I5]
															End line
														End if
													End loop
												Else
													Start a new line
														Set Variable: err_evt_1:= 1
														# Alert: "Evapotranspiration surface is located in a non-simulated geologic unit!"
														Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + Column() + " and Row " + Row() +  ", the evapotranspiration surface is located in a non-simulated geologic unit!")
														Export expression: 999 [I5]
													End line
												End if
											End if
										End if
									End loop
								Else
									Start a new line
										Export expression: 1 [I10]
									End line
								End if
							End loop
						End if
					End if
				End if
			End if
			If: ContinueSimulation
				If: MODFLOW_NPER()>=2
					# Modified next line on June 16, 1997
					Loop for: Variable PeriodIndex from: 2 to: MODFLOW_NPER() step: 1
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
						If: ContinueSimulation
							If: SteadyEVT=0
								Start a new line
									Export expression: -1 [I10]
									Export expression: -1 [I10]
									Export expression: -1 [I10]
									Export expression: -1 [I10]
								End line
							Else
								Start a new line
									# assume ET surface and extinction depth do not change if NEVTOP=2
									Export expression: -1 [I10]
									Export expression: 1 [I10]
									Export expression: -1 [I10]
									Export expression: -1 [I10]
								End line
								# Export ET flux for stress period
								Start a new line
									Export expression: 19 [I10]
									Export expression: 1. [G10]
									Set Variable: FormatString:= " (E13.5, " + (NumColumns()-1) + "E14.5)"
									Export expression: FormatString [G20]
									Export expression: 0 [I10]
								End line
								Export matrix: Evapotranspiration.EVT Flux Stress[PeriodIndex] [E13.5]
							End if
						End if
					End loop
				End if
			End if
		End file
	End if
End if
# ----------------------------------------------------
# GHB Package
# ----------------------------------------------------
If: ContinueSimulation
	If: GeneralHeadChoice!=0&ExportGHB!=0
		Evaluate expression: MODFLOW_ProgressBarSetMessage("General-Head Boundary Package")
		Redirect output to: @adeFileName@.ghb
		End file
		Set Variable: CurrentGHBCount:= 0
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				If: LayIndex=1
					Set Variable: M:= 0
				Else
					Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
				End if
				# 
				# 
				If: MODFLOW_SIMUL(LayIndex)!=0
					# 
					# Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
					# YBI moved this line into the loop to prevent array overflow
					# Set Variable: Block_Num:= (L-1)*NumRows()*NumColumns()
					Loop for: Blocks
						Set Variable: AreaBoundaryInBlock:= 0
						# 
						# Set Variable: Block_Num:= Block_Num+1
						# If: Chk_BlockArrayGet(Block_Num)=1
						# 
						Set Variable: DumRow:= Row()
						Set Variable: DumCol:= Column()
						# 
						Loop for: Objects in layer: POINT GEN HEAD BOUND UNIT[LayIndex]
							Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								Set Variable: DumLay:= M+DivIndex
								Set Variable: CurrentGHBCount:= CurrentGHBCount + 1
								Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
									If: !(PeriodIndex>1&SteadyGHB=0)
										Redirect output to: TempGHBPer
											Start a new line
												Export expression: DumLay [I10]
												Export expression: DumRow [I10]
												Export expression: DumCol; [I10]
												Export expression: Point Gen Head Bound Unit[LayIndex].Head Stress[PeriodIndex]; [G9]
												Export expression: Point Gen Head Bound Unit[LayIndex].Conductance; [G9]
												# MODPATH
												If: MODPATHChoice
													Export expression: Point Gen Head Bound Unit[LayIndex].IFACE[PeriodIndex]; [G0]
												End if
												# MOC3D Data
												If: TransportFlag=1 & Transport>0
													Export expression: Point Gen Head Bound Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
												End if
											End line
										End file
										Evaluate expression: MODFLOW_Join_Files("TempGHBPer" + PeriodIndex, "TempGHBPer", "TempGHBPer" + PeriodIndex)
									End if
								End loop
							End loop
						End loop
						# 
						If: @cbAltGHB@
							Set Variable: ThisConductance:= WSumObjectsInBlock(Line Gen Head Bound Unit[LayIndex].Conductance)
							If: ThisConductance
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Set Variable: DumLay:= M+DivIndex
									Set Variable: CurrentGHBCount:= CurrentGHBCount + 1
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyGHB=0)
											Redirect output to: TempGHBPer
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol; [I10]
													Export expression: Line Gen Head Bound Unit[LayIndex].Head Stress[PeriodIndex]; [G9]
													Export expression: ThisConductance; [G9]
													# MODPATH
													If: MODPATHChoice
														Export expression: Line Gen Head Bound Unit[LayIndex].IFACE[PeriodIndex]; [G0]
													End if
													# MOC3D Data
													If: TransportFlag=1 & Transport>0
														Export expression: Line Gen Head Bound Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempGHBPer" + PeriodIndex, "TempGHBPer", "TempGHBPer" + PeriodIndex)
										End if
									End loop
								End loop
							End if
							If: (Area Gen Head Bound Unit[LayIndex].Conductance!=$N/A)
								Set Variable: ContourArea:= BlockArea()
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Set Variable: DumLay:= M+DivIndex
									Set Variable: CurrentGHBCount:= CurrentGHBCount + 1
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyGHB=0)
											Redirect output to: TempGHBPer
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol; [I10]
													Export expression: Area Gen Head Bound Unit[LayIndex].Head Stress[PeriodIndex]; [G9]
													Export expression: ContourArea*Area Gen Head Bound Unit[LayIndex].Conductance; [G9]
													# MODPATH
													If: MODPATHChoice
														Export expression: Area Gen Head Bound Unit[LayIndex].IFACE[PeriodIndex]; [G0]
													End if
													# MOC3D Data
													If: TransportFlag=1 & Transport>0
														Export expression: Area Gen Head Bound Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempGHBPer" + PeriodIndex, "TempGHBPer", "TempGHBPer" + PeriodIndex)
										End if
									End loop
								End loop
							End if
						Else
							Loop for: Objects in layer: LINE GEN HEAD BOUND UNIT[LayIndex]
								Set Variable: SegmentLength:= ContourIntersectLength()
								If: SegmentLength>0
									Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
										Set Variable: DumLay:= M+DivIndex
										Set Variable: CurrentGHBCount:= CurrentGHBCount + 1
										Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
											If: !(PeriodIndex>1&SteadyGHB=0)
												Redirect output to: TempGHBPer
													Start a new line
														Export expression: DumLay [I10]
														Export expression: DumRow [I10]
														Export expression: DumCol; [I10]
														Export expression: Line Gen Head Bound Unit[LayIndex].Head Stress[PeriodIndex]; [G9]
														Export expression: SegmentLength*Line Gen Head Bound Unit[LayIndex].Conductance; [G9]
														# MODPATH
														If: MODPATHChoice
															Export expression: Line Gen Head Bound Unit[LayIndex].IFACE[PeriodIndex]; [G0]
														End if
														# MOC3D Data
														If: TransportFlag=1 & Transport>0
															Export expression: Line Gen Head Bound Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
														End if
													End line
												End file
												Evaluate expression: MODFLOW_Join_Files("TempGHBPer" + PeriodIndex, "TempGHBPer", "TempGHBPer" + PeriodIndex)
											End if
										End loop
									End loop
								End if
							End loop
							# 
							Loop for: Objects in layer: AREA GEN HEAD BOUND UNIT[LayIndex]
								Set Variable: AreaBoundaryInBlock:= 1
								Set Variable: ContourArea:= ContourIntersectArea()
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Set Variable: DumLay:= M+DivIndex
									Set Variable: CurrentGHBCount:= CurrentGHBCount + 1
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyGHB=0)
											Redirect output to: TempGHBPer
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol; [I10]
													Export expression: Area Gen Head Bound Unit[LayIndex].Head Stress[PeriodIndex]; [G9]
													Export expression: ContourArea*Area Gen Head Bound Unit[LayIndex].Conductance; [G9]
													# MODPATH
													If: MODPATHChoice
														Export expression: Area Gen Head Bound Unit[LayIndex].IFACE[PeriodIndex]; [G0]
													End if
													# MOC3D Data
													If: TransportFlag=1 & Transport>0
														Export expression: Area Gen Head Bound Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempGHBPer" + PeriodIndex, "TempGHBPer", "TempGHBPer" + PeriodIndex)
										End if
									End loop
								End loop
							End loop
							If: (!AreaBoundaryInBlock)&(Area Gen Head Bound Unit[LayIndex].Conductance!=$N/A)
								Set Variable: ContourArea:= BlockArea()
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Set Variable: DumLay:= M+DivIndex
									Set Variable: CurrentGHBCount:= CurrentGHBCount + 1
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyGHB=0)
											Redirect output to: TempGHBPer
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol; [I10]
													Export expression: Area Gen Head Bound Unit[LayIndex].Head Stress[PeriodIndex]; [G9]
													Export expression: ContourArea*Area Gen Head Bound Unit[LayIndex].Conductance; [G9]
													# MODPATH
													If: MODPATHChoice
														Export expression: Area Gen Head Bound Unit[LayIndex].IFACE[PeriodIndex]; [G0]
													End if
													# MOC3D Data
													If: TransportFlag=1 & Transport>0
														Export expression: Area Gen Head Bound Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempGHBPer" + PeriodIndex, "TempGHBPer", "TempGHBPer" + PeriodIndex)
										End if
									End loop
								End loop
							End if
						End if
						# 
					End loop
					# End loop
					# 
					# End if
					# 
				End if
			End if
		End loop
		# End if
		# End file
		Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
			Redirect output to: TempGHB1
				If: PeriodIndex>1&SteadyGHB=0
					Start a new line
						Export expression: -1 [I10]
					End line
				Else
					Start a new line
						Export expression: CurrentGHBCount [I10]
					End line
				End if
			End file
			If: CurrentGHBCount>MaxGHBs
				Set Variable: MaxGHBs:= CurrentGHBCount
			End if
			If: !(PeriodIndex>1&SteadyGHB=0)
				Evaluate expression: MODFLOW_Join_Files("TempGHB1", "TempGHBPer" + PeriodIndex, "TempGHB1")
				Evaluate expression: MODFLOW_Delete_File("TempGHBPer" + PeriodIndex)
			End if
			Evaluate expression: MODFLOW_Join_Files("@adeFileName@.ghb", "TempGHB1", "@adeFileName@.ghb")
			# End if
		End loop
		Redirect output to: TempGHB1
			Start a new line
				Export expression: MaxGHBs [I10]
				If: IGHBCB>0&OneCBCFile=1
					Export expression: 33; [I10]
				End if
				If: IGHBCB>0&OneCBCFile=0
					Export expression: 32; [I10]
				End if
				If: IGHBCB=0
					Export expression: 0; [I10]
				End if
				# MODPATH
				If: MODPATHChoice
					Export expression: " AUXILIARY IFACE" [G0]
				End if
				# MOC3D AUX parameter
				If: TransportFlag=1 & Transport>0
					Export expression: " CBCALLOCATE AUXILIARY CONCENTRATION" [G0]
				End if
			End line
		End file
		Evaluate expression: MODFLOW_Join_Files("TempGHB1", "@adeFileName@.ghb", "@adeFileName@.ghb")
		# 
		Evaluate expression: MODFLOW_Delete_File("TempGHB1")
		Evaluate expression: MODFLOW_Delete_File("TempGHBPer")
		# Evaluate expression: Chk_LayArrayDispose()
		# Evaluate expression: Chk_BlockArrayDispose()
		# End if
		# 
	End if
End if
# ----------------------------------------------------
# River Package
# ----------------------------------------------------
If: ContinueSimulation
	If: RiverChoice!=0&ExportRIV!=0
		Evaluate expression: MODFLOW_ProgressBarSetMessage("River Package")
		Redirect output to: @adeFileName@.riv
		End file
		# YBI syntax: Define->Set
		Set Variable: err_line:= 0
		Set Variable: err_area1:= 0
		Set Variable: err_area2:= 0
		Set Variable: RIV_MXRIVR:= 0
		Set Variable: CurrentRiverCount:= 0
		# Redirect output to: TempRiver2
		# If: !(PeriodIndex>1&SteadyRiver=0)
		# 	Set Variable: L:= 0
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				If: LayIndex=1
					Set Variable: M:= 0
				Else
					Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
				End if
				# 
				If: MODFLOW_SIMUL(LayIndex)!=0
					# 
					# Set Variable: L:= L+1
					# If: Chk_LayArrayGet(L)=1
					# Set Variable: Block_Num:= (L-1)*NumRows()*NumColumns()
					# 
					Loop for: Blocks
						# Set Variable: Block_Num:= Block_Num+1
						# If: Chk_BlockArrayGet(Block_Num)=1
						Set Variable: DumRow:= Row()
						Set Variable: DumCol:= Column()
						Set Variable: AreaBoundaryInBlock:= 0
						If: @cbAltRiv@
							If: WSumObjectsInBlock(Line River Unit[LayIndex].Conductance)!=0
								If: Line River Unit[LayIndex].Bottom Elevation>=Line River Unit[LayIndex].Stage Stress1
									Evaluate expression: MODFLOW_ProgressBarAddLine("Line River Unit" + LayIndex + "Bottom Elevation>=Line River Unit" + LayIndex + ".Stage Stress1 at Row: " + DumRow + "; Column: " +DumCol)
								End if
								Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
								Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
								Set Variable: ocflag:= 0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									If: Line River Unit[LayIndex].Bottom Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Line River Unit[LayIndex].Bottom Elevation>(LayerTop-DivIndex*LayerThickness)
										Set Variable: ocflag:= DivIndex
									End if
								End loop
								If: ocflag=0
									Set Variable: ocflag:= 1
									Set Variable: err_riv_3:= 1
									# If: err_line=0
									Set Variable: DumLay:= M+ocflag
									# Alert: "Line river elevation does not lie within geologic unit: Line river is placed in uppermost model layer in geologic unit."
									Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Line river elevation does not lie within geologic unit: Line river is placed in uppermost model layer in geologic unit.")
									# Set Variable: err_line:= 1
									# End if
								End if
								Set Variable: DumLay:= M+ocflag
								Set Variable: CurrentRiverCount:= CurrentRiverCount + 1
								Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
									If: !(PeriodIndex>1&SteadyRiver=0)
										Redirect output to: TempRivPer
											Start a new line
												Export expression: DumLay [I10]
												Export expression: DumRow [I10]
												Export expression: DumCol; [I10]
												Export expression: Line River Unit[LayIndex].Stage Stress[PeriodIndex]; [G9]
												Export expression: WSumObjectsInBlock(Line River Unit[LayIndex].Conductance); [G9]
												Export expression: Line River Unit[LayIndex].Bottom Elevation; [G9]
												# MODPATH
												If: MODPATHChoice
													Export expression: Line River Unit[LayIndex].IFACE[PeriodIndex]; [G0]
												End if
												# MOC3D Data
												If: TransportFlag=1 & Transport>0
													Export expression: Line River Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
												End if
											End line
										End file
										Evaluate expression: MODFLOW_Join_Files("TempRivPer" + PeriodIndex, "TempRivPer", "TempRivPer" + PeriodIndex)
									End if
								End loop
							End if
						Else
							Loop for: Objects in layer: LINE RIVER UNIT[LayIndex]
								If: Line River Unit[LayIndex].Bottom Elevation>=Line River Unit[LayIndex].Stage Stress1
									Evaluate expression: MODFLOW_ProgressBarAddLine("Line River Unit" + LayIndex + "Bottom Elevation>=Line River Unit" + LayIndex + ".Stage Stress1 at Row: " + DumRow + "; Column: " +DumCol)
								End if
								Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
								Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
								Set Variable: SegmentLength:= ContourIntersectLength()
								If: SegmentLength>0
									Set Variable: ocflag:= 0
									Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
										If: Line River Unit[LayIndex].Bottom Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Line River Unit[LayIndex].Bottom Elevation>(LayerTop-DivIndex*LayerThickness)
											Set Variable: ocflag:= DivIndex
										End if
									End loop
									If: ocflag=0
										Set Variable: ocflag:= 1
										Set Variable: err_riv_3:= 1
										# If: err_line=0
										Set Variable: DumLay:= M+ocflag
										# Alert: "Line river elevation does not lie within geologic unit: Line river is placed in uppermost model layer in geologic unit."
										Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Line river elevation does not lie within geologic unit: Line river is placed in uppermost model layer in geologic unit.")
										# Set Variable: err_line:= 1
										# End if
									End if
									Set Variable: DumLay:= M+ocflag
									Set Variable: CurrentRiverCount:= CurrentRiverCount + 1
									# Set Variable: SegmentLength:= ContourIntersectLength()
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyRiver=0)
											Redirect output to: TempRivPer
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol; [I10]
													Export expression: Line River Unit[LayIndex].Stage Stress[PeriodIndex]; [G9]
													Export expression: SegmentLength*Line River Unit[LayIndex].Conductance; [G9]
													Export expression: Line River Unit[LayIndex].Bottom Elevation; [G9]
													# MODPATH
													If: MODPATHChoice
														Export expression: Line River Unit[LayIndex].IFACE[PeriodIndex]; [G0]
													End if
													# MOC3D Data
													If: TransportFlag=1 & Transport>0
														Export expression: Line River Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempRivPer" + PeriodIndex, "TempRivPer", "TempRivPer" + PeriodIndex)
										End if
									End loop
								End if
							End loop
							# 
							Loop for: Objects in layer: AREA RIVER UNIT[LayIndex]
								If: Area River Unit[LayIndex].Bottom Elevation>=Area River Unit[LayIndex].Stage Stress1
									Evaluate expression: MODFLOW_ProgressBarAddLine("Area River Unit" + LayIndex + "Bottom Elevation>=Area River Unit" + LayIndex + ".Stage Stress1 at Row: " + DumRow + "; Column: " +DumCol)
								End if
								Set Variable: AreaBoundaryInBlock:= 1
								Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
								Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
								Set Variable: ocflag:= 0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									If: Area River Unit[LayIndex].Bottom Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Area River Unit[LayIndex].Bottom Elevation>(LayerTop-DivIndex*LayerThickness)
										Set Variable: ocflag:= DivIndex
									End if
								End loop
								If: ocflag=0
									Set Variable: ocflag:= 1
									Set Variable: err_riv_4:= 1
									# If: err_area1=0
									# Alert: "Area river elevation does not lie within geologic unit: Area river is placed in uppermost model layer in geologic unit."
									Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Area river elevation does not lie within geologic unit: Area river is placed in uppermost model layer in geologic unit.")
									# Set Variable: err_area1:=1
									# End if
								End if
								Set Variable: DumLay:= M+ocflag
								Set Variable: CurrentRiverCount:= CurrentRiverCount + 1
								Set Variable: ContourArea:= ContourIntersectArea()
								Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
									If: !(PeriodIndex>1&SteadyRiver=0)
										Redirect output to: TempRivPer
											Start a new line
												Export expression: DumLay [I10]
												Export expression: DumRow [I10]
												Export expression: DumCol; [I10]
												Export expression: Area River Unit[LayIndex].Stage Stress[PeriodIndex]; [G9]
												Export expression: ContourArea*Area River Unit[LayIndex].Conductance; [G9]
												Export expression: Area River Unit[LayIndex].Bottom Elevation; [G9]
												# MODPATH
												If: MODPATHChoice
													Export expression: Area River Unit[LayIndex].IFACE[PeriodIndex]; [G0]
												End if
												# MOC3D Data
												If: TransportFlag=1 & Transport>0
													Export expression: Area River Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
												End if
											End line
										End file
										Evaluate expression: MODFLOW_Join_Files("TempRivPer" + PeriodIndex, "TempRivPer", "TempRivPer" + PeriodIndex)
									End if
								End loop
							End loop
						End if
						If: (!AreaBoundaryInBlock)&(Area River Unit[LayIndex].Conductance!=$N/A)
							If: Area River Unit[LayIndex].Bottom Elevation>=Area River Unit[LayIndex].Stage Stress1
								Evaluate expression: MODFLOW_ProgressBarAddLine("Area River Unit" + LayIndex + "Bottom Elevation>=Area River Unit" + LayIndex + ".Stage Stress1 at Row: " + DumRow + "; Column: " +DumCol)
							End if
							Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
							Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
							Set Variable: ocflag:= 0
							Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								If: Area River Unit[LayIndex].Bottom Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Area River Unit[LayIndex].Bottom Elevation>(LayerTop-DivIndex*LayerThickness)
									Set Variable: ocflag:= DivIndex
								End if
							End loop
							If: ocflag=0
								Set Variable: ocflag:= 1
								Set Variable: err_riv_4:= 1
								# If: err_area1=0
								# Alert: "Area river elevation does not lie within geologic unit: Area river is placed in uppermost model layer in geologic unit."
								Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Area river elevation does not lie within geologic unit: Area river is placed in uppermost model layer in geologic unit.")
								# Set Variable: err_area1:=1
								# End if
							End if
							Set Variable: DumLay:= M+ocflag
							Set Variable: CurrentRiverCount:= CurrentRiverCount + 1
							Set Variable: ContourArea:= BlockArea()
							Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
								If: !(PeriodIndex>1&SteadyRiver=0)
									Redirect output to: TempRivPer
										Start a new line
											Export expression: DumLay [I10]
											Export expression: DumRow [I10]
											Export expression: DumCol; [I10]
											Export expression: Area River Unit[LayIndex].Stage Stress[PeriodIndex]; [G9]
											Export expression: ContourArea*Area River Unit[LayIndex].Conductance; [G9]
											Export expression: Area River Unit[LayIndex].Bottom Elevation; [E13.5]
											# MODPATH
											If: MODPATHChoice
												Export expression: Area River Unit[LayIndex].IFACE[PeriodIndex]; [G0]
											End if
											# MOC3D Data
											If: TransportFlag=1 & Transport>0
												Export expression: Area River Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
											End if
										End line
									End file
									Evaluate expression: MODFLOW_Join_Files("TempRivPer" + PeriodIndex, "TempRivPer", "TempRivPer" + PeriodIndex)
								End if
							End loop
						End if
						# 
					End loop
					# 
					# End if
					# 
				End if
			End if
		End loop
		# End if
		# End file
		If: ContinueSimulation
			Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
				Redirect output to: TempRiver1
					If: PeriodIndex>1&SteadyRiver=0
						Start a new line
							Export expression: -1 [I10]
						End line
					Else
						Start a new line
							Export expression: CurrentRiverCount [I10]
						End line
					End if
				End file
				If: CurrentRiverCount>MaxRivers
					Set Variable: MaxRivers:= CurrentRiverCount
				End if
				If: !(PeriodIndex>1&SteadyRiver=0)
					Evaluate expression: MODFLOW_Join_Files("TempRiver1", "TempRivPer" + PeriodIndex, "TempRiver1")
					Evaluate expression: MODFLOW_Delete_File("TempRivPer" + PeriodIndex)
				End if
				Evaluate expression: MODFLOW_Join_Files("@adeFileName@.riv", "TempRiver1", "@adeFileName@.riv")
				# End if
			End loop
			Redirect output to: TempRiver1
				Start a new line
					Export expression: MaxRivers [I10]
					If: IRIVCB>0&OneCBCFile=1
						Export expression: 33; [I10]
					End if
					If: IRIVCB>0&OneCBCFile=0
						Export expression: 27; [I10]
					End if
					If: IRIVCB=0
						Export expression: 0; [I10]
					End if
					# MODPATH
					If: MODPATHChoice
						Export expression: " AUXILIARY IFACE" [G0]
					End if
					# MOC3D AUX parameter
					If: TransportFlag=1 & Transport>0
						Export expression: " CBCALLOCATE AUXILIARY CONCENTRATION" [G0]
					End if
				End line
			End file
			Evaluate expression: MODFLOW_Join_Files("TempRiver1", "@adeFileName@.riv", "@adeFileName@.riv")
			# 
			# Evaluate expression: Chk_LayArrayDispose()
			# Evaluate expression: Chk_BlockArrayDispose()
		End if
		Evaluate expression: MODFLOW_Delete_File("TempRiver1")
		Evaluate expression: MODFLOW_Delete_File("TempRivPer")
		# End if
		# 
	End if
End if
# ----------------------------------------------------
# Drain Package
# ----------------------------------------------------
If: ContinueSimulation
	If: DrainChoice!=0&ExportDRN!=0
		Evaluate expression: MODFLOW_ProgressBarSetMessage("Drain Package")
		Redirect output to: @adeFileName@.drn
		End file
		Set Variable: MaxDrains:= 0
		Set Variable: err_line:= 0
		Set Variable: err_area1:= 0
		Set Variable: err_area2:= 0
		Set Variable: DRN_MXDRN:= 0
		Set Variable: CurrentDrainCount:= 0
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				If: LayIndex=1
					Set Variable: M:= 0
				Else
					Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
				End if
				# 
				If: MODFLOW_SIMUL(LayIndex)!=0
					# 
					# Set Variable: L:= L+1
					# If: Chk_LayArrayGet(L)=1
					# Set Variable: Block_Num:= (L-1)*NumRows()*NumColumns()
					Loop for: Blocks
						Set Variable: AreaBoundaryInBlock:= 0
						# Set Variable: Block_Num:= Block_Num+1
						# If: Chk_BlockArrayGet(Block_Num)=1
						# 
						Set Variable: DumRow:= Row()
						Set Variable: DumCol:= Column()
						# 
						If: @cbAltDrn@
							# Set Variable: SegmentLength:= ContourIntersectLength()
							If: WSumObjectsInBlock(Line Drain Unit[LayIndex].Conductance)!=0
								Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
								Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
								# Set Variable: SegmentLength:= ContourIntersectLength()
								# If: SegmentLength>0
								Set Variable: ocflag:= 0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									If: Line Drain Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Line Drain Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
										Set Variable: ocflag:= DivIndex
									End if
								End loop
								If: ocflag=0
									Set Variable: ocflag:= 1
									Set Variable: err_drn_3:= 1
									# If: err_line=0
									# Alert: "Line drain elevation does not lie within geologic unit: Line drain is placed in uppermost model layer in geologic unit."
									Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Line drain elevation does not lie within geologic unit: Line drain is placed in uppermost model layer in geologic unit.")
									# Set Variable: err_line:= 1
									# End if
								End if
								Set Variable: DumLay:= M+ocflag
								# Set Variable: SegmentLength:= ContourIntersectLength()
								Set Variable: CurrentDrainCount:= CurrentDrainCount + 1
								Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
									If: !(PeriodIndex>1&SteadyDrain=0)
										Redirect output to: TempDrainPer
											Start a new line
												Export expression: DumLay [I10]
												Export expression: DumRow [I10]
												Export expression: DumCol; [I10]
												If: Line Drain Unit[LayIndex].On or Off Stress[PeriodIndex]
													Export expression: Line Drain Unit[LayIndex].Elevation; [G9]
												Else
													Export expression: 1.e49; [G9]
												End if
												Export expression: WSumObjectsInBlock(Line Drain Unit[LayIndex].Conductance); [E13.5]
												# MODPATH
												If: MODPATHChoice
													Export expression: Line Drain Unit[LayIndex].IFACE[PeriodIndex] [G0]
												End if
											End line
										End file
										Evaluate expression: MODFLOW_Join_Files("TempDrainPer" + PeriodIndex, "TempDrainPer", "TempDrainPer" + PeriodIndex)
									End if
								End loop
								# End if
							End if
							# 
							If: (AREA Drain Unit1.Conductance!=$N/A)
								Set Variable: ThisConductance:= AREA Drain Unit1.Conductance
								Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
								Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
								Set Variable: ocflag:= 0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									If: Area Drain Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Area Drain Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
										Set Variable: ocflag:= DivIndex
									End if
								End loop
								If: ocflag=0
									Set Variable: ocflag:= 1
									Set Variable: err_drn_4:= 1
									# If: err_area1=0
									# Alert: "Area drain elevation does not lie within geologic unit: Area drain is placed in uppermost model layer in geologic unit."
									Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Area drain elevation does not lie within geologic unit: Area drain is placed in uppermost model layer in geologic unit.")
									# Set Variable: err_area1:= 1
									# End if
								End if
								Set Variable: CurrentDrainCount:= CurrentDrainCount + 1
								Set Variable: ContourArea:= BlockArea()
								Set Variable: DumLay:= M+ocflag
								Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
									If: !(PeriodIndex>1&SteadyDrain=0)
										Redirect output to: TempDrainPer
											Start a new line
												Export expression: DumLay [I10]
												Export expression: DumRow [I10]
												Export expression: DumCol; [I10]
												If: Area Drain Unit[LayIndex].On or Off Stress[PeriodIndex]
													Export expression: Area Drain Unit[LayIndex].Elevation; [G9]
												Else
													Export expression: 1.e49; [G9]
												End if
												Export expression: ContourArea*ThisConductance; [G9]
												# MODPATH
												If: MODPATHChoice
													Export expression: Area Drain Unit[LayIndex].IFACE[PeriodIndex] [G0]
												End if
											End line
										End file
										Evaluate expression: MODFLOW_Join_Files("TempDrainPer" + PeriodIndex, "TempDrainPer", "TempDrainPer" + PeriodIndex)
									End if
								End loop
							End if
						Else
							Loop for: Objects in layer: LINE DRAIN UNIT[LayIndex]
								Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
								Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
								Set Variable: SegmentLength:= ContourIntersectLength()
								If: SegmentLength>0
									Set Variable: ocflag:= 0
									Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
										If: Line Drain Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Line Drain Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
											Set Variable: ocflag:= DivIndex
										End if
									End loop
									If: ocflag=0
										Set Variable: ocflag:= 1
										Set Variable: err_drn_3:= 1
										# If: err_line=0
										# Alert: "Line drain elevation does not lie within geologic unit: Line drain is placed in uppermost model layer in geologic unit."
										Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Line drain elevation does not lie within geologic unit: Line drain is placed in uppermost model layer in geologic unit.")
										# Set Variable: err_line:= 1
										# End if
									End if
									Set Variable: DumLay:= M+ocflag
									# Set Variable: SegmentLength:= ContourIntersectLength()
									Set Variable: CurrentDrainCount:= CurrentDrainCount + 1
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyDrain=0)
											Redirect output to: TempDrainPer
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol; [I10]
													If: Line Drain Unit[LayIndex].On or Off Stress[PeriodIndex]
														Export expression: Line Drain Unit[LayIndex].Elevation; [G9]
													Else
														Export expression: 1.e49; [G9]
													End if
													Export expression: SegmentLength*Line Drain Unit[LayIndex].Conductance; [G9]
													# MODPATH
													If: MODPATHChoice
														Export expression: Line Drain Unit[LayIndex].IFACE[PeriodIndex] [G0]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempDrainPer" + PeriodIndex, "TempDrainPer", "TempDrainPer" + PeriodIndex)
										End if
									End loop
								End if
							End loop
							# 
							Loop for: Objects in layer: AREA DRAIN UNIT[LayIndex]
								Set Variable: AreaBoundaryInBlock:= 1
								Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
								Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
								Set Variable: ocflag:= 0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									If: Area Drain Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Area Drain Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
										Set Variable: ocflag:= DivIndex
									End if
								End loop
								If: ocflag=0
									Set Variable: ocflag:= 1
									Set Variable: err_drn_4:= 1
									# If: err_area1=0
									# Alert: "Area drain elevation does not lie within geologic unit: Area drain is placed in uppermost model layer in geologic unit."
									Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Area drain elevation does not lie within geologic unit: Area drain is placed in uppermost model layer in geologic unit.")
									# Set Variable: err_area1:= 1
									# End if
								End if
								Set Variable: CurrentDrainCount:= CurrentDrainCount + 1
								Set Variable: ContourArea:= ContourIntersectArea()
								Set Variable: DumLay:= M+ocflag
								Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
									If: !(PeriodIndex>1&SteadyDrain=0)
										Redirect output to: TempDrainPer
											Start a new line
												Export expression: DumLay [I10]
												Export expression: DumRow [I10]
												Export expression: DumCol; [I10]
												If: Area Drain Unit[LayIndex].On or Off Stress[PeriodIndex]
													Export expression: Area Drain Unit[LayIndex].Elevation; [G9]
												Else
													Export expression: 1.e49; [G9]
												End if
												Export expression: ContourArea*Area Drain Unit[LayIndex].Conductance; [G9]
												# MODPATH
												If: MODPATHChoice
													Export expression: Area Drain Unit[LayIndex].IFACE[PeriodIndex] [G0]
												End if
											End line
										End file
										Evaluate expression: MODFLOW_Join_Files("TempDrainPer" + PeriodIndex, "TempDrainPer", "TempDrainPer" + PeriodIndex)
									End if
								End loop
							End loop
							If: (!AreaBoundaryInBlock)&(AREA Drain Unit1.Conductance!=$N/A)
								Set Variable: ThisConductance:= AREA Drain Unit1.Conductance
								Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
								Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
								Set Variable: ocflag:= 0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									If: Area Drain Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Area Drain Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
										Set Variable: ocflag:= DivIndex
									End if
								End loop
								If: ocflag=0
									Set Variable: ocflag:= 1
									Set Variable: err_drn_4:= 1
									# If: err_area1=0
									# Alert: "Area drain elevation does not lie within geologic unit: Area drain is placed in uppermost model layer in geologic unit."
									Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Area drain elevation does not lie within geologic unit: Area drain is placed in uppermost model layer in geologic unit.")
									# Set Variable: err_area1:= 1
									# End if
								End if
								Set Variable: CurrentDrainCount:= CurrentDrainCount + 1
								Set Variable: ContourArea:= BlockArea()
								Set Variable: DumLay:= M+ocflag
								Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
									If: !(PeriodIndex>1&SteadyDrain=0)
										Redirect output to: TempDrainPer
											Start a new line
												Export expression: DumLay [I10]
												Export expression: DumRow [I10]
												Export expression: DumCol; [I10]
												If: Area Drain Unit[LayIndex].On or Off Stress[PeriodIndex]
													Export expression: Area Drain Unit[LayIndex].Elevation; [G9]
												Else
													Export expression: 1.e49; [G9]
												End if
												Export expression: ContourArea*ThisConductance; [G9]
												# MODPATH
												If: MODPATHChoice
													Export expression: Area Drain Unit[LayIndex].IFACE[PeriodIndex] [G0]
												End if
											End line
										End file
										Evaluate expression: MODFLOW_Join_Files("TempDrainPer" + PeriodIndex, "TempDrainPer", "TempDrainPer" + PeriodIndex)
									End if
								End loop
							End if
						End if
					End loop
					# End if
					# 
				End if
			End if
		End loop
		# End if
		# End file
		If: ContinueSimulation
			Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
				Redirect output to: TempDrain1
					If: PeriodIndex>1&SteadyDrain=0
						Start a new line
							Export expression: -1 [I10]
						End line
					Else
						Start a new line
							Export expression: CurrentDrainCount [I10]
						End line
					End if
				End file
				If: CurrentDrainCount>MaxDrains
					Set Variable: MaxDrains:= CurrentDrainCount
				End if
				If: !(PeriodIndex>1&SteadyDrain=0)
					Evaluate expression: MODFLOW_Join_Files("TempDrain1", "TempDrainPer" + PeriodIndex, "TempDrain1")
					Evaluate expression: MODFLOW_Delete_File("TempDrainPer" + PeriodIndex)
				End if
				Evaluate expression: MODFLOW_Join_Files("@adeFileName@.drn", "TempDrain1", "@adeFileName@.drn")
			End loop
			Redirect output to: TempDrain1
				Start a new line
					Export expression: MaxDrains [I10]
					If: IDRNCB>0&OneCBCFile=1
						Export expression: 33; [I10]
					End if
					If: IDRNCB>0&OneCBCFile=0
						Export expression: 27; [I10]
					End if
					If: IDRNCB=0
						Export expression: 0; [I10]
					End if
					# MODPATH
					If: MODPATHChoice
						Export expression: " AUXILIARY IFACE" [G0]
					End if
					# MOC3D CBC parameter
					If: TransportFlag=1 & Transport>0
						Export expression: " CBCALLOCATE" [G0]
					End if
				End line
			End file
			Evaluate expression: MODFLOW_Join_Files("TempDrain1", "@adeFileName@.drn", "@adeFileName@.drn")
		End if
		# 
		# Evaluate expression: Chk_LayArrayDispose()
		# Evaluate expression: Chk_BlockArrayDispose()
		Evaluate expression: MODFLOW_Delete_File("TempDrain1")
		Evaluate expression: MODFLOW_Delete_File("TempDrainPer")
		# End if
	End if
End if
# ----------------------------------------------------
# Well Package
# ----------------------------------------------------
If: ContinueSimulation
	If: WellChoice!=0&ExportWEL!=0
		Evaluate expression: MODFLOW_ProgressBarSetMessage("Well Package")
		Redirect output to: @adeFileName@.wel
		End file
		Set Variable: MaxWells:= 0
		Set Variable: CurrentWellCount:= 0
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				If: LayIndex=1
					Set Variable: M:= 0
				Else
					Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
				End if
				# 
				If: MODFLOW_SIMUL(LayIndex)!=0
					# 
					# Set Variable: Block_Num:= (L-1)*NumRows()*NumColumns()
					Loop for: Blocks
						# 
						Set Variable: DumRow:= Row()
						Set Variable: DumCol:= Column()
						Loop for: Objects in layer: WELLS UNIT[LayIndex]
							Set Variable: WT:= Wells Unit[LayIndex].Top Elevation
							Set Variable: WB:= Wells Unit[LayIndex].Bottom Elevation
							# YBI: Pre calculate elevation top and thickness
							Set Variable: TempValue2:= Elevation Top Unit[LayIndex]
							Set Variable: TempValue4:= Elevation Bottom Unit[LayIndex]
							If: (WT>TempValue2)|(WT<=TempValue4)
								Evaluate expression: MODFLOW_ProgressBarAddLine("Top Elevation in a well in Unit: " + LayIndex + "; Row: " + DumRow + "; Column: " + DumCol + " is outside the limits of the unit, it will be treated as if the top of the well screen were at the top of the unit.")
								Set Variable: WT:= TempValue2
							End if
							If: (WB>TempValue2)|(WB<TempValue4)
								Evaluate expression: MODFLOW_ProgressBarAddLine("Bottom Elevation in a well in Unit: " + LayIndex + "; Row: " + DumRow + "; Column: " + DumCol + " is outside the limits of the unit, it will be treated as if the bottom of the well screen were at the bottom of the unit.")
								Set Variable: WB:= TempValue4
							End if
							Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								Set Variable: DumLay:= M+DivIndex
								Set Variable: TempValue3:= (TempValue2-TempValue4)/MODFLOW_NDIV(LayIndex)
								Set Variable: TML:= TempValue2-(DivIndex-1)*TempValue3
								Set Variable: BML:= TempValue2-DivIndex*TempValue3
								If: ((WT>TML)&(WB>=TML))|WT<=BML
								Else
									Set Variable: ocflag:= 0
									If: (WT<=TML&WT>BML)&(WB<TML&WB>=BML)
										Set Variable: ocflag:= 1
										Set Variable: TempValue1:= WT-WB
									End if
									If: ocflag=0
										If: (WT<=TML&WT>BML)&(WB<=BML)
											Set Variable: ocflag:= 1
											Set Variable: TempValue1:= WT-BML
										End if
									End if
									If: ocflag=0
										If: (WT>=TML)&(WB<TML&WB>=BML)
											Set Variable: ocflag:= 1
											Set Variable: TempValue1:= TML-WB
										End if
									End if
									If: ocflag=0
										If: (WT>TML)&(WB<BML)
											Set Variable: ocflag:= 1
											Set Variable: TempValue1:= TML-BML
										End if
									End if
									Set Variable: CurrentWellCount:= CurrentWellCount + 1
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyWell=0)
											Redirect output to: TempWellPer
												Set Variable: TempValue2:= TempValue1*Wells Unit[LayIndex].Stress[PeriodIndex]/(WT-WB)
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol; [I10]
													Export expression: TempValue2; [G9]
													# MODPATH
													If: MODPATHChoice
														Export expression: Wells Unit[LayIndex].IFACE[PeriodIndex] [G0]
													End if
													# MOC3D Data
													If: TransportFlag=1 & Transport>0
														Export expression: Wells Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempWellPer" + PeriodIndex, "TempWellPer", "TempWellPer" + PeriodIndex)
										End if
									End loop
								End if
							End loop
						End loop
					End loop
				End if
			End if
		End loop
		If: ContinueSimulation
			If: CurrentWellCount > MaxWells
				Set Variable: MaxWells:= CurrentWellCount
			End if
			Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
				Redirect output to: TempWell1
					If: PeriodIndex>1&SteadyWell=0
						Start a new line
							Export expression: -1 [I10]
						End line
					Else
						Start a new line
							Export expression: CurrentWellCount [I10]
						End line
					End if
				End file
				If: !(PeriodIndex>1&SteadyWell=0)
					Evaluate expression: MODFLOW_Join_Files("TempWell1", "TempWellPer" + PeriodIndex, "TempWell1")
					Evaluate expression: MODFLOW_Delete_File("TempWellPer" + PeriodIndex)
				End if
				Evaluate expression: MODFLOW_Join_Files("@adeFileName@.wel", "TempWell1", "@adeFileName@.wel")
			End loop
			Evaluate expression: MODFLOW_Delete_File("TempWellPer")
			Redirect output to: TempWell1
				Start a new line
					Export expression: MaxWells [I10]
					If: IWELCB>0&OneCBCFile=1
						Export expression: 33; [I10]
					End if
					If: IWELCB>0&OneCBCFile=0
						Export expression: 29; [I10]
					End if
					If: IWELCB=0
						Export expression: 0; [I10]
					End if
					# MODPATH
					If: MODPATHChoice
						Export expression: " AUXILIARY IFACE" [G0]
					End if
					# MOC3D AUX parameter
					If: TransportFlag=1 & Transport>0
						Export expression: " CBCALLOCATE AUXILIARY CONCENTRATION" [G0]
					End if
				End line
			End file
		End if
		Evaluate expression: MODFLOW_Join_Files("TempWell1", "@adeFileName@.wel", "@adeFileName@.wel")
		Evaluate expression: MODFLOW_Delete_File("TempWell1")
		# 
	End if
End if
# 
# ----------------------------------------------------
# Stream Package
# ----------------------------------------------------
If: ContinueSimulation
	If: StreamChoice&ExportStreams
		Redirect output to: @adeFileName@.str
		End file
		Evaluate expression: MODFLOW_BL_InitializeGridInformation("MODFLOW FD Grid", 0)
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			If: MODFLOW_SIMUL(LayIndex)!=0
				Evaluate expression: MODFLOW_BL_AddVertexLayer("Stream Unit" + LayIndex)
				Loop for: Objects in layer: Stream Unit[LayIndex]
					Evaluate expression: MODFLOW_L_AddToList(StreamSegmentList, Segment Number)
					Evaluate expression: MODFLOW_L_AddToList(SortedStreamSegmentList, Segment Number)
					Evaluate expression: MODFLOW_L_AddToList(StreamUnitList, LayIndex)
					If: UseDiversions
						Evaluate expression: MODFLOW_L_AddToList(StreamTributaryList, Stream Unit[LayIndex].Upstream Diversion Segment Number)
					End if
				End loop
			End if
		End loop
		Evaluate expression: MODFLOW_L_SortList(SortedStreamSegmentList)
		Evaluate expression: MODFLOW_L_EliminateDuplicates(SortedStreamSegmentList)
		Set Variable: StreamSegmentCount:= MODFLOW_L_GetListSize(SortedStreamSegmentList)
		Set Variable: Tributary2DArray:= MODFLOW_L_CreateNew3DList(StreamSegmentCount, TributaryMaxAllowed + 2, 1)
		Set Variable: StreamProperties3DArray:= MODFLOW_L_CreateNew3DList(StreamSegmentCount, MODFLOW_NPER()+1, InterpolateWidth+1)
		# 
		Set Variable: StreamIndex:= 0
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			If: MODFLOW_SIMUL(LayIndex)!=0
				Loop for: Objects in layer: Stream Unit[LayIndex]
					If: ContourType()=2
						Evaluate expression: MODFLOW_L_Set3DListItem(Tributary2DArray, StreamIndex, TributaryMaxAllowed+1, 0, 1)
					End if
					Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, FlowIndex, Flow[PeriodIndex])
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, UpstreamStageIndex, Upstream Stage[PeriodIndex])
						If: Downstream Stage[PeriodIndex]!=$N/A
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, DownstreamStageIndex, Downstream Stage[PeriodIndex])
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateStage, 1)
						Else
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateStage, 0)
						End if
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, ConductivityIndex, Stream Unit[LayIndex].Streambed hydraulic conductivity)
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, UpstreamTopElevIndex, Upstream top elevation[PeriodIndex])
						If: Downstream top elevation[PeriodIndex]!=$N/A
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, DownstreamTopElevIndex, Downstream top elevation[PeriodIndex])
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateTopElev, 1)
						Else
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateTopElev, 0)
						End if
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, UpstreamBotElevIndex, Upstream bottom elevation[PeriodIndex])
						If: Downstream bottom elevation[PeriodIndex]!=$N/A
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, DownstreamBotElevIndex, Downstream bottom elevation[PeriodIndex])
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateBottomElev, 1)
						Else
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateBottomElev, 0)
						End if
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, UpstreamWidthIndex, Upstream width[PeriodIndex])
						If: Downstream width[PeriodIndex]!=$N/A
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, DownstreamWidthIndex, Downstream width[PeriodIndex])
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateWidth, 1)
						Else
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateWidth, 0)
						End if
						If: ICALC
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, SlopeIndex, Slope[PeriodIndex])
							Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, RoughnessIndex, Mannings roughness[PeriodIndex])
						End if
					End loop
					Set Variable: StreamIndex:= StreamIndex+1
					If: UseTributaries
						If: Downstream Segment Number!=$N/A
							If: Downstream Segment Number>0
								Set Variable: TributaryIndex:= MODFLOW_L_UnsortedIndexOf(StreamSegmentList, Downstream Segment Number)
								If: TributaryIndex<0
									# Error
								Else
									Set Variable: TributaryCount:= MODFLOW_L_GetFrom3DList(Tributary2DArray, TributaryIndex, 0, 0)
									If: TributaryCount=TributaryMaxAllowed
										# Error
									Else
										Set Variable: TributaryCount:= TributaryCount + 1
										Evaluate expression: MODFLOW_L_Set3DListItem(Tributary2DArray, TributaryIndex, 0, 0, TributaryCount)
										Evaluate expression: MODFLOW_L_Set3DListItem(Tributary2DArray, TributaryIndex, TributaryCount, 0, TributaryIndex + 1)
										Evaluate expression: MODFLOW_L_Set3DListItem(Tributary2DArray, TributaryIndex, TributaryCount, 0, MODFLOW_L_UnsortedIndexOf(SortedStreamSegmentList, Segment Number) + 1)
									End if
								End if
							End if
						End if
					End if
				End loop
			End if
		End loop
		# 
		# 
		# Check for close contours or point objects. Display a warning if any are detected.
		If: StreamSegmentCount!=MODFLOW_L_GetListSize(StreamSegmentList)
			Evaluate expression: MODFLOW_ProgressBarAddLine("Error: One or more stream segment numbers are not unique.")
		End if
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			If: MODFLOW_SIMUL(LayIndex)!=0
				Loop for: Objects in layer: Stream Unit[LayIndex]
					If: (ContourType()=1)|(ContourType()=3)
						If: (ContourType()=1)
							Evaluate expression: MODFLOW_ProgressBarAddLine("Error: Point object on stream layer. Point Object Segment Number: " + Stream Unit[LayIndex].Segment Number)
						End if
						If: (ContourType()=3)
							Evaluate expression: MODFLOW_ProgressBarAddLine("Error: Close contour on stream layer. Close Contour Segment Number: " + Stream Unit[LayIndex].Segment Number)
						End if
					End if
				End loop
			End if
		End loop
		# 
		# Check that no segment numbers are equal to 0.
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			If: MODFLOW_SIMUL(LayIndex)!=0
				Loop for: Objects in layer: Stream Unit[LayIndex]
					If: Segment Number=0
						Evaluate expression: MODFLOW_ProgressBarAddLine("Warning: Stream segment number = 0 on non-simulated layer Stream Unit" + LayIndex + " will be ignored.")
					End if
				End loop
			End if
		End loop
		# 
		# Check that no stream widths are less than or equal to 0.
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			If: MODFLOW_SIMUL(LayIndex)!=0
				Loop for: Objects in layer: Stream Unit[LayIndex]
					Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
						If: Upstream width[PeriodIndex]<=0
							Evaluate expression: MODFLOW_ProgressBarAddLine("Warning: Upstream width[" + PeriodIndex+ "] <= 0 in Stream Unit" + LayIndex)
						End if
						If: IsNumber(Downstream width[PeriodIndex])
							If: Downstream width[PeriodIndex]<=0
								Evaluate expression: MODFLOW_ProgressBarAddLine("Warning: Downstream width[" + PeriodIndex+ "] <= 0 in Stream Unit" + LayIndex)
							End if
						End if
					End loop
					If: Segment Number=0
						Evaluate expression: MODFLOW_ProgressBarAddLine("Warning: Stream segment number = 0 on non-simulated layer Stream Unit" + LayIndex + " will be ignored.")
					End if
				End loop
			End if
		End loop
		# 
		# Check that no two segments have the same segment number.
		Loop for: Variable SegmentIndex from: 0 to: StreamSegmentCount-1 step: 1
			If: MODFLOW_L_UnsortedIndexOf(StreamSegmentList, MODFLOW_L_GetFromList(StreamSegmentList, SegmentIndex))!=SegmentIndex
				Evaluate expression: MODFLOW_ProgressBarAddLine("Error: Two or more Stream segments are assigned segment numbers of " + MODFLOW_L_GetFromList(StreamSegmentList, StreamIndex))
			End if
		End loop
		# 
		# Check that all downstream segments have higher segment numbers than upsteam segments.
		Set Variable: not_ok:= 0
		If: UseTributaries
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				If: MODFLOW_SIMUL(LayIndex)!=0
					Loop for: Objects in layer: Stream Unit[LayIndex]
						If: (Downstream Segment Number<=Segment Number)&(Segment Number!=0)&(Downstream Segment Number!=0)
							Set Variable: not_ok:= 1
							Evaluate expression: MODFLOW_ProgressBarAddLine("Stream Segment Number " + Stream Unit[LayIndex].Segment Number + " has a downstream segment number " + Stream Unit[LayIndex].Downstream Segment Number + ".  Downstream segments must be higher than upstream segments.")
						End if
					End loop
				End if
			End loop
		End if
		# 
		# Check that all diversion segments have higher segment numbers than upsteam segments.
		If: UseDiversions
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				If: MODFLOW_SIMUL(LayIndex)!=0
					Loop for: Objects in layer: Stream Unit[LayIndex]
						If: (Upstream Diversion Segment Number>=Segment Number)&(Segment Number!=0)&(Upstream Diversion Segment Number!=0)
							Evaluate expression: MODFLOW_ProgressBarAddLine("Segment Number " + Stream Unit[LayIndex].Segment Number + " is a diversion but it has a higher segment that the segment from which flow is diverted (" + Stream Unit[LayIndex].Upstream Diversion Segment Number + ").")
						End if
					End loop
				End if
			End loop
		End if
		# 
		# Check that all stream tops are higher than the corresponding stream bottoms.
		Set Variable: not_ok:= 0
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			If: MODFLOW_SIMUL(LayIndex)!=0
				Loop for: Objects in layer: Stream Unit[LayIndex]
					Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
						If: (PeriodIndex=1)|!StreamsSteady
							Set Variable: StreamTop:= Upstream top elevation[PeriodIndex]
							Set Variable: StreamBottom:= Upstream bottom elevation[PeriodIndex]
							If: (StreamTop<=StreamBottom)&(Segment Number!=0)
								Set Variable: not_ok:= 1
								Evaluate expression: MODFLOW_ProgressBarAddLine("Top <= Bottom in Stream Segment " + Stream Unit[LayIndex].Segment Number + " for period " + PeriodIndex)
							End if
							If: Downstream top elevation[PeriodIndex]!=$N/A
								Set Variable: StreamTop:= Downstream top elevation[PeriodIndex]
							End if
							If: Downstream bottom elevation[PeriodIndex]!=$N/A
								Set Variable: StreamBottom:= Downstream bottom elevation[PeriodIndex]
							End if
							If: (StreamTop<StreamBottom)&(Segment Number!=0)
								Evaluate expression: MODFLOW_ProgressBarAddLine("Top < Bottom in Stream Segment " + Stream Unit[LayIndex].Segment Number + " for period " + PeriodIndex)
							End if
						End if
					End loop
				End loop
			End if
		End loop
		# 
		# Check that all stream stages are higher than the corresponding stream bottoms.
		If: !ICALC
			Set Variable: not_ok:= 0
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				If: MODFLOW_SIMUL(LayIndex)!=0
					Loop for: Objects in layer: Stream Unit[LayIndex]
						Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
							If: (PeriodIndex=1)|(!StreamsSteady)
								Set Variable: StreamStage:= Upstream Stage[PeriodIndex]
								Set Variable: StreamBottom:= Upstream bottom elevation[PeriodIndex]
								If: (StreamStage<StreamBottom)&(Segment Number!=0)
									Evaluate expression: MODFLOW_ProgressBarAddLine("Stage < Bottom in Stream Segment " + Stream Unit[LayIndex].Segment Number)
								End if
								If: Downstream Stage[PeriodIndex]!=$N/A
									Set Variable: StreamStage:= Downstream Stage[PeriodIndex]
								End if
								If: Downstream bottom elevation[PeriodIndex]!=$N/A
									Set Variable: StreamBottom:= Downstream bottom elevation[PeriodIndex]
								End if
								If: (StreamStage<StreamBottom)&(Segment Number!=0)
									Evaluate expression: MODFLOW_ProgressBarAddLine("Stage < Bottom in Stream Segment " + Stream Unit[LayIndex].Segment Number)
								End if
							End if
						End loop
					End loop
				End if
			End loop
		End if
		# 
		# Check that all stream stages are higher than the corresponding stream tops.
		If: !ICALC
			Set Variable: not_ok:= 0
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				If: MODFLOW_SIMUL(LayIndex)!=0
					Loop for: Objects in layer: Stream Unit[LayIndex]
						Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
							If: (PeriodIndex =1)|(!StreamsSteady)
								Set Variable: StreamTop:= Upstream top elevation[PeriodIndex]
								Set Variable: StreamStage:= Upstream Stage[PeriodIndex]
								If: (StreamStage<StreamTop)&(Segment Number!=0)&(ICALC<=0)
									Evaluate expression: MODFLOW_ProgressBarAddLine("Stage < Top in Stream Segment " + Stream Unit[LayIndex].Segment Number)
								End if
								If: Downstream top elevation[PeriodIndex]!=$N/A
									Set Variable: StreamTop:= Downstream top elevation[PeriodIndex]
								End if
								If: Downstream Stage[PeriodIndex]!=$N/A
									Set Variable: StreamStage:= Downstream Stage[PeriodIndex]
								End if
								If: (StreamStage<StreamTop)&(Segment Number!=0)&(ICALC<=0)
									Evaluate expression: MODFLOW_ProgressBarAddLine("Stage < Top in Stream Segment " + Stream Unit[LayIndex].Segment Number)
								End if
							End if
						End loop
					End loop
				End if
			End loop
		End if
		# 
		# Check that all downstream segments exist.
		If: UseTributaries
			Set Variable: not_ok:= 0
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				If: MODFLOW_SIMUL(LayIndex)!=0
					Loop for: Objects in layer: Stream Unit[LayIndex]
						If: Downstream Segment Number!=$N/A
							If: !(Downstream Segment Number=0)
								If: MODFLOW_L_UnsortedIndexOf(SortedStreamSegmentList, Downstream Segment Number)<0
									Evaluate expression: MODFLOW_ProgressBarAddLine("The downstream segment for stream segment " + Stream Unit[LayIndex].Segment Number + " does not exist.")
								End if
							End if
						End if
					End loop
				End if
			End loop
		End if
		# 
		If: UseDiversions
			# Check that all upstream segments for diversions exist.
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				If: MODFLOW_SIMUL(LayIndex)!=0
					Loop for: Objects in layer: Stream Unit[LayIndex]
						If: Upstream Diversion Segment Number!=$N/A
							If: !(Upstream Diversion Segment Number=0)
								If: MODFLOW_L_UnsortedIndexOf(SortedStreamSegmentList, Upstream Diversion Segment Number)<0
									Evaluate expression: MODFLOW_ProgressBarAddLine("In Stream segment " + Stream Unit[LayIndex].Segment Number + ", the segment from which flow is to be diverted (" + Stream Unit[LayIndex].Upstream Diversion Segment Number + ") does not exist.")
								End if
							End if
						End if
					End loop
				End if
			End loop
		End if
		# 
		# Check that no objects are on non-simulated layers
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			If: MODFLOW_SIMUL(LayIndex)=0
				Set Variable: TempInteger:= 0
				Loop for: Objects in layer: Stream Unit[LayIndex]
					Set Variable: TempInteger:= TempInteger+1
				End loop
				If: TempInteger>0
					Evaluate expression: MODFLOW_ProgressBarAddLine("Warning: Streams on non-simulated layer " + LayIndex + " will be ignored.")
				End if
			End if
		End loop
		Set Variable: NTRIB:= 0
		If: UseTributaries
			Loop for: Variable StreamIndex from: 0 to: StreamSegmentCount-1 step: 1
				Set Variable: NTRIBCurrent:= MODFLOW_L_GetFrom3DList(Tributary2DArray, StreamIndex, 0, 0)
				If: NTRIBCurrent>NTRIB
					Set Variable: NTRIB:= NTRIBCurrent
				End if
			End loop
		End if
		If: UseDiversions
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				If: MODFLOW_SIMUL(LayIndex)
					Loop for: Objects in layer: Stream Unit[LayIndex]
						If: Upstream Diversion Segment Number>0
							Set Variable: NDIV:= 1
						End if
					End loop
				End if
			End loop
		End if
		Set Variable: MaxStreamReachCount:= 0
		Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
			Set Variable: CurrentStreamReachCount:= 0
			Redirect output to: TempStream3
				Loop for: Variable StreamIndex from: 0 to: StreamSegmentCount-1 step: 1
					Set Variable: CurrentStream:= MODFLOW_L_GetFromList(SortedStreamSegmentList, StreamIndex)
					Set Variable: StreamIndex2:= MODFLOW_L_UnsortedIndexOf(StreamSegmentList, CurrentStream)
					# StreamIndex2 is now the index of the current stream segment and may be used to retrieve data about the current stream.
					Set Variable: BlockListCount:= MODFLOW_BL_GetCountOfACellList(StreamIndex2)
					If: BlockListCount>0
						Loop for: Variable BlockIndex from: 0 to: BlockListCount-1 step: 1
							Set Variable: StreamUnit:= MODFLOW_L_GetFromList(StreamUnitList, StreamIndex2)
							Set Variable: DumRow:= MODFLOW_BL_GetCellRow(StreamIndex2, BlockIndex)
							Set Variable: DumCol:= MODFLOW_BL_GetCellColumn(StreamIndex2, BlockIndex)
							Set Variable: BlockBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, DumCol, DumRow, StreamUnit)
							Set Variable: BlockTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, StreamUnit)
							Set Variable: StreamBottom:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, UpstreamBotElevIndex)
							If: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, InterpolateBottomElev)
								Set Variable: DownstreamStreamBottom:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, DownstreamBotElevIndex)
								Set Variable: StreamBottom:= StreamBottom - MODFLOW_BL_FractionOfLine(StreamIndex2, BlockIndex) * (StreamBottom - DownstreamStreamBottom)
							End if
							Set Variable: StreamStage:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, UpstreamStageIndex)
							Set Variable: StreamConductance:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, ConductivityIndex) * MODFLOW_BL_SumSegmentLengths(StreamIndex2, BlockIndex)
							If: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, InterpolateStage)
								Set Variable: DownstreamStreamStage:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, DownstreamStageIndex)
								Set Variable: StreamStage:= StreamStage - MODFLOW_BL_FractionOfLine(StreamIndex2, BlockIndex) * (StreamStage - DownstreamStreamStage)
							End if
							Set Variable: Width:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, UpstreamWidthIndex)
							If: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, InterpolateWidth)
								Set Variable: DownstreamWidth:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, DownstreamWidthIndex)
								Set Variable: Width:= Width - MODFLOW_BL_FractionOfLine(StreamIndex2, BlockIndex) * (Width - DownstreamWidth)
							End if
							Set Variable: StreamTop:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, UpstreamTopElevIndex)
							If: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, InterpolateTopElev)
								Set Variable: DownstreamStreamTop:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, DownstreamTopElevIndex)
								Set Variable: StreamTop:= StreamTop - MODFLOW_BL_FractionOfLine(StreamIndex2, BlockIndex) * (StreamTop - DownstreamStreamTop)
							End if
							Set Variable: StreamConductance:= StreamConductance * Width / (StreamTop - StreamBottom)
							Set Variable: CurrentStreamReachCount:= CurrentStreamReachCount + 1
							Start a new line
								Export expression: MODFLOW_Layer(StreamUnit, BlockTop, BlockBottom, StreamBottom) [I5]
								Export expression: DumRow [I5]
								Export expression: DumCol [I5]
								Export expression: StreamIndex + 1 [I5]
								Export expression: BlockIndex + 1 [I5]
								Export expression: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, FlowIndex); [G15]
								Export expression: StreamStage; [G9]
								Export expression: StreamConductance; [G9]
								Export expression: StreamBottom; [G9]
								Export expression: StreamTop [G9]
							End line
						End loop
					End if
				End loop
				If: ICALC
					Loop for: Variable StreamIndex from: 0 to: StreamSegmentCount-1 step: 1
						Set Variable: CurrentStream:= MODFLOW_L_GetFromList(SortedStreamSegmentList, StreamIndex)
						Set Variable: StreamIndex2:= MODFLOW_L_UnsortedIndexOf(StreamSegmentList, CurrentStream)
						# StreamIndex2 is now the index of the current stream segment and may be used to retrieve data about the current stream.
						Set Variable: BlockListCount:= MODFLOW_BL_GetCountOfACellList(StreamIndex2)
						If: BlockListCount>0
							Loop for: Variable BlockIndex from: 0 to: BlockListCount-1 step: 1
								Set Variable: Width:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, UpstreamWidthIndex)
								If: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, InterpolateWidth)
									Set Variable: DownstreamWidth:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, DownstreamWidthIndex)
									Set Variable: Width:= Width - MODFLOW_BL_FractionOfLine(StreamIndex2, BlockIndex) * (Width - DownstreamWidth)
								End if
								Start a new line
									Export expression: Width [G10]
									Export expression: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, SlopeIndex) [G10]
									Export expression: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, RoughnessIndex) [G10]
								End line
							End loop
						End if
					End loop
				End if
				If: NTRIB
					Loop for: Variable StreamIndex from: 0 to: StreamSegmentCount-1 step: 1
						Set Variable: CurrentStream:= MODFLOW_L_GetFromList(SortedStreamSegmentList, StreamIndex)
						Set Variable: StreamIndex2:= MODFLOW_L_UnsortedIndexOf(StreamSegmentList, CurrentStream)
						# StreamIndex2 is now the index of the current stream segment and may be used to retrieve data about the current stream.
						Start a new line
							# Loop for: Variable TributaryIndex from: 1 to: NTRIB step: 1
							Loop for: Variable TributaryIndex from: 1 to: 10 step: 1
								Export expression: MODFLOW_L_GetFrom3DList(Tributary2DArray, StreamIndex2, TributaryIndex , 0) [I5]
							End loop
						End line
					End loop
				End if
				If: NDIV
					Loop for: Variable StreamIndex from: 0 to: StreamSegmentCount-1 step: 1
						Set Variable: CurrentStream:= MODFLOW_L_GetFromList(SortedStreamSegmentList, StreamIndex)
						Set Variable: StreamIndex2:= MODFLOW_L_UnsortedIndexOf(StreamSegmentList, CurrentStream)
						# StreamIndex2 is now the index of the current stream segment and may be used to retrieve data about the current stream.
						Start a new line
							Export expression: MODFLOW_L_GetFromList(StreamTributaryList, StreamIndex2) [I10]
						End line
					End loop
				End if
			End file
			If: CurrentStreamReachCount>MaxStreamReachCount
				Set Variable: MaxStreamReachCount:= CurrentStreamReachCount
			End if
			Redirect output to: TempStream2
				Start a new line
					Export expression: CurrentStreamReachCount [I10]
					Export expression: 0 [I10]
					Export expression: 0 [I10]
				End line
			End file
			Evaluate expression: MODFLOW_Join_Files("TempStream2", "TempStream3", "TempStream2")\n
			Evaluate expression: MODFLOW_Join_Files("@adeFileName@.str", "TempStream2", "@adeFileName@.str")\n
		End loop
		Redirect output to: TempStream1
			Start a new line
				Export expression: MaxStreamReachCount [I10]
				Export expression: StreamSegmentCount [I10]
				Export expression: NTRIB [I10]
				Export expression: NDIV [I10]
				Export expression: ICALC [I10]
				Export expression: StreamCONST [G10]
				If: ISTCB1>0&OneCBCFile=1
					Export expression: 33 [I10]
				End if
				If: ISTCB1>0&OneCBCFile=0
					Export expression: 36 [I10]
				End if
				If: ISTCB1=0
					Export expression: -1 [I10]
				End if
				If: ISTCB2>0
					Export expression: 37 [I10]
				End if
				If: ISTCB2=0
					Export expression: 0 [I10]
				End if
			End line
		End file
		Evaluate expression: MODFLOW_Join_Files("TempStream1", "@adeFileName@.str", "@adeFileName@.str")\n
		Evaluate expression: MODFLOW_Delete_File("TempStream1")
		Evaluate expression: MODFLOW_Delete_File("TempStream2")
		Evaluate expression: MODFLOW_Delete_File("TempStream3")
	End if
End if
# 
# ----------------------------------------------------
# Horizontal Flow Barrier Package
# ----------------------------------------------------
If: HFBChoice&ExportHFB
	Evaluate expression: MODFLOW_ProgressBarSetMessage("Horizontal Flow Barrier Package")
	Evaluate expression: MODFLOW_Delete_File("temphfb1")
	Evaluate expression: MODFLOW_Delete_File("temphfb2")
	Evaluate expression: MODFLOW_Delete_File("temphfb3")
	Redirect output to: @adeFileName@.hfb
	End file
	Set Variable: TotalBarrierCount:= 0
	Evaluate expression: MODFLOW_BL_InitializeGridInformation("MODFLOW FD Grid")
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation
			If: MODFLOW_SIMUL(LayIndex)
				Redirect output to: TempHFB3
					Evaluate expression: MODFLOW_BL_ReInitializeVertexList()
					Evaluate expression: MODFLOW_BL_AddVertexLayer("Horizontal Flow Barrier Unit" + LayIndex)
					Set Variable: CurrentBarrierCount:= 0
					If: MODFLOW_BL_GetCountOfCrossColumnLists()
						Set Variable: BarrierIndex:= -1
						Loop for: Objects in layer: Horizontal Flow Barrier Unit[LayIndex]
							Set Variable: BarrierIndex:= BarrierIndex + 1
							If: MODFLOW_BL_GetCountOfACrossColumnList(BarrierIndex)
								Loop for: Variable CellIndex from: 0 to: MODFLOW_BL_GetCountOfACrossColumnList(BarrierIndex)-1 step: 1
									Set Variable: Row1:= MODFLOW_BL_GetCrossColumnRow(BarrierIndex, CellIndex)
									Set Variable: Row2:= MODFLOW_BL_GetCrossColumnNeighborRow(BarrierIndex, CellIndex)
									Set Variable: Column1:= MODFLOW_BL_GetCrossColumnColumn(BarrierIndex, CellIndex)
									Set Variable: Column2:= Column1
									If: !((Row2>RowCount)|(Row2<1))
										If: (MODFLOW_LAYCON(LayIndex)=0)|(MODFLOW_LAYCON(LayIndex)=2)
											# need to take into account multiple layer per unit
											Set Variable: AverageCellThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column1, Row1, LayIndex)
											Set Variable: HYDCHR:= Barrier Hydraulic Conductivity * AverageCellThickness / Barrier Thickness
										Else
											Set Variable: HYDCHR:= Barrier Hydraulic Conductivity / Barrier Thickness
										End if
										Set Variable: HYDCHR:= HYDCHR * Abs(MODFLOW_BL_GetCrossColumnCompositeX(BarrierIndex, CellIndex) / MODFLOW_BL_GetCrossColumnCompositeLength(BarrierIndex, CellIndex))
										Set Variable: CurrentBarrierCount:= CurrentBarrierCount + 1
										Start a new line
											Export expression: Row1 [I10]
											Export expression: Column1 [I10]
											Export expression: Row2 [I10]
											Export expression: Column2 [I10]
											Export expression: HYDCHR [G10]
										End line
									End if
								End loop
							End if
						End loop
					End if
					If: MODFLOW_BL_GetCountOfCrossRowLists()
						Set Variable: BarrierIndex:= -1
						Loop for: Objects in layer: Horizontal Flow Barrier Unit[LayIndex]
							Set Variable: BarrierIndex:= BarrierIndex + 1
							If: MODFLOW_BL_GetCountOfACrossRowList(BarrierIndex)
								Loop for: Variable CellIndex from: 0 to: MODFLOW_BL_GetCountOfACrossRowList(BarrierIndex)-1 step: 1
									Set Variable: Row1:= MODFLOW_BL_GetCrossRowRow(BarrierIndex, CellIndex)
									Set Variable: Row2:= Row1
									Set Variable: Column1:= MODFLOW_BL_GetCrossRowColumn(BarrierIndex, CellIndex)
									Set Variable: Column2:= MODFLOW_BL_GetCrossRowNeighborColumn(BarrierIndex, CellIndex)
									If: !((Column2>ColumnCount)|(Column2<1))
										If: (MODFLOW_LAYCON(LayIndex)=0)|(MODFLOW_LAYCON(LayIndex)=2)
											Set Variable: AverageCellThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column1, Row1, LayIndex)
											Set Variable: HYDCHR:= Horizontal Flow Barrier Unit[LayIndex].Barrier Hydraulic Conductivity * AverageCellThickness / Horizontal Flow Barrier Unit[LayIndex].Barrier Thickness
										Else
											Set Variable: HYDCHR:= Horizontal Flow Barrier Unit[LayIndex].Barrier Hydraulic Conductivity / Horizontal Flow Barrier Unit[LayIndex].Barrier Thickness
										End if
										Set Variable: HYDCHR:= HYDCHR * Abs(MODFLOW_BL_GetCrossRowCompositeY(BarrierIndex, CellIndex) / MODFLOW_BL_GetCrossRowCompositeLength(BarrierIndex, CellIndex))
										Set Variable: CurrentBarrierCount:= CurrentBarrierCount + 1
										Start a new line
											Export expression: Row1 [I10]
											Export expression: Column1 [I10]
											Export expression: Row2 [I10]
											Export expression: Column2 [I10]
											Export expression: HYDCHR [G10]
										End line
									End if
								End loop
							End if
						End loop
					End if
					Evaluate expression: MODFLOW_BL_ReInitializeVertexList()
				End file
				Redirect output to: temphfb2
					Start a new line
						Export expression: CurrentBarrierCount [I10]
					End line
				End file
				Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
					Set Variable: TotalBarrierCount:= TotalBarrierCount + CurrentBarrierCount
					Evaluate expression: MODFLOW_Join_Files("@adeFileName@.hfb", "temphfb2", "@adeFileName@.hfb")
					Evaluate expression: MODFLOW_Join_Files("@adeFileName@.hfb", "temphfb3", "@adeFileName@.hfb")
				End loop
			End if
		End if
	End loop
	If: ContinueSimulation
		Redirect output to: temphfb1
			Start a new line
				Export expression: TotalBarrierCount [I10]
			End line
		End file
		Evaluate expression: MODFLOW_Join_Files("temphfb1", "@adeFileName@.hfb", "@adeFileName@.hfb")
	End if
	Evaluate expression: MODFLOW_Delete_File("temphfb1")
	Evaluate expression: MODFLOW_Delete_File("temphfb2")
	Evaluate expression: MODFLOW_Delete_File("temphfb3")
End if
# 
# 
# ----------------------------------------------------
# Lake Package version 2.2:
# ----------------------------------------------------
If: ContinueSimulation
	If: LakeChoice
		Set Variable: LakeElevations3DList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), 2)
		Set Variable: MasterLakeList:= MODFLOW_L_CreateNewList()
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			If: MODFLOW_SIMUL(LayIndex)
				Loop for: Objects in layer: Lake Unit[LayIndex]
					Evaluate expression: MODFLOW_L_AddToList(MasterLakeList,Lake Unit[LayIndex].Lake Number)
				End loop
			End if
		End loop
		Evaluate expression: MODFLOW_L_SortList(MasterLakeList)
		Evaluate expression: MODFLOW_L_EliminateDuplicates(MasterLakeList)
		Set Variable: MasterLakeListSize:= MODFLOW_L_GetListSize(MasterLakeList)
		Set Variable: LakeColumnListsStart:= MasterLakeList + 1
		Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
			Set Variable: LakeRowListsStart:= MODFLOW_L_CreateNewList() + 1
		End loop
		Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
			Set Variable: LakeLayerListStart:= MODFLOW_L_CreateNewList() + 1
		End loop
		Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
			Set Variable: LakeTopElevListStart:= MODFLOW_L_CreateNewList() + 1
		End loop
		Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
			Set Variable: LakeBotElevListStart:= MODFLOW_L_CreateNewList() + 1
		End loop
		Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
			Set Variable: LakeAreaListStart:= MODFLOW_L_CreateNewList() + 1
		End loop
		Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
			Set Variable: LakeHydCondListStart:= MODFLOW_L_CreateNewList() + 1
		End loop
		Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
			Evaluate expression: MODFLOW_L_CreateNewList()
		End loop
		Set Variable: FoundLakeBottomCell3DList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), 1)
		Set Variable: ModflowLayer:= 0
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			If: MODFLOW_SIMUL(LayIndex)
				Loop for: Blocks
					Evaluate expression: MODFLOW_L_SetOneBased3DListItem(LakeElevations3DList, Column(), Row(), 1, Lakebed Top Unit[LayIndex])
					Evaluate expression: MODFLOW_L_SetOneBased3DListItem(LakeElevations3DList, Column(), Row(), 2, Lakebed Bottom Unit[LayIndex])
				End loop
				Set Variable: ModflowLayer:= ModflowLayer + MODFLOW_NDIV(LayIndex)
				Loop for: Blocks
					Set Variable: LakeNumber:= Lake To Right Unit[LayIndex]
					Set Variable: LocalKz:= Kx Unit[LayIndex]
					If: LakeNumber
						Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,LakeNumber)
						Set Variable: UnitTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)
						Set Variable: UnitBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
						Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Set Variable: LayerTop:= UnitTop - (DivIndex - 1) * LayerThickness
							Set Variable: LakebedTop:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column() + 1, Row(), 1)
							If: LakebedTop<=LayerTop
								Set Variable: LayerBottom:= UnitTop - DivIndex * LayerThickness
								Set Variable: LakebedBottom:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column() + 1, Row(), 2)
								If: LayerBottom<LakebedTop
									Set Variable: LocalBottom:= LakebedTop
								Else
									Set Variable: LocalBottom:= LayerBottom
								End if
								Set Variable: CrossSectionalArea:= (LayerTop - LocalBottom) * NthBlockSideLength(0)
								Evaluate expression: MODFLOW_L_AddToList(LakeRowListsStart + LakeIndex,Row())
								Evaluate expression: MODFLOW_L_AddToList(LakeColumnListsStart + LakeIndex,Column())
								Evaluate expression: MODFLOW_L_AddToList(LakeLayerListStart + LakeIndex,ModflowLayer - MODFLOW_NDIV(LayIndex) + DivIndex)
								Evaluate expression: MODFLOW_L_AddToList(LakeTopElevListStart + LakeIndex,LakebedTop)
								Evaluate expression: MODFLOW_L_AddToList(LakeBotElevListStart + LakeIndex,LakebedBottom)
								# Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] * (LakebedTop - LakebedBottom) / (NthBlockSideLength(1) / 2))
								If: LakeSideCondChoice=0
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity / (LakebedTop - LakebedBottom)*CrossSectionalArea)
								Else
									If: LakeSideCondChoice=1
										Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] * MODFLOW_TRPY(LayIndex) / (NthBlockSideLength(1) / 2)*CrossSectionalArea)
									Else
										Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,(1 / ((LakebedTop - LakebedBottom) / Lake Unit[LayIndex].Lakebed hydraulic conductivity + (NthBlockSideLength(1) / 2) / (Kx Unit[LayIndex] * MODFLOW_TRPY(LayIndex))))*CrossSectionalArea )
									End if
								End if
								Evaluate expression: MODFLOW_L_AddToList(LakeAreaListStart + LakeIndex,CrossSectionalArea)
							End if
						End loop
					End if
					Set Variable: LakeNumber:= Lake To Left Unit[LayIndex]
					If: LakeNumber
						Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,LakeNumber)
						Set Variable: UnitTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)
						Set Variable: UnitBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
						Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Set Variable: LayerTop:= UnitTop - (DivIndex - 1) * LayerThickness
							Set Variable: LakebedTop:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column()-1,Row(), 1)
							If: LakebedTop<=LayerTop
								Set Variable: LayerBottom:= UnitTop - DivIndex * LayerThickness
								Set Variable: LakebedBottom:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column()-1,Row(), 2)
								If: LayerBottom<LakebedTop
									Set Variable: LocalBottom:= LakebedTop
								Else
									Set Variable: LocalBottom:= LayerBottom
								End if
								Set Variable: CrossSectionalArea:= (LayerTop - LocalBottom) * NthBlockSideLength(0)
								Evaluate expression: MODFLOW_L_AddToList(LakeRowListsStart + LakeIndex,Row())
								Evaluate expression: MODFLOW_L_AddToList(LakeColumnListsStart + LakeIndex,Column())
								Evaluate expression: MODFLOW_L_AddToList(LakeLayerListStart + LakeIndex,ModflowLayer - MODFLOW_NDIV(LayIndex) + DivIndex)
								Evaluate expression: MODFLOW_L_AddToList(LakeTopElevListStart + LakeIndex,LakebedTop)
								Evaluate expression: MODFLOW_L_AddToList(LakeBotElevListStart + LakeIndex,LakebedBottom)
								# Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] * (LakebedTop - LakebedBottom) / (NthBlockSideLength(1) / 2))
								If: LakeSideCondChoice=0
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity / (LakebedTop - LakebedBottom)*CrossSectionalArea)
								Else
									If: LakeSideCondChoice=1
										Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] / (NthBlockSideLength(1) / 2)*CrossSectionalArea)
									Else
										Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,(1 / ((LakebedTop - LakebedBottom) / Lake Unit[LayIndex].Lakebed hydraulic conductivity + (NthBlockSideLength(1) / 2) / Kx Unit[LayIndex]))*CrossSectionalArea )
									End if
								End if
								Evaluate expression: MODFLOW_L_AddToList(LakeAreaListStart + LakeIndex,CrossSectionalArea)
							End if
						End loop
					End if
					Set Variable: LakeNumber:= Lake To North Unit[LayIndex]
					If: LakeNumber
						Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,LakeNumber)
						Set Variable: UnitTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)
						Set Variable: UnitBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
						Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Set Variable: LayerTop:= UnitTop - (DivIndex - 1) * LayerThickness
							Set Variable: LakebedTop:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column(),Row() + 1, 1)
							If: LakebedTop<=LayerTop
								Set Variable: LayerBottom:= UnitTop - DivIndex * LayerThickness
								Set Variable: LakebedBottom:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column(),Row() + 1, 2)
								If: LayerBottom<LakebedTop
									Set Variable: LocalBottom:= LakebedTop
								Else
									Set Variable: LocalBottom:= LayerBottom
								End if
								Set Variable: CrossSectionalArea:= (LayerTop - LocalBottom) * NthBlockSideLength(1)
								Evaluate expression: MODFLOW_L_AddToList(LakeRowListsStart + LakeIndex,Row())
								Evaluate expression: MODFLOW_L_AddToList(LakeColumnListsStart + LakeIndex,Column())
								Evaluate expression: MODFLOW_L_AddToList(LakeLayerListStart + LakeIndex,ModflowLayer - MODFLOW_NDIV(LayIndex) + DivIndex)
								Evaluate expression: MODFLOW_L_AddToList(LakeTopElevListStart + LakeIndex,LakebedTop)
								Evaluate expression: MODFLOW_L_AddToList(LakeBotElevListStart + LakeIndex,LakebedBottom)
								# Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] * (LakebedTop - LakebedBottom) / (NthBlockSideLength(0) / 2))
								If: LakeSideCondChoice=0
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity / (LakebedTop - LakebedBottom)*CrossSectionalArea)
								Else
									If: LakeSideCondChoice=1
										Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] / (NthBlockSideLength(0) / 2)*CrossSectionalArea)
									Else
										Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,(1 / ((LakebedTop - LakebedBottom) / Lake Unit[LayIndex].Lakebed hydraulic conductivity + (NthBlockSideLength(0) / 2) / Kx Unit[LayIndex]))*CrossSectionalArea )
									End if
								End if
								Evaluate expression: MODFLOW_L_AddToList(LakeAreaListStart + LakeIndex,CrossSectionalArea)
							End if
						End loop
					End if
					Set Variable: LakeNumber:= Lake To South Unit[LayIndex]
					If: LakeNumber
						Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,LakeNumber)
						Set Variable: UnitTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)
						Set Variable: UnitBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
						Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Set Variable: LayerTop:= UnitTop - (DivIndex - 1) * LayerThickness
							Set Variable: LakebedTop:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column(),Row() - 1, 1)
							If: LakebedTop<=LayerTop
								Set Variable: LayerBottom:= UnitTop - DivIndex * LayerThickness
								Set Variable: LakebedBottom:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column(),Row() - 1, 2)
								If: LayerBottom<LakebedTop
									Set Variable: LocalBottom:= LakebedTop
								Else
									Set Variable: LocalBottom:= LayerBottom
								End if
								Set Variable: CrossSectionalArea:= (LayerTop - LocalBottom) * NthBlockSideLength(1)
								Evaluate expression: MODFLOW_L_AddToList(LakeRowListsStart + LakeIndex,Row())
								Evaluate expression: MODFLOW_L_AddToList(LakeColumnListsStart + LakeIndex,Column())
								Evaluate expression: MODFLOW_L_AddToList(LakeLayerListStart + LakeIndex,ModflowLayer - MODFLOW_NDIV(LayIndex) + DivIndex)
								Evaluate expression: MODFLOW_L_AddToList(LakeTopElevListStart + LakeIndex,LakebedTop)
								Evaluate expression: MODFLOW_L_AddToList(LakeBotElevListStart + LakeIndex,LakebedBottom)
								# Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] * (LakebedTop - LakebedBottom) / (NthBlockSideLength(0) / 2))
								If: LakeSideCondChoice=0
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity / (LakebedTop - LakebedBottom)*CrossSectionalArea)
								Else
									If: LakeSideCondChoice=1
										Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] / (NthBlockSideLength(0) / 2)*CrossSectionalArea)
									Else
										Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,(1 / ((LakebedTop - LakebedBottom) / Lake Unit[LayIndex].Lakebed hydraulic conductivity + (NthBlockSideLength(0) / 2) / Kx Unit[LayIndex]))*CrossSectionalArea )
									End if
								End if
								Evaluate expression: MODFLOW_L_AddToList(LakeAreaListStart + LakeIndex,CrossSectionalArea)
							End if
						End loop
					End if
					Set Variable: LakeNumber:= LakeParam Unit[LayIndex]
					If: LakeNumber
						Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,LakeNumber)
						Set Variable: UnitTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)
						Set Variable: UnitBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
						Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
						Set Variable: FoundLakeCell:= 0
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							If: !FoundLakeCell
								Set Variable: LayerTop:= UnitTop - (DivIndex - 1) * LayerThickness
								Set Variable: LakebedTop:= Lakebed Top Unit[LayIndex]
								Set Variable: LayerBottom:= UnitTop - DivIndex * LayerThickness
								Set Variable: LakebedBottom:= Lakebed Bottom Unit[LayIndex]
								If: LayerTop<=LakebedBottom
									Set Variable: FoundLakeCell:= 1
									Evaluate expression: MODFLOW_L_SetOneBased3DListItem(FoundLakeBottomCell3DList, Column(), Row(), 1, 1)
									Evaluate expression: MODFLOW_L_AddToList(LakeRowListsStart + LakeIndex,Row())
									Evaluate expression: MODFLOW_L_AddToList(LakeColumnListsStart + LakeIndex,Column())
									Evaluate expression: MODFLOW_L_AddToList(LakeLayerListStart + LakeIndex,ModflowLayer - MODFLOW_NDIV(LayIndex) + DivIndex)
									Evaluate expression: MODFLOW_L_AddToList(LakeTopElevListStart + LakeIndex,LakebedTop)
									Evaluate expression: MODFLOW_L_AddToList(LakeBotElevListStart + LakeIndex,LakebedBottom)
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity)
									If: LakeBotCondChoice=0
										Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity / (LakebedTop - LakebedBottom)*BlockArea())
									Else
										Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,(1 / ((LakebedTop - LakebedBottom) / Lake Unit[LayIndex].Lakebed hydraulic conductivity + (LakebedBottom - LayerBottom) / 2 / LocalKz))*BlockArea())
									End if
									Evaluate expression: MODFLOW_L_AddToList(LakeAreaListStart + LakeIndex,BlockArea())
								End if
							End if
						End loop
					End if
					Set Variable: LakeNumber:= Lake Above Unit[LayIndex]
					If: LakeNumber
						Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,LakeNumber)
						If: (MODFLOW_L_GetFromOneBased3DList(FoundLakeBottomCell3DList, Column(), Row(), 1)=0)&(LayIndex>1)
							Set Variable: LakebedTop:= Lakebed Top Unit[LayIndex-1]
							Set Variable: LakebedBottom:= Lakebed Bottom Unit[LayIndex-1]
							Evaluate expression: MODFLOW_L_SetOneBased3DListItem(FoundLakeBottomCell3DList, Column(), Row(), 1, 1)
							Evaluate expression: MODFLOW_L_AddToList(LakeRowListsStart + LakeIndex,Row())
							Evaluate expression: MODFLOW_L_AddToList(LakeColumnListsStart + LakeIndex,Column())
							Evaluate expression: MODFLOW_L_AddToList(LakeLayerListStart + LakeIndex,ModflowLayer - MODFLOW_NDIV(LayIndex) + 1)
							Evaluate expression: MODFLOW_L_AddToList(LakeTopElevListStart + LakeIndex,Lakebed Top Unit[LayIndex-1])
							Evaluate expression: MODFLOW_L_AddToList(LakeBotElevListStart + LakeIndex,Lakebed Bottom Unit[LayIndex-1])
							If: LakeBotCondChoice=0
								Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex-1].Lakebed hydraulic conductivity / (LakebedTop - LakebedBottom)*BlockArea())
							Else
								Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,(1 / ((LakebedTop - LakebedBottom) / Lake Unit[LayIndex-1].Lakebed hydraulic conductivity + (LakebedBottom - LayerBottom) / 2 / LocalKz))*BlockArea())
							End if
							# Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity)
							Evaluate expression: MODFLOW_L_AddToList(LakeAreaListStart + LakeIndex,BlockArea())
						Else
							# Error
						End if
					End if
				End loop
			End if
		End loop
		Redirect output to: TempLakePhysical
		End file
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			If: MODFLOW_SIMUL(LayIndex)
				Loop for: Objects in layer: Lake Unit[LayIndex]
					Set Variable: NSTRIN:= 0
					Redirect output to: TempLake5
						Loop for: Variable SegmentIndex from: 1 to: MaxInflowSegments step: 1
							If: IsNumber(Input Stream[SegmentIndex])
								Set Variable: NSTRIN:= NSTRIN + 1
								Start a new line
									Export expression: MODFLOW_L_UnsortedIndexOf(StreamSegmentList, Input Stream[SegmentIndex])+1 [I10]
								End line
							End if
						End loop
					End file
					Set Variable: NSTROUT:= 0
					Loop for: Variable SegmentIndex from: 1 to: MaxOutflowSegments step: 1
						Redirect output to: TempLake7
						End file
						Redirect output to: TempLake6
						End file
						If: IsNumber(Output Stream[SegmentIndex])
							Set Variable: NSTROUT:= NSTROUT + 1
							Set Variable: NRATEQ:= 0
							Redirect output to: TempLake7
								Loop for: Variable RateEqIndex from: 1 to: MaxRateEq step: 1
									If: IsNumber(Eq Cutoff[SegmentIndex * 10 + RateEqIndex])
										Set Variable: NRATEQ:= NRATEQ + 1
										Start a new line
											Export expression: Eq Cutoff[SegmentIndex * 10 + RateEqIndex] [G10]
											Export expression: Eq Const[SegmentIndex * 10 + RateEqIndex] [G10]
											Export expression: Eq Elev[SegmentIndex * 10 + RateEqIndex] [G10]
											Export expression: Eq exponent[SegmentIndex * 10 + RateEqIndex] [G10]
										End line
									End if
								End loop
							End file
							Redirect output to: TempLake6
								Start a new line
									Export expression: MODFLOW_L_UnsortedIndexOf(StreamSegmentList, Output Stream[SegmentIndex])+1 [I10]
									Export expression: NRATEQ [I10]
								End line
							End file
						End if
						Redirect output to: TempLake8
							Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,Lake Unit[LayIndex].Lake Number)
							Set Variable: NODES:= MODFLOW_L_GetListSize(LakeLayerListStart + LakeIndex)
							Loop for: Variable CellIndex from: 0 to: NODES-1 step: 1
								Start a new line
									Export expression: MODFLOW_L_GetFromList(LakeLayerListStart + LakeIndex, CellIndex) [I10]
									Export expression: MODFLOW_L_GetFromList(LakeRowListsStart + LakeIndex, CellIndex) [I10]
									Export expression: MODFLOW_L_GetFromList(LakeColumnListsStart + LakeIndex, CellIndex) [I10]
									Export expression: MODFLOW_L_GetFromList(LakeTopElevListStart + LakeIndex, CellIndex) [G10]
									Export expression: MODFLOW_L_GetFromList(LakeBotElevListStart + LakeIndex, CellIndex) [G10]
									Export expression: MODFLOW_L_GetFromList(LakeAreaListStart + LakeIndex, CellIndex) [G10]
									Export expression: MODFLOW_L_GetFromList(LakeHydCondListStart + LakeIndex, CellIndex) [G10]
								End line
							End loop
						End file
						Redirect output to: TempLake4
							Start a new line
								Export expression: NODES [I10]
								Export expression: NSTRIN [I10]
								Export expression: NSTROUT [I10]
								Export expression: Maximum Lake Stage [G10]
								Export expression: 1 [I10]
							End line
						End file
						Evaluate expression: MODFLOW_Join_Files("TempLakePhysical", "TempLake4", "TempLakePhysical")
						Evaluate expression: MODFLOW_Join_Files("TempLakePhysical", "TempLake5", "TempLakePhysical")
						Evaluate expression: MODFLOW_Join_Files("TempLakePhysical", "TempLake6", "TempLakePhysical")
						Evaluate expression: MODFLOW_Join_Files("TempLakePhysical", "TempLake7", "TempLakePhysical")
						Evaluate expression: MODFLOW_Join_Files("TempLakePhysical", "TempLake8", "TempLakePhysical")
					End loop
				End loop
			End if
		End loop
		Set Variable: NLAKES:= 0
		Redirect output to: TempLake3
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				If: MODFLOW_SIMUL(LayIndex)
					Loop for: Objects in layer: Lake Unit[LayIndex]
						Set Variable: NLAKES:= NLAKES + 1
						Start a new line
							Export expression: Lake Name [G10]
							Export expression: Simulation mode [I10]
							Export expression: Starting Stage [G10]
							Export expression: Max Iterations [I10]
							Export expression: Stage Convergence Criterion [G10]
						End line
					End loop
				End if
			End loop
		End file
		Redirect output to: @adeFileName@.lak
			Start a new line
				Export expression: "/*LAK2.2" [G0]
			End line
			Start a new line
				Export expression: NLAKES [I10]
				Export expression: ILKCBC [I10]
				Export expression: ILKOUT [I10]
				Export expression: 1 [I10]
				Export expression: NSUBSTEPS [I10]
			End line
		End file
		Evaluate expression: MODFLOW_Join_Files("@adeFileName@.lak", "TempLake3", "@adeFileName@.lak")
		Evaluate expression: MODFLOW_Join_Files("@adeFileName@.lak", "TempLakePhysical", "@adeFileName@.lak")
		Redirect output to: TempLake9
			Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
				Start a new line
					If: PeriodIndex=1
						Export expression: 1 [G0]
					Else
						Export expression: SteadyLake - 1 [G0]
					End if
				End line
				If: (PeriodIndex=1)|SteadyLake
					Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
						If: MODFLOW_SIMUL(LayIndex)
							Loop for: Objects in layer: Lake Unit[LayIndex]
								Start a new line
									Export expression: Precipitation[PeriodIndex] [G10]
									Export expression: Evapotranspiration[PeriodIndex] [G10]
									Export expression: Runoff[PeriodIndex] [G10]
									Export expression: Dry Recharge[PeriodIndex] [G10]
									Export expression: Output option[PeriodIndex] [I10]
									Export expression: Stage[PeriodIndex] [G10]
								End line
							End loop
						End if
					End loop
				End if
			End loop
		End file
		Evaluate expression: MODFLOW_Join_Files("@adeFileName@.lak", "TempLake9", "@adeFileName@.lak")
		Evaluate expression: MODFLOW_Delete_File("TempLake3")
		Evaluate expression: MODFLOW_Delete_File("TempLake4")
		Evaluate expression: MODFLOW_Delete_File("TempLake5")
		Evaluate expression: MODFLOW_Delete_File("TempLake6")
		Evaluate expression: MODFLOW_Delete_File("TempLake7")
		Evaluate expression: MODFLOW_Delete_File("TempLake8")
		Evaluate expression: MODFLOW_Delete_File("TempLake9")
		Evaluate expression: MODFLOW_Delete_File("TempLakePhysical")
	End if
End if
# 
# ----------------------------------------------------
# Successive Overrelaxation Solver
# ----------------------------------------------------
If: SolverChoice=3&ExportSOL!=0
	Evaluate expression: MODFLOW_ProgressBarSetMessage("Successive Overrelaxation Solver")
	Redirect output to: @adeFileName@.sor
		Start a new line
			Export expression: SOR_MXITER [I10]
		End line
		Start a new line
			# Begin change, RBW, Format changed from [E13.5] to [G13]
			Export expression: SOR_ACCL [G10]
			Export expression: SOR_HCLOSE [G10]
			# end change, RBW
			Export expression: SOR_IPRSOR [I10]
		End line
	End file
End if
# ----------------------------------------------------
# Strongly-implicit procedure Solver
# ----------------------------------------------------
If: SolverChoice=0&ExportSOL!=0
	Evaluate expression: MODFLOW_ProgressBarSetMessage("Strongly-implicit procedure Solver")
	Redirect output to: @adeFileName@.sip
		Start a new line
			Export expression: SIP_MXITER [I10]
			Export expression: SIP_NPARM [I10]
		End line
		Start a new line
			# Begin change, RBW, Format changed from [E13.5] to [G13]
			Export expression: SIP_ACCL [G10]
			Export expression: SIP_HCLOSE [G10]
			# end change, RBW
			Export expression: SIP_IPCALC [I10]
			Export expression: SIP_WSEED [G10]
			Export expression: SIP_IPRSIP [I10]
		End line
	End file
End if
# ----------------------------------------------------
# Preconditioned-Conjugate Gradient Solver
# ----------------------------------------------------
If: SolverChoice=2&ExportSOL!=0
	Evaluate expression: MODFLOW_ProgressBarSetMessage("Preconditioned-Conjugate Gradient Solver")
	Redirect output to: @adeFileName@.pcg
		Start a new line
			Export expression: PCG_MXITER [I10]
			Export expression: PCG_ITER1 [I10]
			Export expression: PCG_NPCOND [I10]
		End line
		Start a new line
			# Begin change, RBW, Format changed from [F10.4] to [G10]
			Export expression: PCG_HCLOSE [G10]
			Export expression: PCG_RCLOSE [G10]
			Export expression: PCG_RELAX [G10]
			# end change, RBW
			Export expression: PCG_NBPOL [I10]
			Export expression: PCG_IPRPCG [I10]
			Export expression: PCG_MUTPCG [I10]
			Export expression: PCG_DAMP [G10]
		End line
	End file
End if
# ----------------------------------------------------
# Direct solution with D4 ordering Solver
# ----------------------------------------------------
If: SolverChoice=1&ExportSOL!=0
	Evaluate expression: MODFLOW_ProgressBarSetMessage("Direct solution with D4 ordering Solver")
	Redirect output to: @adeFileName@.de4
		Start a new line
			Export expression: DE4_ITMX [I10]
			Export expression: DE4_MXUP [I10]
			Export expression: DE4_MXLOW [I10]
			Export expression: DE4_MXBW [I10]
		End line
		Start a new line
			Export expression: DE4_IFREQ [I10]
			Export expression: DE4_MUTD4 [I10]
			# Begin change, RBW, Format changed from [F10.4] to [G10]
			Export expression: DE4_ACCL [G10]
			Export expression: DE4_HCLOSE [G10]
			# end change, RBW
			Export expression: DE4_IPRD4 [I10]
		End line
	End file
End if
# ----------------------------------------------------
# Solute Transport section
# ----------------------------------------------------
If: TransportFlag=1
	Evaluate expression: MODFLOW_ProgressBarSetMessage("Solute Transport")
	# ----------------------------------------------------
	# MOC3D Transport
	# ----------------------------------------------------
	If: Transport>0
		# MOC3D Name File
		Set Variable: j:= 0
		Loop for: Variable LayIndex from: MOC_ISLAY1 to: MOC_ISLAY2 step: 1
			If: MODFLOW_SIMUL(LayIndex)=0
				Set Variable: j:= 1
				Evaluate expression: MODFLOW_ProgressBarAddLine("Layer " + LayIndex + " is non-simulated. Non simulated layers are not allowed in the MOC3D subgrid!")
			End if
		End loop
		If: j=1
			Set Variable: err_moc_1:= 1
			# Alert: "Non simulated layers are not allowed in the MOC3D subgrid!"
		End if
		Redirect output to: @adeFileName@.mcn
			Start a new line
				# File for LISTING results of MOC3D simulation
				Export expression: "CLST 71 "+FileName+".out" [G0]
			End line
			If: Transport=1
				Start a new line
					# File for reading main MOC3D input data file
					Export expression: "MOC 72 "+FileName+".moc" [G0]
				End line
			Else
				If: Transport=2
					Start a new line
						# File for reading main MOCIMP input data file
						Export expression: "MOCIMP 72 "+FileName+".moc" [G0]
					End line
				End if
			End if
			If: RechargeChoice=1
				Start a new line
					# File for reading concentrations in recharge
					Export expression: "CRCH 73 "+FileName+".crc" [G0]
				End line
			End if
			If: MOC_CNC_OPT=1 | MOC_CNC_OPT=3
				Start a new line
					# File for writing concentration output (text)
					Export expression: "CNCA 74 "+FileName+".cna" [G0]
				End line
			End if
			If: MOC_CNC_OPT=2 | MOC_CNC_OPT=3
				Start a new line
					# File for writing concentration output (binary)
					Export expression: "CNCB 75 "+FileName+".cnb" [G0]
				End line
			End if
			If: MOC_VEL_OPT=1 | MOC_VEL_OPT=3
				Start a new line
					# File for writing velocity output (text)
					Export expression: "VELA 76 "+FileName+".vla" [G0]
				End line
			End if
			If: MOC_VEL_OPT=2 | MOC_VEL_OPT=3
				Start a new line
					# File for writing velocity output (binary)
					Export expression: "VELB 77 "+FileName+".vlb" [G0]
				End line
			End if
			If: MOC_PRT_OPT=1 | MOC_PRT_OPT=3
				Start a new line
					# File for writing paricle location output (text)
					Export expression: "PRTA 78 "+FileName+".pta" [G0]
				End line
			End if
			If: MOC_PRT_OPT=2 | MOC_PRT_OPT=3
				Start a new line
					# File for writing paricle location output (binary)
					Export expression: "PRTB 79 "+FileName+".ptb" [G0]
				End line
			End if
			If: MOC_NUMOBS>0
				Start a new line
					# File for reading OBS package information
					Export expression: "OBS 80 "+FileName+".obs" [G0]
				End line
				If: MOC_IOBSFL>0
					Start a new line
						# File for writing observation well data (one file, IOBSFL must be > 0)
						Export expression: "DATA 100 "+FileName+".oba" [G0]
					End line
				Else
					Loop for: Variable i from: 1 to: MOC_NUMOBS step: 1
						Start a new line
							Export expression: "DATA "+(99+i)+" "+FileName+i+".oba" [G0]
						End line
					End loop
				End if
			End if
		End file
		# MOC3D Package:
		If: ExportTRANS!=0
			Redirect output to: @adeFileName@.moc
				Start a new line
					Export expression: Heading1 [G0]
				End line
				Start a new line
					Export expression: Heading2 [G0]
				End line
				Start a new line
					Export expression: FirstLay [I5]
					Export expression: LastLay [I5]
					Export expression: MOC_ISROW1 [I5]
					Export expression: MOC_ISROW2 [I5]
					Export expression: MOC_ISCOL1 [I5]
					Export expression: MOC_ISCOL2 [I5]
				End line
				Start a new line
					Export expression: MOC_NODISP [I5]
					Export expression: MOC_DECAY [E13.5]
					Export expression: MOC_DIFFUS [E13.5]
				End line
				Start a new line
					Export expression: MOC_NPMAX [I5]
					Export expression: if(MOC_NPCUST,-1,1)*MOC_NPTPND [I5]
				End line
				If: MOC_NPCUST
					# Custom particle positioning
					Loop for: Variable i from: 1 to: MOC_NPTPND step: 1
						Start a new line
							Export expression: MODFLOW_MOC_PNEWL(i) [E13.5]
							Export expression: MODFLOW_MOC_PNEWR(i) [E13.5]
							Export expression: MODFLOW_MOC_PNEWC(i) [E13.5]
						End line
					End loop
				End if
				Start a new line
					Export expression: MOC_CELDIS [E13.5]
					Export expression: MOC_FZERO [E13.5]
					Export expression: MOC_INTRPL+1 [I5]
				End line
				If: Transport=2
					Start a new line
						Export expression: MOC_FDTMTH [E13.5]
						Export expression: MOC_NCXIT [I5]
						Export expression: MOC_IDIREC [I5]
						Export expression: MOC_EPSSLV [E13.5]
						Export expression: MOC_MAXIT [I5]
					End line
				End if
				Start a new line
					Export expression: if(MOC_NPNTCL<3,MOC_NPNTCL-2,MOC_NPNTCLN) [I5]
					Export expression: 0 [I5]
					Export expression: if(MOC_NPNTVL<2,MOC_NPNTVL-1,MOC_NPNTVLN) [I5]
					Export expression: 0 [I5]
					Export expression: if(MOC_NPNTDL<3,MOC_NPNTDL-2,MOC_NPNTDLN) [I5]
					Export expression: 0 [I5]
					Export expression: if(MOC_PRT_OPT,0,if(MOC_NPNTPL<3,MOC_NPNTPL-2,MOC_NPNTPLN)) [I5]
				End line
				Start a new line
					Export expression: MOC_CNOFLO [E13.5]
				End line
				Loop for: Variable LayIndex from: MOC_ISLAY1 to: MOC_ISLAY2 step: 1
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						If: MODFLOW_SIMUL(LayIndex)!=0
							Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								Start a new line
									Export expression: "INTERNAL 1 (FREE)" [G0]
									Export expression: 0 [I5]
								End line
								# only export the subgrid
								Set Variable: n:= 0
								Loop for: Blocks
									If: Row()>=MOC_ISROW1 & Row()<=MOC_ISROW2 & Column()>=MOC_ISCOL1 & Column()<=MOC_ISCOL2
										If: ((n=NColsSub)|(n=0))
											Export expression: MODFLOW FD Grid.Init Concentration Unit[LayIndex] [E13.5]
											Set Variable: n:= 0
										Else
											Export expression: MODFLOW FD Grid.Init Concentration Unit[LayIndex] [E13.5]
										End if
										Set Variable: n:= n+1
										If: (n=NColsSub)
											Start a new line
											End line
										End if
									End if
								End loop
							End loop
						End if
					End if
				End loop
				# cinfl array: size depends on subgrid existance and positioning
				If: ContinueSimulation
					If: (MOC_ISROW1>1)|(MOC_ISROW2<NumRows())|(MOC_ISCOL1>1)|(MOC_ISCOL2<NumColumns())|(MOC_ISLAY1>1)|(MOC_ISLAY2<MODFLOW_NLAY())
						Start a new line
							Export expression: "INTERNAL 1.0 (FREE)" [G0]
							Export expression: 1 [I5]
						End line
						Start a new line
							If: (MOC_ISROW1>1)|(MOC_ISROW2<NumRows())|(MOC_ISCOL1>1)|(MOC_ISCOL2<NumColumns())
								Loop for: Variable LayIndex from: MOC_ISLAY1 to: MOC_ISLAY2 step: 1
									If: MODFLOW_SIMUL(LayIndex)!=0
										Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
											Export expression: MODFLOW_MOC_CINFL(LayIndex) [8E13.5]
										End loop
									End if
								End loop
							End if
							If: MOC_ISLAY1>1
								Export expression: MODFLOW_MOC_CINFL(MOC_ISLAY1-1) [8E13.5]
							End if
							If: MOC_ISLAY2<MODFLOW_NLAY()
								Export expression: MODFLOW_MOC_CINFL(MOC_ISLAY2+1) [8E13.5]
							End if
						End line
					End if
					Start a new line
						Export expression: MODFLOW_L_GetListSize(ConcentrationList) [I5]
					End line
					If: MODFLOW_L_GetListSize(ConcentrationList)>0
						Loop for: Variable i from: 1 to: MODFLOW_L_GetListSize(ConcentrationList) step: 1
							Start a new line
								Export expression: -i [I5]
								Export expression: MODFLOW_L_GetFromList(ConcentrationList, i-1) [E13.5]
							End line
						End loop
					End if
				End if
				If: ContinueSimulation
					Loop for: Variable LayIndex from: MOC_ISLAY1 to: MOC_ISLAY2 step: 1
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
						If: ContinueSimulation
							If: MODFLOW_SIMUL(LayIndex)!=0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Start a new line
										Export expression: "INTERNAL 1 (FREE)" [G0]
										Export expression: 7 [I5]
									End line
									# only export the subgrid
									Set Variable: n:= 0
									Loop for: Blocks
										If: Row()>=MOC_ISROW1 & Row()<=MOC_ISROW2 & Column()>=MOC_ISCOL1 & Column()<=MOC_ISCOL2
											If: ((n=NColsSub)|(n=0))
												Export expression: MODFLOW FD Grid.Particle Regeneration Unit[LayIndex] [I5]
												Set Variable: n:= 0
											Else
												Export expression: MODFLOW FD Grid.Particle Regeneration Unit[LayIndex] [I5]
											End if
											Set Variable: n:= n+1
											If: (n=NColsSub)
												Start a new line
												End line
											End if
										End if
									End loop
								End loop
							End if
						End if
					End loop
				End if
				If: ContinueSimulation
					If: MOC_NODISP=0
						Start a new line
							Export expression: "INTERNAL 1.0 (FREE)" [G0]
							Export expression: 1 [I5]
						End line
						Start a new line
							Loop for: Variable LayIndex from: MOC_ISLAY1 to: MOC_ISLAY2 step: 1
								If: MODFLOW_SIMUL(LayIndex)!=0
									Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
										Export expression: MODFLOW_MOC_ALONG(LayIndex) [8E13.5]
									End loop
								End if
							End loop
						End line
						Start a new line
							Export expression: "INTERNAL 1.0 (FREE)" [G0]
							Export expression: 1 [I5]
						End line
						Start a new line
							Loop for: Variable LayIndex from: MOC_ISLAY1 to: MOC_ISLAY2 step: 1
								If: MODFLOW_SIMUL(LayIndex)!=0
									Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
										Export expression: MODFLOW_MOC_ATRANH(LayIndex) [8E13.5]
									End loop
								End if
							End loop
						End line
						Start a new line
							Export expression: "INTERNAL 1.0 (FREE)" [G0]
							Export expression: 1 [I5]
						End line
						Start a new line
							Loop for: Variable LayIndex from: MOC_ISLAY1 to: MOC_ISLAY2 step: 1
								If: MODFLOW_SIMUL(LayIndex)!=0
									Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
										Export expression: MODFLOW_MOC_ATRANV(LayIndex) [8E13.5]
									End loop
								End if
							End loop
						End line
					End if
					Start a new line
						Export expression: "INTERNAL 1.0 (FREE)" [G0]
						Export expression: 1 [I5]
					End line
					Start a new line
						Loop for: Variable LayIndex from: MOC_ISLAY1 to: MOC_ISLAY2 step: 1
							If: MODFLOW_SIMUL(LayIndex)!=0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Export expression: MODFLOW_MOC_RF(LayIndex) [8E13.5]
								End loop
							End if
						End loop
					End line
				End if
				If: ContinueSimulation
					Loop for: Variable LayIndex from: MOC_ISLAY1 to: MOC_ISLAY2 step: 1
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
						If: ContinueSimulation
							If: MODFLOW_SIMUL(LayIndex)!=0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Start a new line
										Export expression: "INTERNAL 1 (FREE)" [G0]
										Export expression: 0 [I5]
									End line
									# only export the subgrid
									Set Variable: n:= 0
									Loop for: Blocks
										If: Row()>=MOC_ISROW1 & Row()<=MOC_ISROW2 & Column()>=MOC_ISCOL1 & Column()<=MOC_ISCOL2
											If: ((n=NColsSub)|(n=0))
												Export expression: MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex) [E13.5]
												Set Variable: n:= 0
											Else
												Export expression: MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex) [E13.5]
											End if
											Set Variable: n:= n+1
											If: (n=NColsSub)
												Start a new line
												End line
											End if
										End if
									End loop
									Start a new line
										Export expression: "INTERNAL 1 (FREE)" [G0]
										Export expression: 5 [I5]
									End line
									# only export the subgrid
									Set Variable: n:= 0
									Loop for: Blocks
										If: Row()>=MOC_ISROW1 & Row()<=MOC_ISROW2 & Column()>=MOC_ISCOL1 & Column()<=MOC_ISCOL2
											If: ((n=NColsSub)|(n=0))
												Export expression: MODFLOW FD Grid.Porosity Unit[LayIndex] [E13.5]
												Set Variable: n:= 0
											Else
												Export expression: MODFLOW FD Grid.Porosity Unit[LayIndex] [E13.5]
											End if
											Set Variable: n:= n+1
											If: (n=NColsSub)
												Start a new line
												End line
											End if
										End if
									End loop
								End loop
							End if
						End if
					End loop
				End if
			End file
			# Evaluate expression: MODFLOW_MOC_EndZones()
			#  MOC3D Concentrations in recharge
			If: ContinueSimulation
				If: RechargeChoice!=0
					Redirect output to: @adeFileName@.crc
						Start a new line
							Export expression: 0 [I5]
						End line
						# Export Recharge concentrations for stress period 1
						Start a new line
							Export expression: "INTERNAL 1.0  (FREE)" [G0]
							Export expression: 0 [I5]
						End line
						# only export the subgrid
						Set Variable: n:= 0
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
						If: ContinueSimulation
							Loop for: Blocks
								If: Row()>=MOC_ISROW1 & Row()<=MOC_ISROW2 & Column()>=MOC_ISCOL1 & Column()<=MOC_ISCOL2
									If: ((n=NColsSub)|(n=0))
										Export expression: Recharge Concentration.Concentration1 [E13.5]
										Set Variable: n:= 0
									Else
										Export expression: Recharge Concentration.Concentration1 [E13.5]
									End if
									Set Variable: n:= n+1
									If: (n=NColsSub)
										Start a new line
										End line
									End if
								End if
							End loop
							If: ContinueSimulation
							End if
							Loop for: Variable PeriodIndex from: 2 to: MODFLOW_NPER() step: 1
								Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
								If: ContinueSimulation
									Start a new line
										Export expression: if(MOC_INCRCH>0,-1,0) [I5]
									End line
									If: MOC_INCRCH=0
										Start a new line
											Export expression: "INTERNAL 1.0  (FREE)" [G0]
											Export expression: 0 [I5]
										End line
										# only export the subgrid
										Set Variable: n:= 0
										Loop for: Blocks
											If: Row()>=MOC_ISROW1 & Row()<=MOC_ISROW2 & Column()>=MOC_ISCOL1 & Column()<=MOC_ISCOL2
												If: ((n=NColsSub)|(n=0))
													Export expression: Recharge Concentration.Concentration[PeriodIndex] [E13.5]
													Set Variable: n:= 0
												Else
													Export expression: Recharge Concentration.Concentration[PeriodIndex] [E13.5]
												End if
												Set Variable: n:= n+1
												If: (n=NColsSub)
													Start a new line
													End line
												End if
											End if
										End loop
									End if
								End if
							End loop
						End if
					End file
				End if
			End if
		End if
		# MOC3D Observation well file
		If: ContinueSimulation
			If: ExportOBS!=0
				If: MOC_NUMOBS>0
					Redirect output to: @adeFileName@.obs
						Start a new line
							Export expression: MOC_NUMOBS [I5]
							Export expression: MOC_IOBSFL [I5]
						End line
						Set Variable: n:= 1
						Loop for: Variable LayIndex from: MOC_ISLAY1 to: MOC_ISLAY2 step: 1
							Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
							If: ContinueSimulation
								If: LayIndex=MOC_ISLAY1
									Set Variable: M:= MOC_ISLAY1-1
								Else
									Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
								End if
								If: MODFLOW_SIMUL(LayIndex)!=0
									Loop for: Variable k from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
										Loop for: Blocks
											Set Variable: DumRow:= Row()
											Set Variable: DumCol:= Column()
											Set Variable: DumLay:= M+k
											Loop for: Objects in layer: MOC3D Observation Wells
												Set Variable: LayerTop:= Elevation Top Unit[LayIndex]
												Set Variable: LayerThickness:= (LayerTop - Elevation Bottom Unit[LayIndex]) / MODFLOW_NDIV(LayIndex)
												Loop for: Variable i from: 1 to: 5 step: 1
													Set Variable: WD:= MOC3D Observation Wells.Elevation[i]
													Set Variable: TML:= LayerTop-(k-1)*LayerThickness
													Set Variable: BML:= LayerTop-k*LayerThickness
													If: IsNumber(WD) & TML>WD & BML<=WD
														Start a new line
															Export expression: DumLay [I5]
															Export expression: DumRow [I5]
															Export expression: DumCol [I5]
															Export expression: 99+n [I5]
														End line
														Set Variable: n:= n+1
													End if
												End loop
											End loop
										End loop
									End loop
								End if
							End if
						End loop
					End file
				End if
			End if
		End if
	End if
End if
# ----------------------------------------------------
# Write error log for MODFLOW & MOC3D export
# ----------------------------------------------------
If: (err_geo=1|err_bcf_1=1|err_rch_1=1|err_evt_1=1|err_ghb_1=1|err_ghb_2=1|err_riv_1=1|err_riv_2=1|err_riv_3=1|err_riv_4=1|err_drn_1=1|err_drn_2=1|err_drn_3=1|err_drn_4=1|err_wel_1=1|err_wel_2=1|err_moc_1=1)
	Evaluate expression: MODFLOW_ProgressBarSetMessage("Write error log")
	Alert: "Error found while exporting!  See error file (Rootname.err)"
	Redirect output to: @adeFileName@.err
		If: err_geo=1
			Start a new line
				Export expression: "Error - Project Information: No geologic units are specified in simulation" [G0]
			End line
		End if
		If: err_bcf_1=1
			Start a new line
				Export expression: "Error - Project Information: Only the top simulated geologic unit can be unconfined" [G0]
			End line
		End if
		If: err_rch_1=1
			Start a new line
				Export expression: "Warning - Recharge Information: Recharge elevation is located in a nonsimulated geologic unit - check recharge elevation and export Recharge package again" [G0]
			End line
		End if
		If: err_evt_1=1
			Start a new line
				Export expression: "Warning - Evapotranspiration Information: Evapotranspiration surface is located in a nonsimulated geologic unit - check evapotranspiration surface and export Evapotranspiration package again" [G0]
			End line
		End if
		If: err_ghb_1=1
			Start a new line
				Export expression: "Error - The PIE Chk_LayArray.DLL is missing - results from General Head Boundary package will not be generated" [G0]
			End line
		End if
		If: err_ghb_2=1
			Start a new line
				Export expression: "Error - The PIE Chk_BlockArray.DLL is missing - results from General Head Boundary package will not be generated" [G0]
			End line
		End if
		If: err_riv_1=1
			Start a new line
				Export expression: "Error - The PIE Chk_LayArray.DLL is missing - results from River package will not be generated" [G0]
			End line
		End if
		If: err_riv_2=1
			Start a new line
				Export expression: "Error - The PIE Chk_BlockArray.DLL is missing - results from River package will not be generated" [G0]
			End line
		End if
		If: err_riv_3=1
			Start a new line
				Export expression: "Warning - Line river elevation does not lie within the geologic unit - Line river is placed in the uppermost model layer of the geologic unit - Check line river elevations for possible errors" [G0]
			End line
		End if
		If: err_riv_4=1
			Start a new line
				Export expression: "Warning - Area river elevation does not lie within the geologic unit - Area river is placed in the uppermost model layer of the geologic unit - Check area river elevations for possible errors" [G0]
			End line
		End if
		If: err_drn_1=1
			Start a new line
				Export expression: "Error - The PIE Chk_LayArray.DLL is missing - results from Drain package will not be generated" [G0]
			End line
		End if
		If: err_drn_2=1
			Start a new line
				Export expression: "Error - The PIE Chk_BlockArray.DLL is missing - results from Drain package will not be generated" [G0]
			End line
		End if
		If: err_drn_3=1
			Start a new line
				Export expression: "Warning - Line drain elevation does not lie within the geologic unit - Line drain is placed in the uppermost model layer of the geologic unit - Check line drain elevations for possible errors" [G0]
			End line
		End if
		If: err_drn_4=1
			Start a new line
				Export expression: "Warning - Area drain elevation does not lie within the geologic unit - Area drain is placed in the uppermost model layer of the geologic unit - Check area drain elevations for possible errors" [G0]
			End line
		End if
		If: err_wel_1=1
			Start a new line
				Export expression: "Error - The PIE Chk_LayArray.DLL is missing - results from Well package will not be generated" [G0]
			End line
		End if
		If: err_wel_2=1
			Start a new line
				Export expression: "Error - The PIE Chk_BlockArray.DLL is missing - results from Well package will not be generated" [G0]
			End line
		End if
		If: err_moc_1=1
			Start a new line
				Export expression: "Error - Non simulated layers are not allowed in the MOC3D subgrid!" [G0]
			End line
		End if
	End file
End if
# 
# ----------------------------------------------------
# Run MODFLOW.EXE
# ----------------------------------------------------
# batch file to run MODFLOW
Evaluate expression: MODFLOW_ProgressBarSetMessage("Run MODFLOW or MOC3D")
Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
If: ContinueSimulation
	If: !RunMOC3D
		Redirect output to: MODFLOW.BAT
			Start a new line
				Export expression: "@adeMODFLOWPath@ <modflow.bf" [G0]
			End line
			Start a new line
				Export expression: "Pause" [G0]
			End line
		End file
	Else
		# batch file to run MOC3D
		Redirect output to: MOC3D.BAT
			Start a new line
				Export expression: "@adeMOC3DPath@" [G0]
			End line
			Start a new line
				Export expression: "Pause" [G0]
			End line
		End file
	End if
	# 
	If: RunMODFLOW
		If: !RunMOC3D
			# Execute external code: MODFLOW_GetDirectory() + "Modflw96.exe"
			# Execute external code: "\Modflw96.3_1\bin\Modflw96.exe"
			Execute external code: "MODFLOW.BAT"
		Else
			Execute external code: "MOC3D.BAT"
		End if
	End if
End if
Evaluate expression: MODFLOW_L_FreeAllLists()
Evaluate expression: MODFLOW_BL_FreeAllBlockLists()
Evaluate expression: MODFLOW_ProgressBarSaveToFile("ErrMessage.txt")
Evaluate expression: MODFLOW_ProgressBarFree()

