# 
# modflow.met
# Template modified from:
# MODFLOW/MOC3D Export Template Version 3.0
# Modified by Richard Winston 3/8/99
# 
# Remove all files from ReadFileValues PIE.
Evaluate expression: MODFLOW_RF_Clear_Files()
# 
# The following "pie command" command causes the MODFLOW PIE to replace the line
# containing the name of a file with the contents of that file when the template
# is run by the PIE.
#
# 
# MF_DefineVariables.met
# --------------------------
# Define Variables
# --------------------------
# 
# Variables used in more than one package
Define Variable: NumUnits [Integer]
Define Variable: PIEVersionOK [Boolean]
Define Variable: PointLayerIsEmpty [Boolean]
Define Variable: LineLayerIsEmpty [Boolean]
Define Variable: AreaLayerIsEmpty [Boolean]
Define Variable: ContinueSimulation [Boolean]
Define Variable: ThisConductance [Real]
Define Variable: AreaBoundaryInBlock [Boolean]
Define Variable: CurrentColumn [Integer]
Define Variable: CurrentRow [Integer]
Define Variable: Dummy [Real]
Define Variable: LayIndex [Integer]
Define Variable: DivIndex [Integer]
Define Variable: PeriodIndex [Integer]
Define Variable: StepIndex [Integer]
Define Variable: ConcentrationList [Integer]
Define Variable: TopElevationList [Integer]
Define Variable: BottomElevationList [Integer]
Define Variable: ThicknessList [Integer]
Define Variable: KzList [Integer]
Define Variable: CellThickness [Real]
Define Variable: LayerThickness [Real]
Define Variable: LayerTop [Real]
Define Variable: LayerBottom [Real]
Define Variable: ThisElevation [Real]
Define Variable: ProgressMax [Integer]
# Define error flags
Define Variable: err_geo [Integer]
# Define root filename for MODFLOW files:
Define Variable: FileName [String]
# Define flag for writing file of cell-by-cell flows (0 = separate files, 1 = single file);
Define Variable: OneCBCFile [Integer]
# Define total number of model layers
Define Variable: NumLay [Integer]
# Define number of geologic units in simulation
Define Variable: NumGeo [Integer]
Define Variable: TopSimul [Integer]
Define Variable: BotSimul [Integer]
# Define dummy variables for looping and checking
Define Variable: i [Integer]
Define Variable: j [Integer]
Define Variable: k [Integer]
Define Variable: n [Integer]
Define Variable: ocflag [Integer]
Define Variable: M [Integer]
Define Variable: TempValue1 [Real]
Define Variable: TempValue2 [Real]
Define Variable: TempValue3 [Real]
Define Variable: TempValue4 [Real]
Define Variable: WD [Real]
Define Variable: WT [Real]
Define Variable: WB [Real]
Define Variable: TML [Real]
Define Variable: BML [Real]
Define Variable: SegmentLength [Real]
Define Variable: ContourArea [Real]
Define Variable: L [Integer]
Define Variable: Lay_Flag [Integer]
Define Variable: Block_Num [Integer]
Define Variable: Block_Flag [Integer]
Define Variable: ok [Integer]
Define Variable: Test [Real]
Define Variable: err_point [Integer]
Define Variable: err_line [Integer]
Define Variable: err_area1 [Integer]
Define Variable: err_area2 [Integer]
Define Variable: DumRow [Integer]
Define Variable: DumCol [Integer]
Define Variable: DumLay [Integer]
# 
# 
# Variables used only outside of packages
Define Variable: LineCount [Integer]
Define Variable: UseCalibration [Boolean]
Define Variable: ShowWarnings [Boolean]
Define Variable: CalcElev [Boolean]
Define Variable: RunMODFLOW [Integer]
# 
# Basic package variables
# Define heading for export
Define Variable: Heading1 [String]
Define Variable: Heading2 [String]
# define export choice variable
Define Variable: ExportBAS [Integer]
# Define ITMUNI, IAPART & ISTRT
Define Variable: ITMUNI [Integer]
Define Variable: IAPART [Integer]
Define Variable: ISTRT [Integer]
# Define variable OPTION (FREE=none, FREE CHTOCH=flow between adjacent constant head cells is calculated)
Define Variable: OPTION [String]
Define Variable: CHTOCH [Boolean]
Define Variable: InitialHeadName [String]
Define Variable: InitialHeadChoice [Boolean]
# 
# Variables used in output control option
Define Variable: HeadPrintStyle [Boolean]
Define Variable: DrawdownPrintStyle [Boolean]
Define Variable: HeadPrintFormat [Integer]
Define Variable: DrawdownPrintFormat [Integer]
# define export choice variable
Define Variable: ExportOC [Integer]
# Define HNOFLO
Define Variable: HNOFLO [Real]
# Define flag for output of head into an external file (0 = none, 1 = formatted, 2 = binary):
Define Variable: OutputHead [Integer]
# Define flag for output of drawdown into an external file (0 = none, 1 = formatted, 2 = binary):
Define Variable: OutputDrawdown [Integer]
# Define flag for printing compact budget files (0 = regular, 1 = compact)
Define Variable: CompactBudget [Integer]
Define Variable: OutputBudget [Integer]
# Define flag for frequency of printing head, drawdown and budget information in external files (0 = none, -1 = last timestep of stress period, N = every Nth timestep):
Define Variable: FreqHeadFile [Integer]
Define Variable: FreqDrawdownFile [Integer]
Define Variable: FreqBudgetFile [Integer]
# Define flags for frequency of output in listing file (0 = none, -1 = last timestep of stress period, N = every Nth timestep):
Define Variable: FreqHeadList [Integer]
Define Variable: FreqDrawdownList [Integer]
Define Variable: FreqBudgetList [Integer]
Define Variable: FreqHeadFileChoice [Integer]
Define Variable: FreqDrawdownFileChoice [Integer]
Define Variable: FreqBudFileChoice [Integer]
Define Variable: FreqHeadListChoice [Integer]
Define Variable: FreqDrawdownListChoice [Integer]
Define Variable: FreqBudListChoice [Integer]
# 
# 
# 
# BCF Variables
Define Variable: TempThickListStart [Integer]
Define Variable: TempThickIndex [Integer]
Define Variable: TempKzListStart [Integer]
Define Variable: TempKzListIndex [Integer]
Define Variable: ResultList [Integer]
# define export choice variable
Define Variable: ExportBCF [Integer]
# Define error flags
Define Variable: err_bcf_1 [Integer]
# Define ISS (0=transient, 1=steady-state)
Define Variable: ISS [Integer]
# Define variables and flags for rewetting package (HDRY, IWDFLG, WETFCT, IWETIT, IHDWET)
Define Variable: HDRY [Real]
Define Variable: IWDFLG [Integer]
Define Variable: WETFCT [Real]
Define Variable: IWETIT [Integer]
Define Variable: IHDWET [Integer]
# Define flag for writing cell-by-cell flow from each stress package (0 = do not write, 1 = write)
Define Variable: IBCFCB [Integer]
# 
# Well Package Variables
Define Variable: CurrentWellCount [Integer]
Define Variable: MaxWells [Integer]
Define Variable: CurrentRiverCount [Integer]
Define Variable: MaxRivers [Integer]
# define export choice variable
Define Variable: ExportWEL [Integer]
# Define error flags
Define Variable: err_wel_1 [Integer]
Define Variable: err_wel_2 [Integer]
# Define flags for stress packages (0 = package is NOT executed, 1 = package is executed):
Define Variable: WellChoice [Integer]
# Define flags for steady or transient stresses (0=steady, 1=transient)
Define Variable: SteadyWell [Integer]
# Define flag for writing cell-by-cell flow from each stress package (0 = do not write, 1 = write)
Define Variable: IWELCB [Integer]
Define Variable: WEL_MXWELL [Integer]
# 
# Drain Package Variables
Define Variable: CurrentDrainCount [Integer]
Define Variable: MaxDrains [Integer]
# define export choice variable
Define Variable: ExportDRN [Integer]
# Define error flags
Define Variable: err_drn_1 [Integer]
Define Variable: err_drn_2 [Integer]
Define Variable: err_drn_3 [Integer]
Define Variable: err_drn_4 [Integer]
# Define flags for stress packages (0 = package is NOT executed, 1 = package is executed):
Define Variable: DrainChoice [Integer]
# Define flags for steady or transient stresses (0=steady, 1=transient)
Define Variable: SteadyDrain [Integer]
# Define flag for writing cell-by-cell flow from each stress package (0 = do not write, 1 = write)
Define Variable: IDRNCB [Integer]
Define Variable: DRN_MXDRN [Integer]
# 
# GHB Variables
Define Variable: CurrentGHBCount [Integer]
Define Variable: MaxGHBs [Integer]
# define export choice variable
Define Variable: ExportGHB [Integer]
# Define error flags
Define Variable: err_ghb_1 [Integer]
Define Variable: err_ghb_2 [Integer]
# Define flags for stress packages (0 = package is NOT executed, 1 = package is executed):
Define Variable: GeneralHeadChoice [Integer]
# Define flags for steady or transient stresses (0=steady, 1=transient)
Define Variable: SteadyGHB [Integer]
# Define flag for writing cell-by-cell flow from each stress package (0 = do not write, 1 = write)
Define Variable: IGHBCB [Integer]
Define Variable: GHB_MXBND [Integer]
# 
# River package variables
# define export choice variable
Define Variable: ExportRIV [Integer]
# Define error flags
Define Variable: err_riv_1 [Integer]
Define Variable: err_riv_2 [Integer]
Define Variable: err_riv_3 [Integer]
Define Variable: err_riv_4 [Integer]
# Define flags for stress packages (0 = package is NOT executed, 1 = package is executed):
Define Variable: RiverChoice [Integer]
# Define flags for steady or transient stresses (0=steady, 1=transient)
Define Variable: SteadyRiver [Integer]
# Define flag for writing cell-by-cell flow from each stress package (0 = do not write, 1 = write)
Define Variable: IRIVCB [Integer]
Define Variable: RIV_MXRIVR [Integer]
# 
# Recharge package variables
# define export choice variable
Define Variable: ExportRCH [Integer]
# Define error flags
Define Variable: err_rch_1 [Integer]
# Define flags for stress packages (0 = package is NOT executed, 1 = package is executed):
Define Variable: RechargeChoice [Integer]
# Define flags for steady or transient stresses (0=steady, 1=transient)
Define Variable: SteadyRecharge [Integer]
# Define recharge option (NRCHOP=1 recharge only to the top grid layer, =2 vertical distribution of recharge specified from recharge elevation, =3 recharge applied to highest active cell in vertical dimension)
# (Assume recharge elevation is constant for entire simulation)
Define Variable: NRCHOP [Integer]
# Define flag for writing cell-by-cell flow from each stress package (0 = do not write, 1 = write)
Define Variable: IRCHCB [Integer]
Define Variable: RechargeTest [Boolean]
# 
# Evapotranspiration package variables
# define export choice variable
Define Variable: ExportEVT [Integer]
# Define error flags
Define Variable: err_evt_1 [Integer]
# Define flags for stress packages (0 = package is NOT executed, 1 = package is executed):
Define Variable: EvapotranspirationChoice [Integer]
# Define flags for steady or transient stresses (0=steady, 1=transient)
Define Variable: SteadyEVT [Integer]
# Define evapotranspiration option (NEVTOP=1 ET calculated only at top grid layer, =2 vertical distribution of ET specified from ET surface)
# (Assume ET surface and ET extinction depth are constant for entire simulation)
Define Variable: NEVTOP [Integer]
# Define flag for writing cell-by-cell flow from each stress package (0 = do not write, 1 = write)
Define Variable: IEVTCB [Integer]
# 
# Stream package variables
Define Variable: StreamChoice [Boolean]
Define Variable: ExportStreams [Boolean]
Define Variable: ElevationAboveTopError [Boolean]
Define Variable: ElevationBelowBottomError [Boolean]
Define Variable: TributaryMaxAllowed [Integer]
Define Variable: SegmentIndex [Integer]
Define Variable: TempInteger [Integer]
Define Variable: StreamSegmentCount [Integer]
Define Variable: StreamSegmentList [Integer]
Define Variable: SortedStreamSegmentList [Integer]
Define Variable: StreamUnitList [Integer]
Define Variable: StreamTributaryList [Integer]
Define Variable: StreamIndex [Integer]
Define Variable: StreamIndex2 [Real]
Define Variable: Tributary2DArray [Integer]
Define Variable: TributaryIndex [Integer]
Define Variable: TributaryCount [Integer]
Define Variable: not_ok [Boolean]
Define Variable: StreamsSteady [Boolean]
Define Variable: StreamTop [Real]
Define Variable: DownstreamStreamTop [Real]
Define Variable: StreamBottom [Real]
Define Variable: DownstreamStreamBottom [Real]
Define Variable: StreamStage [Real]
Define Variable: DownstreamStreamStage [Real]
Define Variable: StreamConductance [Real]
Define Variable: Width [Real]
Define Variable: DownstreamWidth [Real]
Define Variable: ICALC [Integer]
Define Variable: UseTributaries [Boolean]
Define Variable: UseDiversions [Boolean]
Define Variable: StreamProperties3DArray [Integer]
Define Variable: CurrentStream [Integer]
Define Variable: BlockIndex [Integer]
Define Variable: BlockListCount [Integer]
Define Variable: BlockTop [Real]
Define Variable: BlockBottom [Real]
Define Variable: StreamUnit [Integer]
Define Variable: CurrentStreamReachCount [Integer]
Define Variable: MaxStreamReachCount [Integer]
Define Variable: ISTCB1 [Integer]
Define Variable: ISTCB2 [Integer]
Define Variable: NTRIB [Integer]
Define Variable: NTRIBCurrent [Integer]
Define Variable: NDIV [Integer]
Define Variable: Flow [Real]
# ModelLengthUnits = 0 -> m
# ModelLengthUnits = 1 -> ft
Define Variable: ModelLengthUnits [Integer]
Define Variable: StreamCONST [Real]
Define Variable: FlowIndex [Integer]
Define Variable: UpstreamStageIndex [Integer]
Define Variable: DownstreamStageIndex [Integer]
Define Variable: ConductivityIndex [Integer]
Define Variable: UpstreamTopElevIndex [Integer]
Define Variable: DownstreamTopElevIndex [Integer]
Define Variable: UpstreamBotElevIndex [Integer]
Define Variable: DownstreamBotElevIndex [Integer]
Define Variable: UpstreamWidthIndex [Integer]
Define Variable: DownstreamWidthIndex [Integer]
Define Variable: SlopeIndex [Integer]
Define Variable: RoughnessIndex [Integer]
Define Variable: InterpolateStage [Integer]
Define Variable: InterpolateTopElev [Integer]
Define Variable: InterpolateBottomElev [Integer]
Define Variable: InterpolateWidth [Integer]
# 
# Flow and Head variables
Define Variable: FlowHeadChoice [Boolean]
Define Variable: ExportFHB [Boolean]
Define Variable: FlowBoundaryCount [Integer]
Define Variable: HeadBoundaryCount [Integer]
Define Variable: ContourIndex [Integer]
Define Variable: FLWRAT [Real]
Define Variable: SBHED [Real]
Define Variable: EndSBHED [Real]
Define Variable: LineFraction [Real]
Define Variable: NBDTIM [Integer]
Define Variable: IFHBSS [Integer]
Define Variable: IFHBCB [Integer]
Define Variable: IFHBUN [Integer]
Define Variable: TopUnitElev [Real]
Define Variable: BottomUnitElev [Real]
Define Variable: TopContourElev [Real]
Define Variable: BottomContourElev [Real]
Define Variable: TopLayer [Integer]
Define Variable: BottomLayer [Integer]
Define Variable: TopDivElev [Real]
Define Variable: BottomDivElev [Real]
Define Variable: DivThickness [Real]
Define Variable: UnitThickness [Real]
Define Variable: ContourThickness [Real]
Define Variable: TopContourInDiv [Real]
Define Variable: BottomContourInDiv [Real]
Define Variable: ThicknessContourInDiv [Real]
# 
# HFB Variables
Define Variable: HFBChoice [Boolean]
Define Variable: ExportHFB [Boolean]
Define Variable: BarrierIndex [Integer]
Define Variable: CellIndex [Integer]
Define Variable: ColumnCount [Integer]
Define Variable: RowCount [Integer]
Define Variable: Row1 [Integer]
Define Variable: Row2 [Integer]
Define Variable: Column1 [Integer]
Define Variable: Column2 [Integer]
Define Variable: CurrentBarrierCount [Integer]
Define Variable: TotalBarrierCount [Integer]
Define Variable: HYDCHR [Real]
Define Variable: AverageCellThickness [Real]
# 
# Solver Variables
# define export choice variable
Define Variable: ExportSOL [Integer]
# Define flag for matrix solver: (0 = SOR, 1 = SIP, 2 = PCG, 3 = DE4)
Define Variable: SolverChoice [Integer]
# Define variables for SOR solver (SolverChoice=3)
# MXITER: Maximum number of outer iterations
Define Variable: SOR_MXITER [Integer]
# ACCL: Acceleration parameter
Define Variable: SOR_ACCL [Real]
# HCLOSE: Maximum absolute change in head used to check convergence.
Define Variable: SOR_HCLOSE [Real]
# IPRSOR: Printout interval for SOR.
Define Variable: SOR_IPRSOR [Integer]
# 
# Define variables for SIP solver (SolverChoice=0)
# MXITER: Maximum number of outer iterations
Define Variable: SIP_MXITER [Integer]
# NPARM: Number of iteration parameters
Define Variable: SIP_NPARM [Integer]
# ACCL: Acceleration parameter
Define Variable: SIP_ACCL [Real]
# HCLOSE: Maximum absolute change in head used to check convergence.
Define Variable: SIP_HCLOSE [Real]
# IPCALC: Flag to indicate seed for calculating iteration parameters (0=seed entered by user, 1=seed calculated at start of simulation)
Define Variable: SIP_IPCALC [Integer]
# WSEED: Seed for calculating iteration paramters
Define Variable: SIP_WSEED [Real]
# IPRSIP: Printout interval for SIP.
Define Variable: SIP_IPRSIP [Integer]
# 
# Define variable for PCG solver (SolverChoice=2)
# MXITER: Maximum number of outer iterations
Define Variable: PCG_MXITER [Integer]
# ITER1: Maximum number of inner iterations
Define Variable: PCG_ITER1 [Integer]
# NPCOND: Flag used to select matrix preconditioning method: 1=Modified incomplete Cholesky, 2=Polynomial
Define Variable: PCG_NPCOND [Real]
# HCLOSE: Maximum absolute change in head used to check convergence.
Define Variable: PCG_HCLOSE [Real]
# RCLOSE: Maximum absolute change in residual used to check convergence.
Define Variable: PCG_RCLOSE [Real]
# RELAX: Relation parameter used with NPCOND=1
Define Variable: PCG_RELAX [Real]
# NBPOL: Flag used when NPCOND=2 to indicate whether the estimate of the upper bound of the max eignevalue is 2, or will be calculated. NBPOL=2 specifies max eigenvalue as 2, NBPOL!=2 calculates estimate. (Not used for NBPOL!=2)
Define Variable: PCG_NBPOL [Integer]
# IPRPCG: Printout interval for PCG
Define Variable: PCG_IPRPCG [Integer]
# MUTPCG: Flag to control printing from solver, MUTPCG=0 print solver information, MUTPCG=1 only print iteration, MUTPCG=2 suppresses all printing.
Define Variable: PCG_MUTPCG [Integer]
# IPCGCD: Flag used for NPCOND=1 to control whether same Cholesky decomposition is used for multiple calls to PCG.
Define Variable: PCG_DAMP [Real]
# 
# Define variables for DE4 solver (SolverChoice=1)
# ITMX: maximum number of iterations
Define Variable: DE4_ITMX [Integer]
# MXUP: maximum number of equations in upper part
Define Variable: DE4_MXUP [Integer]
# MXLOW: maximum number of equations in lower part
Define Variable: DE4_MXLOW [Integer]
# MXBW: maximum bandwidth
Define Variable: DE4_MXBW [Integer]
# IFREQ: flag indicating frequency of change in coefficient matrix (1=flow equations are linear, 2=flow equations are linear but coefficients of simulated head may change at the beginning of stress period, 3=nonlinear flow equations)
Define Variable: DE4_IFREQ [Integer]
# MUTD4: Flag indicating printing at convergence (0=number of iterations printed & maximum head change, 1=number of iterations printed, 2=no information printed)
Define Variable: DE4_MUTD4 [Integer]
# ACCL: acceleration parameter
Define Variable: DE4_ACCL [Real]
# HCLOSE: convergence criteria for head
Define Variable: DE4_HCLOSE [Real]
# IPRD4: time step interval when printing out convergence information
Define Variable: DE4_IPRD4 [Integer]
# 
# MODPATH Variables
Define Variable: MODFLOWLayer [Integer]
Define Variable: MODPATHChoice [Boolean]
Define Variable: RechargeITOP [Integer]
Define Variable: EvapITOP [Integer]
# 
# MOC3D variables
Define Variable: PrintMOC3DLocations [Boolean]
Define Variable: RunMoc3d [Integer]
# Define error flags
Define Variable: err_moc_1 [Integer]
Define Variable: ExportTRANS [Integer]
Define Variable: ExportOBS [Integer]
Define Variable: TransportFlag [Integer]
Define Variable: Transport [Integer]
Define Variable: MOC_ISLAY1 [Integer]
Define Variable: MOC_ISLAY2 [Integer]
Define Variable: FirstMoc3DUnit [Integer]
Define Variable: LastMoc3DUnit [Integer]
Define Variable: MOC_ISROW1 [Integer]
Define Variable: MOC_ISROW2 [Integer]
Define Variable: MOC_ISCOL1 [Integer]
Define Variable: MOC_ISCOL2 [Integer]
Define Variable: MOC_NODISP [Integer]
Define Variable: MOC_DECAY [Real]
Define Variable: MOC_DIFFUS [Real]
Define Variable: MOC_INTRPL [Integer]
Define Variable: MOC_CNOFLO [Real]
Define Variable: MOC_INCRCH [Integer]
Define Variable: MOC_IOBSFL [Integer]
# 
Define Variable: MOC_NPMAX [Integer]
Define Variable: MOC_CELDIS [Real]
Define Variable: MOC_FZERO [Real]
Define Variable: MOC_NPCUST [Integer]
Define Variable: MOC_NPTPND [Integer]
Define Variable: MOC_NPTPNDError [Boolean]
# 
Define Variable: MOC_CNC_OPT [Integer]
Define Variable: MOC_NPNTCL [Integer]
Define Variable: MOC_NPNTCLN [Integer]
Define Variable: MOC_VEL_OPT [Integer]
Define Variable: MOC_NPNTVL [Integer]
Define Variable: MOC_NPNTVLN [Integer]
Define Variable: MOC_NPNTDL [Integer]
Define Variable: MOC_NPNTDLN [Integer]
Define Variable: MOC_PRT_OPT [Integer]
Define Variable: MOC_NPNTPL [Integer]
Define Variable: MOC_NPNTPLN [Integer]
Define Variable: MOC_NSLAY [Integer]
Define Variable: MOC_CINFLBefore [Real]
Define Variable: MOC_CINFLAfter [Real]
Define Variable: RowHeightList [Integer]
Define Variable: ColumnWidthList [Integer]
Define Variable: RowIndex [Integer]
Define Variable: ColumnIndex [Integer]
Define Variable: MinRow [Real]
Define Variable: MaxRow [Real]
Define Variable: MinColumn [Real]
Define Variable: MaxColumn [Real]
Define Variable: FirstRowHeight [Real]
Define Variable: FirstColumnWidth [Real]
Define Variable: CurrentRowHeight [Real]
Define Variable: CurrentColumnWidth [Real]
Define Variable: ObservationIndex [Integer]
# 
Define Variable: Dimensions [Integer]
# MOCIMP
Define Variable: MOC_EPSSLV [Real]
Define Variable: MOC_FDTMTH [Real]
Define Variable: MOC_IDIREC [Integer]
Define Variable: MOC_MAXIT [Integer]
Define Variable: MOC_NCXIT [Integer]
# 
Define Variable: MOC_NUMOBS [Integer]
Define Variable: NColsSub [Integer]
Define Variable: NRowsSub [Integer]
Define Variable: NLaySub [Integer]
Define Variable: FirstLay [Integer]
Define Variable: LastLay [Integer]
# MOC3D Age package variables
Define Variable: AgeChoice [Boolean]
Define Variable: AGER8 [Real]
# MOC3D Dual Porosity package variables
Define Variable: DualPorosityChoice [Boolean]
Define Variable: IDPFO [Boolean]
Define Variable: IDPZO [Boolean]
Define Variable: IDPTIM [Boolean]
Define Variable: IDPPS [Integer]
# MOC3D Simple Reaction package variables
Define Variable: SimpleReactionChoice [Boolean]
Define Variable: IDKRF [Boolean]
Define Variable: IDKTIM [Boolean]
Define Variable: IDKFO [Boolean]
Define Variable: IDKFS [Boolean]
Define Variable: IDKZO [Boolean]
Define Variable: IDKZS [Boolean]
# 
# begin modification
Define Variable: ListIndex [Integer]
# 
# Lake Variables
Define Variable: UnitTop [Real]
Define Variable: UnitBottom [Real]
Define Variable: LakebedTop [Real]
Define Variable: LakebedBottom [Real]
Define Variable: LocalKz [Real]
Define Variable: CrossSectionalArea [Real]
Define Variable: LocalBottom [Real]
Define Variable: FoundLakeCell [Boolean]
Define Variable: FoundLakeBottomCell3DList [Real]
Define Variable: MasterLakeList [Integer]
Define Variable: MasterLakeListSize [Integer]
Define Variable: LakeColumnListsStart [Integer]
Define Variable: LakeRowListsStart [Integer]
Define Variable: LakeLayerListStart [Integer]
Define Variable: LakeNodeTypeListStart [Integer]
Define Variable: LakeTopElevListStart [Integer]
Define Variable: LakeBotElevListStart [Integer]
Define Variable: LakeAreaListStart [Integer]
Define Variable: LakeHydCondListStart [Integer]
Define Variable: LakeNumber [Integer]
Define Variable: LakeIndex [Integer]
Define Variable: MaxInflowSegments [Integer]
Define Variable: MaxOutflowSegments [Integer]
Define Variable: NSTRIN [Integer]
Define Variable: NSTROUT [Integer]
Define Variable: NRATEQ [Integer]
Define Variable: NODES [Integer]
Define Variable: NLAKES [Integer]
Define Variable: MaxRateEq [Integer]
Define Variable: RateEqIndex [Integer]
Define Variable: NSUBSTEPS [Integer]
Define Variable: ILKCBC [Integer]
Define Variable: ILKOUT [Integer]
Define Variable: SteadyLake [Integer]
Define Variable: LakeChoice [Boolean]
Define Variable: LakeBotCondChoice [Integer]
Define Variable: LakeSideCondChoice [Integer]
# Index1, Column
# Index2, Row
# Index3, 1=top, 2=bottom
Define Variable: LakeElevations3DList [Integer]
Define Variable: ExportLAK [Boolean]
# 
# Seepage Variables
Define Variable: SeepageChoice [Boolean]
Define Variable: ExportSPG [Boolean]
Define Variable: SteadySeepage [Boolean]
Define Variable: MaxSeepages [Integer]
Define Variable: CurrentSeepageCount [Integer]
Define Variable: err_spg_3 [Integer]
Define Variable: err_spg_4 [Integer]
Define Variable: ISPGCB [Integer]
# 
# MT3D Variables
Define Variable: MT3D_FlowFile [Boolean]


# end modification
# 
# MF_SetVariables.met
# --------------------------
# Set Variables
# --------------------------
# Variables used in more than one package
Set Variable: ProgressMax:= 1
Set Variable: ContinueSimulation:= 1
# Initialize Error flags
Set Variable: err_geo:= 0
Set Variable: FileName:= "brook"
Set Variable: OneCBCFile:= 0
Set Variable: NumLay:= 0
Set Variable: NumUnits:= 0
Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
	Set Variable: NumLay:= NumLay+MODFLOW_SIMUL(LayIndex)*MODFLOW_NDIV(LayIndex)
	If: MODFLOW_SIMUL(LayIndex)
		Set Variable: NumUnits:= NumUnits + 1
	End if
End loop
If: NumLay>1
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NLAY()
End if
Set Variable: NumGeo:= 0
Set Variable: TopSimul:= 0
Set Variable: BotSimul:= 0
# 
Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
	If: MODFLOW_SIMUL(LayIndex)!=0&TopSimul=0
		Set Variable: TopSimul:= LayIndex
	End if
End loop
# 
Loop for: Variable LayIndex from: MODFLOW_NLAY() to: 1 step: -1
	If: MODFLOW_SIMUL(LayIndex)!=0&BotSimul=0
		Set Variable: BotSimul:= LayIndex
	End if
End loop
Set Variable: NumGeo:= BotSimul-TopSimul+1
# 
# Variables used only outside of packages
Set Variable: UseCalibration:= 0
Set Variable: ShowWarnings:= 1
Set Variable: RunMODFLOW:= 1
# 
# Basic package variables
# Set variables for exporting packages (0 prohibits export of package, != 0 enables export of package)
Set Variable: ExportBAS:= 1
Set Variable: Heading1:= "Project title"
Set Variable: Heading2:= ""
Set Variable: ITMUNI:= 1
Set Variable: IAPART:= 0
Set Variable: ISTRT:= 1
Set Variable: HNOFLO:= 999999.000000
Set Variable: OPTION:= "FREE"
Set Variable: CHTOCH:= 1
If: CHTOCH
	Set Variable: OPTION:= OPTION + ", CHTOCH"
End if
If: ExportBAS!=0
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NLAY() * 2 + MODFLOW_NPER()
End if
Set Variable: InitialHeadName:= ""
Set Variable: InitialHeadChoice:= 0
# 
# Variables used in output control option
# Set variables for exporting packages (0 prohibits export of package, != 0 enables export of package)
Set Variable: ExportOC:= 1
Set Variable: HeadPrintStyle:= 0
Set Variable: DrawdownPrintStyle:= 0
Set Variable: HeadPrintFormat:= 11 + 1
Set Variable: DrawdownPrintFormat:= 11 + 1
Set Variable: OutputHead:= 1
Set Variable: OutputDrawdown:= 1
Set Variable: CompactBudget:= 0
Set Variable: FreqHeadFileChoice:= 1
If: FreqHeadFileChoice=0
	Set Variable: FreqHeadFile:= 0
Else
	If: FreqHeadFileChoice=1
		Set Variable: FreqHeadFile:= 1
	Else
		Set Variable: FreqHeadFile:= -1
	End if
End if
Set Variable: FreqDrawdownFileChoice:= 1
If: FreqDrawdownFileChoice=0
	Set Variable: FreqDrawdownFile:= 0
Else
	If: FreqDrawdownFileChoice=1
		Set Variable: FreqDrawdownFile:= 1
	Else
		Set Variable: FreqDrawdownFile:= -1
	End if
End if
Set Variable: FreqBudFileChoice:= 2
If: FreqBudFileChoice=0
	Set Variable: FreqBudgetFile:= 0
Else
	If: FreqBudFileChoice=1
		Set Variable: FreqBudgetFile:= 1
	Else
		Set Variable: FreqBudgetFile:= -1
	End if
End if
Set Variable: FreqHeadListChoice:= 1
If: FreqHeadListChoice=0
	Set Variable: FreqHeadList:= 0
Else
	If: FreqHeadListChoice=1
		Set Variable: FreqHeadList:= 1
	Else
		Set Variable: FreqHeadList:= -1
	End if
End if
Set Variable: FreqDrawdownListChoice:= 1
If: FreqDrawdownListChoice=0
	Set Variable: FreqDrawdownList:= 0
Else
	If: FreqDrawdownListChoice=1
		Set Variable: FreqDrawdownList:= 1
	Else
		Set Variable: FreqDrawdownList:= -1
	End if
End if
Set Variable: FreqBudListChoice:= 2
If: FreqBudListChoice=0
	Set Variable: FreqBudgetList:= 0
Else
	If: FreqBudListChoice=1
		Set Variable: FreqBudgetList:= 1
	Else
		Set Variable: FreqBudgetList:= -1
	End if
End if
If: ExportOC!=0
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER()
End if
# 
# BCF Variables
# Set variables for exporting packages (0 prohibits export of package, != 0 enables export of package)
Set Variable: ExportBCF:= 1
# Initialize Error flags
Set Variable: err_bcf_1:= 0
Set Variable: ISS:= 1
Set Variable: HDRY:= -999999.000000
Set Variable: IWDFLG:= 0
Set Variable: WETFCT:= 0.500000
Set Variable: IWETIT:= 1
Set Variable: IHDWET:= 1
Set Variable: IBCFCB:= 1
If: ExportBCF!=0
	Set Variable: ProgressMax:= ProgressMax + 3 * MODFLOW_NLAY()
End if
# 
# 
# Well Package Variables
# Set variables for exporting packages (0 prohibits export of package, != 0 enables export of package)
Set Variable: ExportWEL:= 1
# Initialize Error flags
Set Variable: err_wel_1:= 0
Set Variable: err_wel_2:= 0
# Set variables for choice of stress packages and output control:
Set Variable: WellChoice:= 1&0
Set Variable: SteadyWell:= 0
Set Variable: IWELCB:= 1
If: WellChoice!=0&ExportWEL!=0
	Set Variable: ProgressMax:= ProgressMax + NumUnits*NumBlocks()
End if
# 
# Drain Package Variables
# Set variables for exporting packages (0 prohibits export of package, != 0 enables export of package)
Set Variable: ExportDRN:= 1
# Initialize Error flags
Set Variable: err_drn_1:= 0
Set Variable: err_drn_2:= 0
Set Variable: err_drn_3:= 0
Set Variable: err_drn_4:= 0
# Set variables for choice of stress packages and output control:
Set Variable: DrainChoice:= 1&1
Set Variable: SteadyDrain:= 0
Set Variable: IDRNCB:= 1
If: DrainChoice!=0&ExportDRN!=0
	Set Variable: ProgressMax:= ProgressMax + NumUnits*NumBlocks()
End if
# 
# GHB Variables
# Set variables for exporting packages (0 prohibits export of package, != 0 enables export of package)
Set Variable: ExportGHB:= 1
# Initialize Error flags
Set Variable: err_ghb_1:= 0
Set Variable: err_ghb_2:= 0
# Set variables for choice of stress packages and output control:
Set Variable: GeneralHeadChoice:= 0&1
Set Variable: SteadyGHB:= 0
Set Variable: IGHBCB:= 1
If: GeneralHeadChoice!=0&ExportGHB!=0
	Set Variable: ProgressMax:= ProgressMax + NumUnits*NumBlocks()
End if
# 
# River package variables
# Set variables for exporting packages (0 prohibits export of package, != 0 enables export of package)
Set Variable: ExportRIV:= 1
# Initialize Error flags
Set Variable: err_riv_1:= 0
Set Variable: err_riv_2:= 0
Set Variable: err_riv_3:= 0
Set Variable: err_riv_4:= 0
# Set variables for choice of stress packages and output control:
Set Variable: RiverChoice:= 1&1
Set Variable: SteadyRiver:= 0
Set Variable: IRIVCB:= 1
If: RiverChoice!=0&ExportRIV!=0
	Set Variable: ProgressMax:= ProgressMax + NumUnits*NumBlocks()
End if
# 
# Recharge package variables
# Set variables for exporting packages (0 prohibits export of package, != 0 enables export of package)
Set Variable: ExportRCH:= 1
# Initialize Error flags
Set Variable: err_rch_1:= 0
# Set variables for choice of stress packages and output control:
Set Variable: RechargeChoice:= 1&1
Set Variable: SteadyRecharge:= 0
Set Variable: NRCHOP:= 0 + 1
Set Variable: IRCHCB:= 1
If: RechargeChoice!=0&ExportRCH!=0
	Set Variable: ProgressMax:= ProgressMax + 1
	If: NRCHOP=2
		Set Variable: ProgressMax:= ProgressMax + 1
	End if
	If: MODFLOW_NPER()>=2
		Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER() - 1
	End if
End if
# 
# Evapotranspiration package variables
# Set variables for exporting packages (0 prohibits export of package, != 0 enables export of package)
Set Variable: ExportEVT:= 1
# Initialize Error flags
Set Variable: err_evt_1:= 0
# Set variables for choice of stress packages and output control:
Set Variable: EvapotranspirationChoice:= 0&1
Set Variable: SteadyEVT:= 0
Set Variable: NEVTOP:= 0 + 1
Set Variable: IEVTCB:= 1
If: EvapotranspirationChoice!=0&ExportEVT!=0
	Set Variable: ProgressMax:= ProgressMax + 3
	If: NEVTOP=2
		Set Variable: ProgressMax:= ProgressMax + 1
	End if
	If: MODFLOW_NPER()>=2
		Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER() - 1
	End if
End if
# 
# Stream package variables
Set Variable: StreamChoice:= 0&1
Set Variable: ExportStreams:= 1
Set Variable: StreamsSteady:= !0
Set Variable: ICALC:= 0
Set Variable: UseTributaries:= 0
Set Variable: UseDiversions:= 0
Set Variable: StreamSegmentList:= MODFLOW_L_CreateNewList()
Set Variable: SortedStreamSegmentList:= MODFLOW_L_CreateNewList()
Set Variable: StreamTributaryList:= MODFLOW_L_CreateNewList()
Set Variable: TributaryMaxAllowed:= 10
Set Variable: StreamUnitList:= MODFLOW_L_CreateNewList()
Set Variable: ISTCB1:= 1
Set Variable: ISTCB2:= 1
# ModelLengthUnits = 0 -> m
# ModelLengthUnits = 1 -> ft
Set Variable: ModelLengthUnits:= 0
Set Variable: StreamCONST:= 1
If: ICALC&StreamChoice
	If: ITMUNI=0
		Alert: "Error: You must specify the time unit to calculate the stage height in the stream package. Check the Time Tab of the Edit Project Info Dialog box."
	End if
	If: ITMUNI=1
		If: ModelLengthUnits
			Set Variable: StreamCONST:= 1.486
		Else
			Set Variable: StreamCONST:= 1
		End if
	End if
	If: ITMUNI=2
		If: ModelLengthUnits
			Set Variable: StreamCONST:= 89.16
		Else
			Set Variable: StreamCONST:= 60
		End if
	End if
	If: ITMUNI=3
		If: ModelLengthUnits
			Set Variable: StreamCONST:= 5349.6
		Else
			Set Variable: StreamCONST:= 3600
		End if
	End if
	If: ITMUNI=4
		If: ModelLengthUnits
			Set Variable: StreamCONST:= 128390.4
		Else
			Set Variable: StreamCONST:= 86400
		End if
	End if
	If: ITMUNI=5
		If: ModelLengthUnits
			Set Variable: StreamCONST:= 46784593
		Else
			Set Variable: StreamCONST:= 31447600
		End if
	End if
End if
Set Variable: FlowIndex:= 0
Set Variable: UpstreamStageIndex:= 1
Set Variable: DownstreamStageIndex:= 2
Set Variable: ConductivityIndex:= 3
Set Variable: UpstreamTopElevIndex:= 4
Set Variable: DownstreamTopElevIndex:= 5
Set Variable: UpstreamBotElevIndex:= 6
Set Variable: DownstreamBotElevIndex:= 7
Set Variable: UpstreamWidthIndex:= 8
Set Variable: DownstreamWidthIndex:= 9
Set Variable: SlopeIndex:= 10
Set Variable: RoughnessIndex:= 11
Set Variable: InterpolateStage:= 12
Set Variable: InterpolateTopElev:= 13
Set Variable: InterpolateBottomElev:= 14
Set Variable: InterpolateWidth:= 15
If: StreamChoice&ExportStreams
	Set Variable: ProgressMax:= ProgressMax + 2*MODFLOW_NLAY() + MODFLOW_NPER()
	If: ShowWarnings
		Set Variable: ProgressMax:= ProgressMax + 5*MODFLOW_NLAY()
	End if
	If: UseTributaries&ShowWarnings
		Set Variable: ProgressMax:= ProgressMax + 2*MODFLOW_NLAY()
	End if
	If: UseDiversions
		Set Variable: ProgressMax:= ProgressMax + MODFLOW_NLAY()
	End if
	If: UseDiversions&ShowWarnings
		Set Variable: ProgressMax:= ProgressMax + 2*MODFLOW_NLAY()
	End if
	If: (!ICALC)&ShowWarnings
		Set Variable: ProgressMax:= ProgressMax + 2*MODFLOW_NLAY()
	End if
End if
# 
# Flow and Head variables
Set Variable: FlowHeadChoice:= 0&1
Set Variable: ExportFHB:= 1
Set Variable: NBDTIM:= 2
Set Variable: IFHBSS:= 1
Set Variable: IFHBCB:= 1
If: IFHBCB
	If: OneCBCFile=1
		Set Variable: IFHBCB:= 33
	Else
		Set Variable: IFHBCB:= 39
	End if
End if
Set Variable: IFHBUN:= 40
If: FlowHeadChoice&ExportFHB
	Set Variable: ProgressMax:= ProgressMax + 2*MODFLOW_NLAY()
End if
# 
# HFB Variables
Set Variable: HFBChoice:= 0&1
Set Variable: ExportHFB:= 1
Set Variable: ColumnCount:= NumColumns()
Set Variable: RowCount:= NumRows()
If: ExportHFB&HFBChoice
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NLAY()
End if
# 
# Solver Variables
# Set variables for exporting packages (0 prohibits export of package, != 0 enables export of package)
Set Variable: ExportSOL:= 1
Set Variable: SolverChoice:= 2
# 
# Set variables for SOR solver (SolverChoice=3)
Set Variable: SOR_MXITER:= 100
Set Variable: SOR_ACCL:= 1.670000
Set Variable: SOR_HCLOSE:= 0.001000
Set Variable: SOR_IPRSOR:= 999
# 
# Set variables for SIP solver (SolverChoice=0)
Set Variable: SIP_MXITER:= 100
Set Variable: SIP_NPARM:= 5
Set Variable: SIP_ACCL:= 1.000000
Set Variable: SIP_HCLOSE:= 0.001000
Set Variable: SIP_IPCALC:= 1
Set Variable: SIP_WSEED:= 9999.000000
Set Variable: SIP_IPRSIP:= 0
# 
# Set variables for PCG solver (SolverChoice=2)
Set Variable: PCG_MXITER:= 20
Set Variable: PCG_ITER1:= 30
Set Variable: PCG_NPCOND:= 0 +1
Set Variable: PCG_HCLOSE:= 0.001000
Set Variable: PCG_RCLOSE:= 0.001000
Set Variable: PCG_RELAX:= 1.000000
Set Variable: PCG_NBPOL:= 1 + 1
Set Variable: PCG_IPRPCG:= 1
Set Variable: PCG_MUTPCG:= 1
Set Variable: PCG_DAMP:= 1
# 
# Set variables for DE4 solver (SolverChoice=1)
Set Variable: DE4_ITMX:= 5
Set Variable: DE4_MXUP:= 0
Set Variable: DE4_MXLOW:= 0
Set Variable: DE4_MXBW:= 0
Set Variable: DE4_IFREQ:= 2 + 1
Set Variable: DE4_MUTD4:= 0
Set Variable: DE4_ACCL:= 1.000000
Set Variable: DE4_HCLOSE:= 0.001000
Set Variable: DE4_IPRD4:= 1
# 
# MODPATH Variables
Set Variable: MODPATHChoice:= 0
Set Variable: RechargeITOP:= 1
Set Variable: EvapITOP:= 1
# 
# MOC3D variables
Set Variable: PrintMOC3DLocations:= 0
Set Variable: RunMoc3d:= 1
# Initialize Error flags
Set Variable: err_moc_1:= 0
# Set variable for exporting package (0 prohibits export of package, != 0 enables export of package)
Set Variable: ExportTRANS:= 1
Set Variable: ExportOBS:= 1
Set Variable: Transport:= 1
Set Variable: TransportFlag:= Transport
If: Transport
	Set Variable: Transport:= Transport + 0
End if
Set Variable: FirstMoc3DUnit:= 1
Set Variable: LastMoc3DUnit:= -1
If: LastMoc3DUnit= -1
	Set Variable: LastMoc3DUnit:= MODFLOW_NLAY()
End if
Set Variable: MOC_ISLAY1:= 1
Set Variable: MOC_ISLAY2:= 0
Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
	If: MODFLOW_SIMUL(LayIndex)
		If: LayIndex<FirstMoc3DUnit
			Set Variable: MOC_ISLAY1:= MOC_ISLAY1 + MODFLOW_NDIV(LayIndex)
		End if
		If: LayIndex<=LastMoc3DUnit
			Set Variable: MOC_ISLAY2:= MOC_ISLAY2 + MODFLOW_NDIV(LayIndex)
		End if
	End if
End loop
Set Variable: MOC_ISROW1:= MOC_ISROW1()
Set Variable: MOC_ISROW2:= MOC_ISROW2()
Set Variable: MOC_ISCOL1:= MOC_ISCOL1()
Set Variable: MOC_ISCOL2:= MOC_ISCOL2()
Set Variable: MOC_NODISP:= 0
Set Variable: MOC_DECAY:= 0.000000
Set Variable: MOC_DIFFUS:= 0.000000
Set Variable: MOC_INTRPL:= 0 + 1
Set Variable: MOC_CNOFLO:= -999.900000
Set Variable: MOC_INCRCH:= -0
Set Variable: MOC_IOBSFL:= 1
Set Variable: MOC_NPMAX:= 0
Set Variable: MOC_CELDIS:= 0.500000
Set Variable: MOC_FZERO:= 0.050000
Set Variable: MOC_NPCUST:= 0
Set Variable: MOC_NPTPND:= 9
Set Variable: MOC_CNC_OPT:= 1
Set Variable: MOC_NPNTCL:= 3
Set Variable: MOC_NPNTCLN:= 20
Set Variable: MOC_VEL_OPT:= 1
Set Variable: MOC_NPNTVL:= 0
Set Variable: MOC_NPNTVLN:= 0
Set Variable: MOC_NPNTDL:= 2
Set Variable: MOC_NPNTDLN:= 0
Set Variable: MOC_PRT_OPT:= 0
Set Variable: MOC_NPNTPL:= 0
Set Variable: MOC_NPNTPLN:= 0
Set Variable: MOC_NSLAY:= 1
Set Variable: NColsSub:= MOC_ISCOL2-MOC_ISCOL1+1
Set Variable: NRowsSub:= MOC_ISROW2-MOC_ISROW1+1
Set Variable: NLaySub:= MOC_ISLAY2-MOC_ISLAY1+1
Set Variable: MOC_NPTPNDError:= 0
If: RunMoc3d&!MOC_NPCUST
	Set Variable: Dimensions:= 0
	If: NLaySub>1
		Set Variable: Dimensions:= Dimensions + 1
	End if
	If: NRowsSub>1
		Set Variable: Dimensions:= Dimensions + 1
	End if
	If: NColsSub>1
		Set Variable: Dimensions:= Dimensions + 1
	End if
	If: Dimensions=1
		If: !((MOC_NPTPND=1)|(MOC_NPTPND=2)|(MOC_NPTPND=3)|(MOC_NPTPND=4))
			Set Variable: MOC_NPTPNDError:= 1
		End if
	End if
	If: Dimensions=2
		If: !((MOC_NPTPND=1)|(MOC_NPTPND=4)|(MOC_NPTPND=9)|(MOC_NPTPND=16))
			Set Variable: MOC_NPTPNDError:= 1
		End if
	End if
	If: Dimensions=3
		If: !((MOC_NPTPND=1)|(MOC_NPTPND=8)|(MOC_NPTPND=27))
			Set Variable: MOC_NPTPNDError:= 1
		End if
	End if
End if
# MOCIMP
Set Variable: MOC_EPSSLV:= 0.000100
Set Variable: MOC_FDTMTH:= 0.500000
Set Variable: MOC_IDIREC:= 1 + 1
Set Variable: MOC_MAXIT:= 100
Set Variable: MOC_NCXIT:= 2
# MOC3D Age package variables
Set Variable: AgeChoice:= 0
Set Variable: AGER8:= 1
# MOC3D Dual Porosity package variables
Set Variable: DualPorosityChoice:= 0
Set Variable: IDPFO:= 0
Set Variable: IDPZO:= 0
Set Variable: IDPTIM:= 0|0
Set Variable: IDPPS:= 2 + 1
# MOC3D Simple Reaction package variables
Set Variable: SimpleReactionChoice:= 0
Set Variable: IDKRF:= 0
Set Variable: IDKTIM:= 0|0|0|0
Set Variable: IDKFO:= 0
Set Variable: IDKFS:= 0
Set Variable: IDKZO:= 0
Set Variable: IDKZS:= 0
Set Variable: CalcElev:= 0
If: TransportFlag=1
	If: Transport>0
		If: ExportTRANS!=0
			Set Variable: ProgressMax:= ProgressMax + 3 * (LastMoc3DUnit - FirstMoc3DUnit + 1)
			If: RechargeChoice!=0
				Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER()
			End if
			If: ExportOBS!=0
				If: MOC_NUMOBS>0
					Set Variable: ProgressMax:= ProgressMax + LastMoc3DUnit - FirstMoc3DUnit + 1
				End if
			End if
		End if
	End if
End if
# 
# 
# begin modification
# 
# Lake Variables
Set Variable: LakeChoice:= 0
Set Variable: ILKCBC:= 1
If: ILKCBC
	Set Variable: ILKCBC:= 66
End if
Set Variable: ILKOUT:= 0
If: ILKOUT
	Set Variable: ILKOUT:= 67
End if
Set Variable: MaxRateEq:= 1
Set Variable: SteadyLake:= 1
Set Variable: NSUBSTEPS:= 1
Set Variable: LakeBotCondChoice:= 0
Set Variable: LakeSideCondChoice:= 1
Set Variable: ExportLAK:= 1
If: LakeChoice&ExportLAK
	Set Variable: ProgressMax:= ProgressMax + 2*MODFLOW_NLAY()
End if
Set Variable: ExportLAK:= 1
# 
# 
# Seepage Variables
Set Variable: SeepageChoice:= 0&1
Set Variable: ExportSPG:= 1
Set Variable: SteadySeepage:= 1
Set Variable: ISPGCB:= 1
# 
If: SeepageChoice&ExportSPG
	Set Variable: ProgressMax:= ProgressMax + MODFLOW_NPER()
End if
# 
# MT3D Variables
Set Variable: MT3D_FlowFile:= 0
Set Variable: MaxInflowSegments:= 0
Set Variable: MaxOutflowSegments:= 0
# 

# end modification
# 
# MF_SetOutputBudget.met
# 
If: ((IBCFCB=1|(WellChoice=1&IWELCB=1)|(RechargeChoice=1&IRCHCB=1)|(DrainChoice=1&IDRNCB=1)|(RiverChoice=1&IRIVCB=1)|(EvapotranspirationChoice=1&IEVTCB=1)|(GeneralHeadChoice=1&IGHBCB=1)|(StreamChoice=1&ISTCB1=1)|(StreamChoice=1&ISTCB2=1)|(FlowHeadChoice&IFHBCB)))
	Set Variable: OutputBudget:= 1
End if
# 
# 
# begin modification
# 
If: ((LakeChoice&ILKCBC)|(SeepageChoice&ISPGCB))
	Set Variable: OutputBudget:= 1
End if
# 
# 

# 
# 
If: LakeChoice&ExportLAK
	Set Variable: CalcElev:= 1
End if
If: SeepageChoice&ExportSPG
	Set Variable: CalcElev:= 1
End if

# end modification
# 
# MF_SetCalcElev.met
# 
Set Variable: CalcElev:= 0
If: RunMoc3d
	Set Variable: CalcElev:= 1
End if
If: ExportBCF
	Set Variable: CalcElev:= 1
End if
If: ExportRCH&RechargeChoice
	Set Variable: CalcElev:= 1
End if
If: ExportEVT&EvapotranspirationChoice
	Set Variable: CalcElev:= 1
End if
If: ExportRIV&RiverChoice
	Set Variable: CalcElev:= 1
End if
If: ExportDRN&DrainChoice
	Set Variable: CalcElev:= 1
End if
If: ExportStreams&StreamChoice
	Set Variable: CalcElev:= 1
End if
If: ExportHFB&HFBChoice
	Set Variable: CalcElev:= 1
End if
If: CalcElev
	Set Variable: ProgressMax:= ProgressMax + 2*MODFLOW_NLAY()
	If: MODFLOW_NLAY() > 1
		Set Variable: ProgressMax:= ProgressMax + MODFLOW_NLAY()-1
	End if
End if
# 
# MF_InitializeMODFLOW_ProgressBar.met
# 
Set Variable: PIEVersionOK:= MODFLOW_ProgressBarCheckVersion(1, 3, 0, 0)
If: IsNAN(PIEVersionOK)
	Alert: "Error: MODFLOW Progress Bar PIE is not installed!"
Else
	If: !PIEVersionOK
		Alert: "Error: MODFLOW Progress Bar PIE is not up to date! Check that the correct version is installed and that there are not multiple copies of it."
	End if
End if
# Initialize progress bar
Evaluate expression: MODFLOW_ProgressBarInitialize(ProgressMax, 1)
Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error and warning messages")
# 
# Show error message about number of particles per cell for MOC3D
If: MOC_NPTPNDError&ShowWarnings
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Initial number of particles per cell for MOC3D is invalid")
End if
# 
# show error message abut no simulated geologic unts.
If: TopSimul=0&BotSimul=0&ShowWarnings&ContinueSimulation
	Set Variable: err_geo:= 1
	# Alert: "No geologic units are specified for simulation!"
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("No geologic units are specified for simulation!")
End if
# 
# show error messages about non-uniform MOC3D subgrid
If: Transport&TransportFlag&RunMoc3d&ContinueSimulation
	Set Variable: RowHeightList:= MODFLOW_L_CreateNewList()
	Set Variable: ColumnWidthList:= MODFLOW_L_CreateNewList()
	Loop for: Variable RowIndex from: MOC_ISROW1-1 to: MOC_ISROW2-1 step: 1
		Evaluate expression: MODFLOW_L_AddToList(RowHeightList, NthRowHeight(RowIndex))
	End loop
	Loop for: Variable ColumnIndex from: MOC_ISCOL1-1 to: MOC_ISCOL2-1 step: 1
		Evaluate expression: MODFLOW_L_AddToList(ColumnWidthList, NthColumnWidth(ColumnIndex))
	End loop
	If: !MODFLOW_L_IsSingPrecUniform(ColumnWidthList)&ShowWarnings
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: Column widths are not uniform in the MOC3D subgrid.")
	End if
	If: !MODFLOW_L_IsSingPrecUniform(RowHeightList)&ShowWarnings
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: Row heights are not uniform in the MOC3D subgrid.")
	End if
	Evaluate expression: MODFLOW_L_FreeAList(ColumnWidthList)
	Evaluate expression: MODFLOW_L_FreeAList(RowHeightList)
End if
# 
# Show warning message about excessive changes in row and column widths
Set Variable: FirstRowHeight:= NthRowHeight(1)
Set Variable: MinRow:= FirstRowHeight
Set Variable: MaxRow:= FirstRowHeight
Set Variable: FirstColumnWidth:= NthColumnWidth(1)
Set Variable: MinColumn:= FirstRowHeight
Set Variable: MaxColumn:= FirstColumnWidth
Loop for: Rows
	Set Variable: CurrentRowHeight:= NthRowHeight($Row$)
	Set Variable: CurrentRow:= $Row$
	If: CurrentRowHeight>MaxRow
		Set Variable: MaxRow:= CurrentRowHeight
	End if
	If: CurrentRowHeight<MinRow
		Set Variable: MinRow:= CurrentRowHeight
	End if
	If: ShowWarnings&(((CurrentRowHeight / FirstRowHeight)>1.5)|((FirstRowHeight / CurrentRowHeight)>1.5))
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: Ratio of adjacent row heights exceeds the recommended maximum of 1.5 for Rows " +CurrentRow + " and " + (CurrentRow -1))
	End if
	Set Variable: FirstRowHeight:= CurrentRowHeight
End loop
Loop for: Columns
	Set Variable: CurrentColumnWidth:= NthColumnWidth($Column$)
	Set Variable: CurrentColumn:= $Column$
	If: CurrentColumnWidth>MaxColumn
		Set Variable: MaxColumn:= CurrentColumnWidth
	End if
	If: CurrentColumnWidth<MinColumn
		Set Variable: MinColumn:= CurrentColumnWidth
	End if
	If: ShowWarnings&(((CurrentColumnWidth / FirstColumnWidth)>1.5)|((FirstColumnWidth / CurrentColumnWidth)>1.5))
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: Ratio of adjacent column widths exceeds the recommended maximum of 1.5 for Columns " + CurrentColumn + " and " + (CurrentColumn -1))
	End if
	Set Variable: FirstColumnWidth:= CurrentColumnWidth
End loop
# 
# Show warnings about excessive ratios of row and column widths
If: ShowWarnings&ContinueSimulation&((MaxColumn / MinRow)>10)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: the ratio of the column width to row height exceeds the recomended maximum of 10 in some cases.")
End if
If: ShowWarnings&ContinueSimulation&((MaxRow / MinColumn)>10)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: the ratio of the row height to column width exceeds the recomended maximum of 10 in some cases.")
End if
# 
# 
Set Variable: PIEVersionOK:= MODFLOW_L_CheckVersion(1, 8, 0, 0)
If: IsNAN(PIEVersionOK)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: MODFLOW List PIE is not installed!")
Else
	If: !PIEVersionOK
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: MODFLOW List PIE is not up to date! Check that the correct version is installed and that there are not multiple copies of it.")
	End if
End if
Set Variable: PIEVersionOK:= MODFLOW_BL_CheckVersion(1, 3, 0, 0)
If: IsNAN(PIEVersionOK)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: MODFLOW BlockList PIE is not installed!")
Else
	If: !PIEVersionOK
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: MODFLOW BlockList PIE is not up to date! Check that the correct version is installed and that there are not multiple copies of it.")
	End if
End if
Set Variable: PIEVersionOK:= MODFLOW_JF_CheckVersion(1, 5, 0, 0)
If: IsNAN(PIEVersionOK)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: MODFLOW JoinFiles PIE is not installed!")
Else
	If: !PIEVersionOK
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: MODFLOW JoinFiles PIE is not up to date! Check that the correct version is installed and that there are not multiple copies of it.")
	End if
End if
Set Variable: PIEVersionOK:= MODFLOW_RF_CheckVersion(1, 0, 0, 0)
If: IsNAN(PIEVersionOK)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: MODFLOW ReadFileValue PIE is not installed!")
Else
	If: !PIEVersionOK
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: MODFLOW ReadFileValue PIE is not up to date! Check that the correct version is installed and that there are not multiple copies of it.")
	End if
End if
# 
# MF_CacheData.met
# Create lists
Set Variable: ConcentrationList:= MODFLOW_L_CreateNewList()
Set Variable: TopElevationList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), MODFLOW_NLAY())
Set Variable: BottomElevationList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), MODFLOW_NLAY())
Set Variable: ThicknessList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), MODFLOW_NLAY())
Set Variable: KzList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), MODFLOW_NLAY())
# 
# set list items
If: CalcElev&ContinueSimulation
	# Set top elevations
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Evaluating Top Elevations of Unit " + LayIndex)
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation
			Redirect output to: Dummy
				Export matrix: MODFLOW_L_SetOneBased3DListItem(TopElevationList, Column(), Row(), LayIndex, Elev Top Unit[LayIndex]) [G0]
			End file
			Evaluate expression: MODFLOW_Delete_File("Dummy")
		End if
	End loop
	# Set Bottom elevations and layer thicknesses
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Evaluating Bottom Elevations of Unit " + LayIndex)
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation
			Redirect output to: Dummy
				Export matrix: MODFLOW_L_SetOneBased3DListItem(BottomElevationList, Column(), Row(), LayIndex, Elev Bot Unit[LayIndex]) [G0]
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Evaluating Layer Thicknesses of Unit " + LayIndex)
				If: ContinueSimulation
					If: MODFLOW_SIMUL(LayIndex)
						Export matrix: MODFLOW_L_SetOneBased3DListItem(ThicknessList, Column(), Row(), LayIndex, (MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex))/MODFLOW_NDIV(LayIndex)) [G0]
					Else
						Export matrix: MODFLOW_L_SetOneBased3DListItem(ThicknessList, Column(), Row(), LayIndex, (MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex))) [G0]
					End if
				End if
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Testing Layer Thicknesses of Unit " + LayIndex)
				# Check thicknesses
				If: ContinueSimulation&ShowWarnings
					Export matrix: If((MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)<=0)&IBOUND Unit[LayIndex], MODFLOW_ProgressBarAddLine("Negative or zero unit thickness at Unit " + LayIndex + "; Column: " + Column() + "; Row: " + Row()), 0) [G0]
				End if
			End file
			Evaluate expression: MODFLOW_Delete_File("Dummy")
		End if
	End loop
	# check elevations
	If: ShowWarnings&ContinueSimulation
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Checking for elevation errors")
		If: MODFLOW_NLAY() > 1
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY()-1 step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation
					Redirect output to: Dummy
						If: MODFLOW_SpecVcont(LayIndex)
							Export matrix: If(MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)>MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex + 1)&IBOUND Unit[LayIndex]&IBOUND Unit[LayIndex+1], MODFLOW_ProgressBarAddLine("Bottom elevation at Column: " + Column() + "; Row: " + Row() + "; Unit: " + LayIndex + " is less than the top elevation of the unit beneath it."), 0) [G0]
						Else
							Export matrix: If(MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)!=MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex + 1)&IBOUND Unit[LayIndex]&IBOUND Unit[LayIndex+1], MODFLOW_ProgressBarAddLine("Bottom elevation at Column: " + Column() + "; Row: " + Row() + "; Unit: " + LayIndex + " is different from the top elevation of the unit beneath it."), 0) [G0]
						End if
					End file
					Evaluate expression: MODFLOW_Delete_File("Dummy")
				End if
			End loop
		End if
	End if
End if
# store Kz values
If: (NumLay>1)&ContinueSimulation&ExportBCF
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Evaluating Kz")
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation
			Redirect output to: Dummy
				Export matrix: MODFLOW_L_SetOneBased3DListItem(KzList, Column(), Row(), LayIndex, Kz Unit[LayIndex]) [G0]
				If: ShowWarnings
					Export matrix: If(MODFLOW_L_GetFromOneBased3DList(KzList, Column(), Row(), LayIndex)<=0&IBOUND Unit[LayIndex], MODFLOW_ProgressBarAddLine("Negative or zero vertical hydraulic conductivity at Unit " + LayIndex + "; Column: " + Column() + "; Row: " + Row()), 0) [G0]
				End if
			End file
			Evaluate expression: MODFLOW_Delete_File("Dummy")
		End if
	End loop
End if
# pie command: replace_file MF_DefineVariables.met
# begin modification
# pie command: replace_file MF_DefineNewVariables.met
# end modification
# pie command: replace_file MF_SetVariables.met
# begin modification
# pie command: replace_file MF_SetNewVariables.met
# end modification
# pie command: replace_file MF_SetOutputBudget.met
# begin modification
# pie command: replace_file MF_NewSetOutputBudget.met
# pie command: replace_file MF_NewSetCalcElev.met
# end modification
# pie command: replace_file MF_SetCalcElev.met
# pie command: replace_file MF_InitializeProgressBar.met
# pie command: replace_file MF_CheckPIEs.met
# pie command: replace_file MF_CacheData.met
# pie command: stop_replacing_files
# 
# ----------------------------------------------------
# Specification of NameFile so that MODFLOW will run without prompting from screen.
# ----------------------------------------------------
If: ContinueSimulation
	Redirect output to: modflow.bf
		Start a new line
			Export expression: FileName [G0]
		End line
	End file
End if
# 
# 
# The following "pie command" command causes the MODFLOW PIE to replace the line
# containing the name of a file with the contents of that file when the template
# is run by the PIE.
#
# 
# MF_Name.met
# ----------------------------------------------------
# Name file
# ----------------------------------------------------
# Unit Numbers Used
# 10 MODFLOW Listing file
# 11 Basic Package File
# 12 Output Control File
# 13 BCF File
# 14 Recharge File
# 15 River File
# 16 Well File
# 17 Drain File
# 18 GHB File
# 19 EVT File
# 20 SIP File
# 21 SOR File
# 22 binary head file
# 23 formatted head file
# 24 binary drawdown file
# 25 formatted drawdown file
# 27 River budget file
# 28 Recharge budget file
# 29 Well budget file
# 30 Drain budget file
# 31 EVT budget file
# 32 GHB budget file
# 33 budget file
# 34 PCG File
# 35 DE4 File
# 36 Stream budget file 1
# 37 Stream budget file 2
# 38 HFB file
# 39 FHB budget file
# 40 FHB file
# 41 Stream file
# 42 Initial head source file
# 70 MOC3D information file
# begin modification
# 65 Lake File
# 66 Lake cell-by-cell budget file
# 67 Lake stage/budget file
# 68 Seepage file
# 69 Seepage budget file
# 71 MT3D FLO file
# end modification
If: ContinueSimulation
	Redirect output to: brook
		# The NameFile is the list of filenames being used in the MODFLOW simulation. These filenames are for specifying where output is to bewritten and where information is to be read.
		Start a new line
			# File for LISTING results of MODFLOW simulation
			Export expression: "LIST 10 "+FileName+".lst" [G0]
		End line
		Start a new line
			# File for reading BASIC package information
			Export expression: "BAS 11 "+FileName+".bas" [G0]
		End line
		Start a new line
			# File for reading OUTPUT CONTROL information
			Export expression: "OC 12 "+FileName+".oc" [G0]
		End line
		Start a new line
			# File for reading BCF package information
			Export expression: "BCF 13 "+FileName+".bcf" [G0]
		End line
		If: InitialHeadChoice
				Start a new line
					# File for reading initial heads 
					Export expression: "DATA(BINARY) 42 " + InitialHeadName [G0]
				End line
		End if
		# 
		If: WellChoice=1
			Start a new line
				# File for reading WEL package information
				Export expression: "WEL 16 "+FileName+".wel" [G0]
			End line
		End if
		# 
		If: RechargeChoice=1
			Start a new line
				# File for reading RCH package information
				Export expression: "RCH 14 "+FileName+".rch" [G0]
			End line
		End if
		# 
		If: DrainChoice=1
			Start a new line
				# File for reading DRN package information
				Export expression: "DRN 17 "+FileName+".drn" [G0]
			End line
		End if
		# 
		If: RiverChoice=1
			Start a new line
				# File for reading RIV package information
				Export expression: "RIV 15 "+FileName+".riv" [G0]
			End line
		End if
		# 
		If: EvapotranspirationChoice=1
			Start a new line
				# File for reading EVT package information
				Export expression: "EVT 19 "+FileName+".evt" [G0]
			End line
		End if
		# 
		If: GeneralHeadChoice=1
			Start a new line
				# File for reading GHB package information
				Export expression: "GHB 18 "+FileName+".ghb" [G0]
			End line
		End if
		# 
		If: HFBChoice=1
			Start a new line
				# File for reading HFB package information
				Export expression: "HFB 38 "+FileName+".hfb" [G0]
			End line
		End if
		# 
		If: FlowHeadChoice=1
			Start a new line
				# File for reading HFB package information
				Export expression: "FHB 40  "+FileName+".fhb" [G0]
			End line
		End if
		# 
		If: StreamChoice
			Start a new line
				# file for the stream package
				Export expression: "STR 41 " + Filename + ".str" [G0]
			End line
		End if
# begin modification
	If: LakeChoice
		Start a new line
			# file for the lake package
			Export expression: "LAK 65 " + Filename + ".lak" [G0]
		End line
	End if
	If: LakeChoice&ILKOUT
		Start a new line
			# file for the lake stage/budget file
			Export expression: "DATA 67 " + Filename + ".lbd" [G0]
		End line
	End if
	If: SeepageChoice
		Start a new line
			# file for the lake package
			Export expression: "SPG 68 " + Filename + ".spg" [G0]
		End line
	End if

# pie command: replace_file MF_NewName1.met
# pie command: stop_replacing_files
# end modification
		If: SolverChoice=0
			Start a new line
				# File for reading SIP package information
				Export expression: "SIP 20 "+FileName+".sip" [G0]
			End line
		End if
		# 
		If: SolverChoice=3
			Start a new line
				# File for reading SOR package information
				Export expression: "SOR 21 "+FileName+".sor" [G0]
			End line
		End if
		# 
		If: SolverChoice=2
			Start a new line
				# File for reading PCG information:
				Export expression: "PCG 34 "+FileName+".pcg" [G0]
			End line
		End if
		# 
		If: SolverChoice=1
			Start a new line
				# File for reading DE4 information:
				Export expression: "DE4 35 "+FileName+".de4" [G0]
			End line
		End if
		# 
		If: TransportFlag=1
			If: Transport>0
				If: RunMoc3d!=0
					Start a new line
						# File for reading MOC3D information:
						Export expression: "CONC 70 "+FileName+".mcn" [G0]
					End line
				Else
					Start a new line
						# File for reading MOC3D information:
						Export expression: "#CONC 70 "+FileName+".mcn" [G0]
					End line
				End if
			End if
		End if
		# 
		If: OutputHead=1
			Start a new line
				# File for writing heads in text format
				Export expression: "DATA 23 "+FileName+".fhd" [G0]
			End line
		End if
		# 
		If: OutputHead=2
			Start a new line
				# File for writing heads in binary format
				Export expression: "DATA(BINARY) 22 "+FileName+".bhd" [G0]
				Evaluate expression: MODFLOW_Delete_File(FileName+".bhd")
			End line
		End if
		# 
		If: OutputDrawdown=1
			Start a new line
				# File for writing drawdown in text format
				Export expression: "DATA 25 "+FileName+".fdn" [G0]
			End line
		End if
		# 
		If: OutputDrawdown=2
			Start a new line
				# File for writing drawdown in binary format
				Export expression: "DATA(BINARY) 24 "+FileName+".bdn" [G0]
				Evaluate expression: MODFLOW_Delete_File(FileName+".bdn")
			End line
		End if
		# 
		If: (OneCBCFile=1 & (IBCFCB=1|(WellChoice=1&IWELCB=1)|(RechargeChoice=1&IRCHCB=1)|(DrainChoice=1&IDRNCB=1)|(RiverChoice=1&IRIVCB=1)|(EvapotranspirationChoice=1&IEVTCB=1)|(GeneralHeadChoice=1&IGHBCB=1)|(StreamChoice=1&ISTCB1=1)| (FlowHeadChoice&IFHBCB>0)))
			Start a new line
				# File for writing binary cell by cell flows
				Export expression: "DATA(BINARY) 33 "+FileName+".bud" [G0]
				Evaluate expression: MODFLOW_Delete_File(FileName+".bud")
			End line
		Else
			If: IBCFCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 33 "+FileName+".bud" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bud")
				End line
			End if
			If: WellChoice=1&IWELCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 29 "+FileName+".bwe" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bwe")
				End line
			End if
			If: RechargeChoice=1&IRCHCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 28 "+FileName+".brc" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".brc")
				End line
			End if
			If: DrainChoice=1&IDRNCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 30 "+FileName+".bdr" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bdr")
				End line
			End if
			If: RiverChoice=1&IRIVCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 27 "+FileName+".bri" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bri")
				End line
			End if
			If: EvapotranspirationChoice=1&IEVTCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 31 "+FileName+".bev" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bev")
				End line
			End if
			If: GeneralHeadChoice=1&IGHBCB=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 32 "+FileName+".bgh" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bgh")
				End line
			End if
			If: FlowHeadChoice&IFHBCB>0
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) " [G0]
					Export expression: IFHBCB; [G0]
					Export expression: FileName+".bfh" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bfh")
				End line
# begin modification
		If: LakeChoice=1&ILKCBC>0
			Start a new line
				# File for writing binary cell by cell flows
				Export expression: "DATA(BINARY) 66 "+FileName+".blk" [G0]
			End line
		End if
		If: SeepageChoice&ISPGCB
			Start a new line
				# File for writing binary cell by cell flows
				Export expression: "DATA(BINARY) 69 "+FileName+".bsp" [G0]
			End line
		End if

# pie command: replace_file MF_NewName2.met
# pie command: stop_replacing_files
# end modification
			End if
			If: StreamChoice=1&ISTCB1=1
				Start a new line
					# File for writing binary cell by cell flows
					Export expression: "DATA(BINARY) 36 "+FileName+".bs1" [G0]
					Evaluate expression: MODFLOW_Delete_File(FileName+".bs1")
				End line
			End if
		End if
		If: StreamChoice=1&ISTCB2=1
			Start a new line
				# File for writing binary cell by cell flows
				Export expression: "DATA(BINARY) 37 "+FileName+".bs2" [G0]
				Evaluate expression: MODFLOW_Delete_File(FileName+".bs2")
			End line
		End if
# begin modification
			# Export file name and unit number of the MT3D Flow file.
			If: MT3D_FlowFile
				Start a new line
					# RBW - This line exports uses the format for specifying the MT3D flow file used by the free version of MODFLOW at http://www.mindspring.com/~rbwinston/ModDyn.htm
					Export expression: "MT3 71 " + FileName + ".FLO UNFORMATTED" [G0]
				End line
			End if

# pie command: replace_file MF_NewName3.met
# pie command: stop_replacing_files
# end modification
	End file
End if
# 
# 
# MF_MOC_ini.met
# ----------------------
# MOC3D Initialization
# ----------------------
# Calculate layers in subgrid
If: ContinueSimulation
	Set Variable: n:= 1
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		If: LayIndex=FirstMoc3DUnit
			Set Variable: FirstLay:= n
		End if
		If: LayIndex=LastMoc3DUnit
			Set Variable: LastLay:= n+MODFLOW_NDIV(LayIndex)-1
		End if
		Set Variable: n:= n+MODFLOW_NDIV(LayIndex)
	End loop
	# Set the number of columns in the subgrid for looping on matrix export
End if
If: (TransportFlag=1) & (Transport>0) & ContinueSimulation
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Evaluating concentrations at specified head boundaries")
	# MOC3D Concentration associated with constant-head cells calculation
	# Need even if ExportTRANS=0!!
	# Evaluate expression: MODFLOW_MOC_StartZones()
	Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
		# Set Variable: ContinueSimulation:=  MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
			Redirect output to: Dummy
				Export matrix: If(MODFLOW FD Grid.IBOUND Unit[LayIndex]<0, MODFLOW_L_AddToList(ConcentrationList, Interpolate(Prescribed Head Unit[LayIndex].Concentration)), 0) [G0]
			End file
			Evaluate expression: MODFLOW_Delete_File("Dummy")
		End if
	End loop
	Evaluate expression: MODFLOW_L_SortList(ConcentrationList)
	Evaluate expression: MODFLOW_L_EliminateDuplicates(ConcentrationList)
	# MOC3D NUMOBS calculation
	If: ContinueSimulation&(ExportOBS!=0)
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Evaluating MOC3D observations")
		Set Variable: MOC_NUMOBS:= 0
		Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
			# Set Variable: ContinueSimulation:=  MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				If: LayIndex=FirstMoc3DUnit
					Set Variable: M:= 0
				Else
					Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
				End if
			End if
			If: ContinueSimulation&MODFLOW_SIMUL(LayIndex)&!IsLayerEmpty(MOC3D Observation Wells.Elevation1)
				Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
					Loop for: Blocks
						Loop for: Objects in layer: MOC3D Observation Wells
							Loop for: Variable ObservationIndex from: 1 to: 5 step: 1
								Set Variable: WD:= MOC3D Observation Wells.Elevation[ObservationIndex]
								If: WD!=$N/A
									Set Variable: TempValue2:= Elevation Top Unit[LayIndex]
									Set Variable: TempValue3:= (TempValue2-Elevation Bottom Unit[LayIndex])/MODFLOW_NDIV(LayIndex)
									Set Variable: TML:= TempValue2-(DivIndex-1)*TempValue3
									Set Variable: BML:= TempValue2-DivIndex*TempValue3
									If: TML>WD & BML<=WD
										Set Variable: MOC_NUMOBS:= MOC_NUMOBS+1
									End if
								End if
							End loop
						End loop
					End loop
				End loop
			End if
		End loop
	End if
End if
# 
# MF_BAS.met
# ----------------------------------------------------
# Basic Package:
# ----------------------------------------------------
If: ContinueSimulation&(ExportBAS!=0)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Basic Package")
	If: ContinueSimulation
		Redirect output to: brook.bas
			Start a new line
				Export expression: Heading1 [G0]
			End line
			Start a new line
				Export expression: Heading2 [G0]
			End line
			Start a new line
				Export expression: NumLay [I5]
				Export expression: NumRows() [I5]
				Export expression: NumColumns() [I5]
				Export expression: MODFLOW_NPER() [I5]
				Export expression: ITMUNI [I5]
			End line
			Start a new line
				Export expression: OPTION [G0]
			End line
			Start a new line
				Export expression: IAPART [I5]
				Export expression: ISTRT [I5]
			End line
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation&MODFLOW_SIMUL(LayIndex)!=0
					Redirect output to: brook.i$LOOP$
						If: TransportFlag=1 & Transport>0 & LayIndex>=FirstMoc3DUnit & LayIndex<=LastMoc3DUnit
							# MOC3D case
							Export matrix: MODFLOW FD Grid.IBOUND Unit[LayIndex] * if(MODFLOW FD Grid.IBOUND Unit[LayIndex]>=0,1,1+MODFLOW_L_IndexOf(ConcentrationList, Interpolate(Prescribed Head Unit[LayIndex].Concentration))) [I5]
						Else
							Export matrix: MODFLOW FD Grid.IBOUND Unit[LayIndex] [I5]
						End if
					End file
					Evaluate expression: MODFLOW_Rename_File("brook.i" + $LOOP$, "brook.i" + MODFLOW_Int2Str(LayIndex-1))
					Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						Start a new line
							Export expression: "OPEN/CLOSE brook.i" + MODFLOW_Int2Str(LayIndex-1) + " 1 (FREE)" [G0]
							Export expression: 5 [I5]
						End line
					End loop
				End if
			End loop
			If: ContinueSimulation
				Start a new line
					Export expression: HNOFLO [G0]
				End line
			End if
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation
				If: MODFLOW_SIMUL(LayIndex)!=0
				If: InitialHeadChoice
					Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						Start a new line
							Export expression: "EXTERNAL 42 1. (BINARY) " [G0]
							Export expression: 2 [I5]
						End line
					End loop
				Else
					Redirect output to: brook.h$LOOP$
						Export matrix: MODFLOW FD Grid.Initial Head Unit[LayIndex] [G0]
						If: CalcElev&ShowWarnings
							Redirect output to: Dummy
								Export matrix: If(MODFLOW FD Grid.IBOUND Unit[LayIndex]&MODFLOW FD Grid.Initial Head Unit[LayIndex]<MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex), MODFLOW_ProgressBarAddLine("Warning: Initial head is below the bottom of the layer in Unit "+ LayIndex + ", Row " + Row() + " Column " + Column()), 0) [G0]
							End file
							Evaluate expression: MODFLOW_Delete_File("Dummy")
						End if
					End file
					Evaluate expression: MODFLOW_Rename_File("brook.h" + $LOOP$, "brook.h" + MODFLOW_Int2Str(LayIndex-1))
					Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						Start a new line
							Export expression: "OPEN/CLOSE brook.h" + MODFLOW_Int2Str(LayIndex-1) + " 1.0 (FREE)" [G0]
							Export expression: 2 [I5]
						End line
					End loop
				End if
				End if
				End if
			End loop
			Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation
					Start a new line
						Export expression: MODFLOW_PERLEN(PeriodIndex); [G0]
						Export expression: MODFLOW_NSTP(PeriodIndex); [I5]
						Export expression: MODFLOW_TSMULT(PeriodIndex); [G0]
					End line
				End if
			End loop
		End file
	End if
End if
# 
# MF_OC.met
# ----------------------------------------------------
# Output Control Option:
# ----------------------------------------------------
If: ContinueSimulation&(ExportOC!=0)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Output Control")
	If: ContinueSimulation
		Redirect output to: brook.oc
			Start a new line
				Export expression: "HEAD PRINT FORMAT"; [G0]
				If: HeadPrintStyle
					Export expression: HeadPrintFormat [I5]
				Else
					Export expression: -HeadPrintFormat [I5]
				End if
			End line
			Start a new line
				Export expression: "DRAWDOWN PRINT FORMAT"; [G0]
				If: DrawdownPrintStyle
					Export expression: DrawdownPrintFormat [I5]
				Else
					Export expression: -DrawdownPrintFormat [I5]
				End if
			End line
			If: OutputHead=1
				Start a new line
					Export expression: "HEAD SAVE FORMAT" [G0]
					Export expression: " (8E13.5) " [G0]
					Export expression: "LABEL" [G0]
				End line
				Start a new line
					Export expression: "HEAD SAVE UNIT 23" [G0]
				End line
			End if
			If: OutputHead=2
				Start a new line
					Export expression: "HEAD SAVE UNIT 22" [G0]
				End line
			End if
			If: OutputDrawdown=1
				Start a new line
					Export expression: "DRAWDOWN SAVE FORMAT" [G0]
					Export expression: " (8E13.5) " [G0]
					Export expression: "LABEL" [G0]
				End line
				Start a new line
					Export expression: "DRAWDOWN SAVE UNIT 25" [G0]
				End line
			End if
			If: OutputDrawdown=2
				Start a new line
					Export expression: "DRAWDOWN SAVE UNIT 24" [G0]
				End line
			End if
			If: CompactBudget=1
				Start a new line
					Export expression: "COMPACT BUDGET FILES" [G0]
				End line
			End if
			Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation
					Loop for: Variable StepIndex from: 1 to: MODFLOW_NSTP(PeriodIndex) step: 1
						If: FreqHeadList!=0
							If: (FreqHeadList<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqHeadList>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqHeadList)=0))
								Set Variable: ocflag:= 1
							End if
						End if
						# Check for printing drawdown in listing file
						If: FreqDrawdownList!=0
							If: (FreqDrawdownList<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqDrawdownList>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqDrawdownList)=0))
								Set Variable: ocflag:= 1
							End if
						End if
						# Check for printing budget in listing file
						If: FreqBudgetList!=0
							If: (FreqBudgetList<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqBudgetList>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqBudgetList)=0))
								Set Variable: ocflag:= 1
							End if
						End if
						# Check for writing head to file
						If: OutputHead!=0&FreqHeadFile!=0
							If: (FreqHeadFile<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqHeadFile>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqHeadFile)=0))
								Set Variable: ocflag:= 1
							End if
						End if
						# Check for writing drawdown to file
						If: OutputDrawdown!=0&FreqDrawdownFile!=0
							If: (FreqDrawdownFile<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqDrawdownFile>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqDrawdownFile)=0))
								Set Variable: ocflag:= 1
							End if
						End if
						# Check for writing budget to file
						If: OutputBudget=1&FreqBudgetFile!=0
							If: (FreqBudgetFile<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqBudgetFile>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex,FreqBudgetFile)=0))
								Set Variable: ocflag:= 1
							End if
						End if
						# If ocflag=1, write items to be output for period & timestep
						If: ocflag=1
							Start a new line
								Export expression: "PERIOD" [G0]
								Export expression: PeriodIndex [I10]
								Export expression: "   STEP" [G0]
								Export expression: StepIndex [I10]
							End line
							# Check for head in listing file
							If: FreqHeadList!=0
								If: (FreqHeadList<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqHeadList>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqHeadList)=0))
									Start a new line
										Export expression: "PRINT HEAD" [G0]
									End line
								End if
							End if
							# Check for drawdown in listing file
							If: FreqDrawdownList!=0
								If: (FreqDrawdownList<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqDrawdownList>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqDrawdownList)=0))
									Start a new line
										Export expression: "PRINT DRAWDOWN" [G0]
									End line
								End if
							End if
							# Check for budget in listing file
							If: FreqBudgetList!=0
								If: (FreqBudgetList<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqBudgetList>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqBudgetList)=0))
									Start a new line
										Export expression: "PRINT BUDGET" [G0]
									End line
								End if
							End if
							# Check for head to be saved to file (formatted or binary)
							If: OutputHead!=0&FreqHeadFile!=0
								If: (FreqHeadFile<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqHeadFile>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqHeadFile)=0))
									Start a new line
										Export expression: "SAVE HEAD" [G0]
									End line
								End if
							End if
							# Check for drawdown to be saved to file (formatted or binary)
							If: OutputDrawdown!=0&FreqDrawdownFile!=0
								If: (FreqDrawdownFile<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqDrawdownFile>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqDrawdownFile)=0))
									Start a new line
										Export expression: "SAVE DRAWDOWN" [G0]
									End line
								End if
							End if
							# Check for budget to be saved to file (binary)
							If: OutputBudget=1&FreqBudgetFile!=0
								If: (FreqBudgetFile<0&StepIndex=MODFLOW_NSTP(PeriodIndex))|(FreqBudgetFile>0&(StepIndex=MODFLOW_NSTP(PeriodIndex)|Mod(StepIndex, FreqBudgetFile)=0))
									Start a new line
										Export expression: "SAVE BUDGET" [G0]
									End line
								End if
							End if
						End if
					End loop
				End if
			End loop
		End file
	End if
End if
# 
# MF_BCF.met
# ----------------------------------------------------
# Block-Centered Flow Package:
# ----------------------------------------------------
If: ContinueSimulation&(ExportBCF!=0)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package")
	If: ContinueSimulation
		Redirect output to: brook.bcf
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Item 1")
			If: ContinueSimulation
				# Data item 1
				Start a new line
					Export expression: ISS [I5]
					If: IBCFCB=0
						Export expression: 0 [I5]
					End if
					If: IBCFCB!=0
						Export expression: 33 [I5]
					End if
					Export expression: HDRY [E13.5]
					Export expression: IWDFLG [I5]
					Export expression: WETFCT [E13.5]
					Export expression: IWETIT [I5]
					Export expression: IHDWET [I5]
				End line
			End if
			# Data item 2
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: LAYCON")
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
					If: MODFLOW_LAYCON(LayIndex)=1&LayIndex!=TopSimul
						Set Variable: err_bcf_1:= 1
						# Alert: "Only the top simulated geologic unit can be unconfined!"
						If: ShowWarnings
							Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Layer " + LayIndex + " is unconfined but only the top simulated geologic unit can be unconfined!")
						End if
					End if
					Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						If: MODFLOW_LAYCON(LayIndex)=1&DivIndex!=1
							Start a new line
								Export expression: MODFLOW_AVEMETHOD(LayIndex) [I1]
								Export expression: 3 [I1]
							End line
						Else
							Start a new line
								Export expression: MODFLOW_AVEMETHOD(LayIndex) [I1]
								Export expression: MODFLOW_LAYCON(LayIndex) [I1]
							End line
						End if
					End loop
				End if
			End loop
			# Data item 3
			If: ContinueSimulation
				Start a new line
					Export expression: "INTERNAL 1.0 (FREE)" [G0]
					Export expression: 1 [I5]
				End line
			End if
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Anisotropy")
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
					Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						Start a new line
							Export expression: MODFLOW_TRPY(LayIndex) [E13.5]
						End line
					End loop
				End if
			End loop
			# Data item 4
			If: ContinueSimulation
				Start a new line
					Export expression: "INTERNAL 1.0 (FREE)" [G0]
					Export expression: 1 [I5]
				End line
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Columns positions")
				Loop for: Columns
					If: $Column$<NumColumns()
						Start a new line
							Export expression: Abs(NthColumnPos($Column$+1)-NthColumnPos($Column$)) [E13.5]
						End line
					End if
				End loop
				# Data item 5
			End if
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Row positions")
			If: ContinueSimulation
				Start a new line
					Export expression: "INTERNAL 1.0 (FREE)" [G0]
					Export expression: 1 [I5]
				End line
				Loop for: Rows
					If: $Row$<NumRows()
						Start a new line
							Export expression: Abs(NthRowPos($Row$+1)-NthRowPos($Row$)) [E13.5]
						End line
					End if
				End loop
			End if
			# Data item 6 export to external file
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
					If: ISS=0
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Storage parameters")
						Redirect output to: brook.s$LOOP$
							If: MODFLOW_LAYCON(LayIndex)=0
								If: MODFLOW_SpecSF1(LayIndex)
									Export matrix: Conf Storage Coef Unit[LayIndex] [G0]
									If: ShowWarnings
										Redirect output to: Dummy
											Export matrix: If((Conf Storage Coef Unit[LayIndex]>1)|(Conf Storage Coef Unit[LayIndex]<0), MODFLOW_ProgressBarAddLine("Error: Confined Storage Coefficient in Unit " + LayIndex + ", Row " + Row() + ", Column " + Column() + " is negative or greater than 1."), 0) [G0]
										End file
										Evaluate expression: MODFLOW_Delete_File("Dummy")
									End if
								Else
									Export matrix: MODFLOW FD Grid.Sp_Storage Unit[LayIndex]*MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex) [G0]
									If: ShowWarnings
										Redirect output to: Dummy
											Export matrix: If((MODFLOW FD Grid.Sp_Storage Unit[LayIndex]>1)|(MODFLOW FD Grid.Sp_Storage Unit[LayIndex]<0), MODFLOW_ProgressBarAddLine("Error: Specific Storage in Unit " + LayIndex + ", Row " + Row() + ", Column " + Column() + " is negative or greater than 1."), 0) [G0]
										End file
										Evaluate expression: MODFLOW_Delete_File("Dummy")
									End if
								End if
							End if
							If: ((MODFLOW_LAYCON(LayIndex)=1)&(MODFLOW_NDIV(LayIndex)>1))|MODFLOW_LAYCON(LayIndex)=2|MODFLOW_LAYCON(LayIndex)=3
								Export matrix: MODFLOW FD Grid.Sp_Storage Unit[LayIndex]*MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex) [G0]
								If: MODFLOW_SpecSF1(LayIndex)
									Export matrix: Conf Storage Coef Unit[LayIndex] [G0]
									If: ShowWarnings
										Redirect output to: Dummy
											Export matrix: If((Conf Storage Coef Unit[LayIndex]>1)|(Conf Storage Coef Unit[LayIndex]<0), MODFLOW_ProgressBarAddLine("Error: Confined Storage Coefficient in Unit " + LayIndex + ", Row " + Row() + ", Column " + Column() + " is negative or greater than 1."), 0) [G0]
										End file
										Evaluate expression: MODFLOW_Delete_File("Dummy")
									End if
								Else
									Export matrix: MODFLOW FD Grid.Sp_Storage Unit[LayIndex]*MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex) [G0]
									If: ShowWarnings
										Redirect output to: Dummy
											Export matrix: If((MODFLOW FD Grid.Sp_Storage Unit[LayIndex]>1)|(MODFLOW FD Grid.Sp_Storage Unit[LayIndex]<0), MODFLOW_ProgressBarAddLine("Error: Specific Storage in Unit " + LayIndex + ", Row " + Row() + ", Column " + Column() + " is negative or greater than 1."), 0) [G0]
										End file
										Evaluate expression: MODFLOW_Delete_File("Dummy")
									End if
								End if
								If: (MODFLOW_LAYCON(LayIndex)=1)&(MODFLOW_NDIV(LayIndex)>1)
									Redirect output to: brook.y$LOOP$
										Export matrix: MODFLOW FD Grid.Sp_Yield Unit[LayIndex] [G0]
									End file
									Evaluate expression: MODFLOW_Rename_File("brook.y" + $LOOP$, "brook.y" + MODFLOW_Int2Str(LayIndex-1))
									If: ShowWarnings
										Redirect output to: Dummy
											Export matrix: If((MODFLOW FD Grid.Sp_Yield Unit[LayIndex]>1)|(MODFLOW FD Grid.Sp_Yield Unit[LayIndex]<0), MODFLOW_ProgressBarAddLine("Error: Specific Yield in Unit " + LayIndex + ", Row " + Row() + ", Column " + Column() + " is negative or greater than 1."), 0) [G0]
										End file
										Evaluate expression: MODFLOW_Delete_File("Dummy")
									End if
								End if
							Else
								If: MODFLOW_LAYCON(LayIndex)!=0
									Redirect output to: brook.y$LOOP$
										Export matrix: MODFLOW FD Grid.Sp_Yield Unit[LayIndex] [G0]
									End file
									Evaluate expression: MODFLOW_Rename_File("brook.y" + $LOOP$, "brook.y" + MODFLOW_Int2Str(LayIndex-1))
									If: ShowWarnings
										Redirect output to: Dummy
											Export matrix: If((MODFLOW FD Grid.Sp_Yield Unit[LayIndex]>1)|(MODFLOW FD Grid.Sp_Yield Unit[LayIndex]<0), MODFLOW_ProgressBarAddLine("Error: Specific Yield in Unit " + LayIndex + ", Row " + Row() + ", Column " + Column() + " is negative or greater than 1."), 0) [G0]
										End file
										Evaluate expression: MODFLOW_Delete_File("Dummy")
									End if
								End if
							End if
						End file
						Evaluate expression: MODFLOW_Rename_File("brook.s" + $LOOP$, "brook.s" + MODFLOW_Int2Str(LayIndex-1))
					End if
					# Data items 7 and 8 export to external files
					If: MODFLOW_LAYCON(LayIndex)=0|MODFLOW_LAYCON(LayIndex)=2
						# Data item 7 export to external file
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Transmissivity " + LayIndex)
						If: ContinueSimulation
							Redirect output to: brook.k$LOOP$
								If: MODFLOW_SpecTrans(LayIndex)
									Export matrix: Trans Unit[LayIndex] / MODFLOW_NDIV(LayIndex) [G0]
								Else
									Export matrix: MODFLOW FD Grid.Kx Unit[LayIndex]*MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex) [G0]
								End if
							End file
							Evaluate expression: MODFLOW_Rename_File("brook.k" + $LOOP$, "brook.k" + MODFLOW_Int2Str(LayIndex-1))
						End if
					Else
						# Data item 8 export to external file
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: Hydraulic conductivity")
						If: ContinueSimulation
							Redirect output to: brook.k$LOOP$
								Export matrix: MODFLOW FD Grid.Kx Unit[LayIndex] [G0]
							End file
							Evaluate expression: MODFLOW_Rename_File("brook.k" + $LOOP$, "brook.k" + MODFLOW_Int2Str(LayIndex-1))
						End if
					End if
					If: ShowWarnings&ContinueSimulation
						Redirect output to: Dummy
							Export matrix: If(MODFLOW FD Grid.Kx Unit[LayIndex]<0, MODFLOW_ProgressBarAddLine("Error: Kx in Unit " + LayIndex + ", Row " + Row() + ", Column " + Column() + " is negative."), 0) [G0]
						End file
						Evaluate expression: MODFLOW_Delete_File("Dummy")
					End if
					# Data item 10 export to external file
					If: MODFLOW_NDIV(LayIndex) > 1
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: VCONT")
						If: ContinueSimulation
							Redirect output to: brook.z$LOOP$
								If: MODFLOW_SpecVcont(LayIndex)
									Export matrix: Vert Cond Unit[LayIndex] [G0]
								Else
									Export matrix: (MODFLOW_L_GetFromOneBased3DList(KzList, Column(), Row(), LayIndex))/(MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)) [G0]
								End if
							End file
							Evaluate expression: MODFLOW_Rename_File("brook.z" + $LOOP$, "brook.z" + MODFLOW_Int2Str(LayIndex-1))
						End if
					End if
					# Data item 6
					Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						If: ISS=0
							Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Block-Centered Flow Package: storage")
							If: ContinueSimulation
								Start a new line
									If: (MODFLOW_LAYCON(LayIndex)=1)&(DivIndex=1)
										Export expression: "OPEN/CLOSE brook.y" + MODFLOW_Int2Str(LayIndex-1) + " 1.0 (FREE)" [G0]
										Export expression: 12 [I5]
									Else
										Export expression: "OPEN/CLOSE brook.s" + MODFLOW_Int2Str(LayIndex-1) + " 1.0 (FREE)" [G0]
										Export expression: 12 [I5]
									End if
								End line
							End if
						End if
						# Data items 7 and 8
						If: ContinueSimulation
							If: (MODFLOW_LAYCON(LayIndex)=0|MODFLOW_LAYCON(LayIndex)=2)
								# Data item 7
								Start a new line
									Export expression: "OPEN/CLOSE brook.k" + MODFLOW_Int2Str(LayIndex-1) + " 1.0 (FREE)" [G0]
									Export expression: 12 [I5]
								End line
							Else
								# Data item 8
								Start a new line
									Export expression: "OPEN/CLOSE brook.k" + MODFLOW_Int2Str(LayIndex-1) + " 1.0 (FREE)" [G0]
									Export expression: 12 [I5]
								End line
								# Data item 9
								# YBI: note that the next matrix is different for each sub division!
								Start a new line
									Export expression: "INTERNAL 1.0 (FREE)" [G0]
									Export expression: 12 [I5]
								End line
								Export matrix: MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-DivIndex*(MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)) [G0]
							End if
							# Data item 10
							If: DivIndex<MODFLOW_NDIV(LayIndex)
								Start a new line
									Export expression: "OPEN/CLOSE brook.z" + MODFLOW_Int2Str(LayIndex-1) + " 1.0 (FREE)" [G0]
									Export expression: 12 [I5]
								End line
							End if
							If: DivIndex=MODFLOW_NDIV(LayIndex)
								If: MODFLOW_SpecVcont(LayIndex)
									Start a new line
										Export expression: "INTERNAL 1.0 (FREE)" [G0]
										Export expression: 12 [I5]
									End line
									Export matrix: Vert Cond Unit[LayIndex] [G0]
								Else
									# the case of the bottom subdivision is different from all the other sub divisions
									If: LayIndex<BotSimul
										Start a new line
											Export expression: "INTERNAL 1.0 (FREE)" [G0]
											Export expression: 12 [I5]
										End line
										Set Variable: ocflag:= 0
										Loop for: Variable k from: LayIndex+1 to: BotSimul step: 1
											If: MODFLOW_SIMUL(k)!=0&ocflag=0
												Set Variable: M:= k
												Set Variable: ocflag:= 1
											End if
										End loop
										Set Variable: ResultList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), 1)
										Loop for: Variable k from: LayIndex to: M step: 1
											Set Variable: TempThickListStart:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), 1)
										End loop
										Set Variable: TempThickListStart:= TempThickListStart - (M - LayIndex)
										Loop for: Variable k from: LayIndex to: M step: 1
											Set Variable: TempKzListStart:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), 1)
										End loop
										Set Variable: TempKzListStart:= TempKzListStart - (M - LayIndex)
										Set Variable: TempThickIndex:= TempThickListStart - 1
										Set Variable: TempKzListIndex:= TempKzListStart - 1
										Loop for: Variable k from: LayIndex to: M step: 1
											Set Variable: TempThickIndex:= TempThickIndex + 1
											Set Variable: TempKzListIndex:= TempKzListIndex + 1
											Redirect output to: Dummy
												Export matrix: MODFLOW_L_SetOneBased3DListItem(TempThickIndex, Column(), Row(), 1, MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), k)) [G0]
												Export matrix: MODFLOW_L_SetOneBased3DListItem(TempKzListIndex, Column(), Row(), 1, MODFLOW_L_GetFromOneBased3DList(KzList, Column(), Row(), k)) [G0]
											End file
											Evaluate expression: MODFLOW_Delete_File("Dummy")
											If: (k=LayIndex)|(k=M)
												Evaluate expression: MODFLOW_L_Multipy3DByConstant(TempThickIndex, TempThickIndex, 0.5)
											End if
										End loop
										Loop for: Blocks
											Set Variable: ocflag:= 1
											Set Variable: TempThickIndex:= TempThickListStart - 1
											Set Variable: TempKzListIndex:= TempKzListStart - 1
											Set Variable: DumCol:= Column()
											Set Variable: DumRow:= Row()
											Loop for: Variable k from: LayIndex to: M step: 1
												If: ocflag
													Set Variable: TempThickIndex:= TempThickIndex + 1
													Set Variable: TempKzListIndex:= TempKzListIndex + 1
													Set Variable: TempValue1:= MODFLOW_L_GetFromOneBased3DList(TempThickIndex, DumCol, DumRow, 1)
													Set Variable: TempValue2:= MODFLOW_L_GetFromOneBased3DList(TempKzListIndex, DumCol, DumRow, 1)
													If: (TempValue1=0)|(TempValue2=0)
														Evaluate expression: MODFLOW_L_SetOneBased3DListItem(ResultList, DumCol, DumRow, 1, 0)
														Set Variable: ocflag:= 0
													Else
														Evaluate expression: MODFLOW_L_SetOneBased3DListItem(ResultList, DumCol, DumRow, 1, TempValue1 / TempValue2 + MODFLOW_L_GetFromOneBased3DList(ResultList, DumCol, DumRow, 1))
													End if
												End if
											End loop
										End loop
										Evaluate expression: MODFLOW_L_Invert3DListMembers(ResultList, ResultList)
										Export matrix: MODFLOW_L_GetFromOneBased3DList(ResultList, Column(), Row(), 1) [G0]
										Evaluate expression: MODFLOW_L_FreeA3DList(ResultList)
										Set Variable: TempThickIndex:= TempThickListStart - 1
										Set Variable: TempKzListIndex:= TempKzListStart - 1
										Loop for: Variable k from: LayIndex to: M step: 1
											Set Variable: TempThickIndex:= TempThickIndex + 1
											Set Variable: TempKzListIndex:= TempKzListIndex + 1
											Evaluate expression: MODFLOW_L_FreeA3DList(TempThickIndex)
											Evaluate expression: MODFLOW_L_FreeA3DList(TempKzListIndex)
										End loop
									End if
								End if
							End if
						End if
						# Data item 11
						If: ContinueSimulation
							If: ISS=0&(MODFLOW_LAYCON(LayIndex)=2|MODFLOW_LAYCON(LayIndex)=3|(MODFLOW_LAYCON(LayIndex)=1&DivIndex>1))
								Start a new line
									Export expression: "INTERNAL 1.0 (FREE)" [G0]
									Export expression: 12 [I5]
								End line
								Export matrix: MODFLOW FD Grid.Sp_Yield Unit[LayIndex] [G0]
								If: ShowWarnings
									Redirect output to: Dummy
										Export matrix: If((MODFLOW FD Grid.Sp_Yield Unit[LayIndex]>1)|(MODFLOW FD Grid.Sp_Yield Unit[LayIndex]<0), MODFLOW_ProgressBarAddLine("Error: Specific Yield in Unit " + LayIndex + ", Row " + Row() + ", Column " + Column() + " is negative or greater than 1."), 0) [G0]
									End file
									Evaluate expression: MODFLOW_Delete_File("Dummy")
								End if
							End if
						End if
						# Data item 12
						If: ContinueSimulation
							If: MODFLOW_LAYCON(LayIndex)=2|MODFLOW_LAYCON(LayIndex)=3|(MODFLOW_LAYCON(LayIndex)=1&DivIndex>1)
								Start a new line
									Export expression: "INTERNAL 1.0 (FREE)" [G0]
									Export expression: 12 [I5]
								End line
								# Export matrix: MODFLOW FD Grid.Elev Top Unit[LayIndex]-(DivIndex-1)*(MODFLOW FD Grid.Thickness Unit[LayIndex]/MODFLOW_NDIV(LayIndex)) [G0]
								Export matrix: MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-(DivIndex-1)*(MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)) [G0]
							End if
						End if
						# Data item 13
						If: ContinueSimulation
							If: IWDFLG!=0&(MODFLOW_LAYCON(LayIndex)=1|MODFLOW_LAYCON(LayIndex)=3)
								Start a new line
									Export expression: "INTERNAL 1.0 (FREE)" [G0]
									Export expression: 12 [I5]
								End line
								Export matrix: MODFLOW FD Grid.Wetting Unit[LayIndex] [G0]
							End if
						End if
					End loop
				End if
			End loop
		End file
	End if
End if
# 
# MF_RCH.met
# ----------------------------------------------------
# Recharge Package:
# ----------------------------------------------------
If: ContinueSimulation&(RechargeChoice!=0&ExportRCH!=0)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Recharge Package")
	If: ContinueSimulation
		Redirect output to: brook.rch
			Start a new line
				# Export NRCHOP
				Export expression: NRCHOP [I5]
				If: IRCHCB>0&OneCBCFile=1
					Export expression: 33; [I5]
				End if
				If: IRCHCB>0&OneCBCFile=0
					Export expression: 28; [I5]
				End if
				If: IRCHCB=0
					Export expression: 0; [I5]
				End if
				If: MODPATHChoice
					Export expression: RechargeITOP [G0]
				End if
			End line
			# Stress period 1
			Start a new line
				Export expression: 1 [I5]
				If: NRCHOP=2
					Export expression: 1 [I5]
				End if
				If: NRCHOP!=2
					Export expression: -1 [I5]
				End if
			End line
			# Export Recharge flux for stress period 1
			Start a new line
				Export expression: "INTERNAL 1.0  (FREE)" [G0]
				Export expression: 2 [I5]
			End line
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				Export matrix: Recharge.Stress1 [G0]
			End if
			# Export Layer number of recharge if NRCHOP=2
			If: ContinueSimulation&(NRCHOP=2)
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation
					Start a new line
						Export expression: "INTERNAL 1  (FREE)" [G0]
						Export expression: 9 [I5]
					End line
				End if
				If: ContinueSimulation
					If: 0
						Export matrix: Recharge Layer [I5]
					Else
						Loop for: Blocks
							If: ContinueSimulation
								Set Variable: ocflag:= 0
								If: Recharge.Stress1!=0&(Recharge Elevation<=MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), 1)&Recharge Elevation>MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), MODFLOW_NLAY()))
									Set Variable: M:= 0
									Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
										If: ocflag=0
											If: LayIndex=1
												Set Variable: M:= 0
											Else
												Set Variable: M:= M+MODFLOW_NDIV(LayIndex-1)*MODFLOW_SIMUL(LayIndex-1)
											End if
											If: Recharge Elevation<=MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)&Recharge Elevation>MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
												Set Variable: ocflag:= 1
												If: MODFLOW_SIMUL(LayIndex)!=0
													Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
														Set Variable: CellThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
														If: (Recharge Elevation<=MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-(DivIndex-1)*CellThickness)&(Recharge Elevation>(MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-DivIndex*CellThickness))
															Set Variable: k:= M+DivIndex
															Start a new line
																Export expression: k [I5]
															End line
														End if
													End loop
												Else
													Start a new line
														Set Variable: err_rch_1:= 1
														# Alert: "Recharge elevation is located in a non-simulated geologic unit!"
														If: ShowWarnings
															Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("At column " + Column() + " and Row " + Row() +  ", recharge elevation is located in a non-simulated geologic unit!")
														End if
														Export expression: 999 [I5]
													End line
												End if
											End if
										End if
									End loop
								Else
									Start a new line
										Export expression: 1 [I5]
									End line
								End if
							End if
						End loop
					End if
				End if
			End if
			If: MODFLOW_NPER()>=2
				Loop for: Variable PeriodIndex from: 2 to: MODFLOW_NPER() step: 1
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						If: SteadyRecharge=0
							Start a new line
								Export expression: -1 [I5]
								Export expression: -1 [I5]
							End line
						Else
							Start a new line
								Export expression: 1 [I5]
								# assume recharge elevation does not change if NRCHOP=2
								Export expression: -1 [I5]
							End line
							# Export Recharge flux for stress period
							Start a new line
								Export expression: "INTERNAL 1.0  (FREE)" [G0]
								Export expression: 2 [I5]
							End line
							Export matrix: Recharge.Stress[PeriodIndex] [G0]
							If: ShowWarnings
								Set Variable: RechargeTest:= 0
								Loop for: Blocks
									If: Recharge.Stress[PeriodIndex]<0
										Set Variable: RechargeTest:= 1
									End if
								End loop
								If: RechargeTest
									Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: one or more recharge values in Stress Period " + PeriodIndex + " is negative.")
								End if
							End if
						End if
					End if
				End loop
			End if
		End file
	End if
End if
# 
# MF_EVT.met
# ----------------------------------------------------
# Export for EVT Package:
# ----------------------------------------------------
If: ContinueSimulation&(EvapotranspirationChoice!=0&ExportEVT!=0)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Evapotranspiration Package")
	Redirect output to: brook.evt
		Start a new line
			# Export NEVTOP
			Export expression: NEVTOP [I5]
			If: IEVTCB>0&OneCBCFile=1
				Export expression: 33; [I5]
			End if
			If: IEVTCB>0&OneCBCFile=0
				Export expression: 31; [I5]
			End if
			If: IEVTCB=0
				Export expression: 0; [I5]
			End if
			If: MODPATHChoice
				Export expression: EvapITOP [G0]
			End if
		End line
		# Stress period 1
		Start a new line
			Export expression: 1 [I5]
			Export expression: 1 [I5]
			Export expression: 1 [I5]
			If: NEVTOP=2
				Export expression: 1 [I5]
			End if
			If: NEVTOP!=2
				Export expression: -1 [I5]
			End if
		End line
		# Export ET surface for stress period 1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation
			Start a new line
				Export expression: "INTERNAL 1.0  (FREE)" [G0]
				Export expression: 2 [I5]
			End line
			Export matrix: Evapotranspiration [G0]
		End if
		# Export ET rate for stress period 1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation
			Start a new line
				Export expression: "INTERNAL 1.0  (FREE)" [G0]
				Export expression: 2 [I5]
			End line
			Export matrix: Evapotranspiration.EVT Flux Stress1 [G0]
		End if
		# Export ET extinction depth for stress period 1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation
			Start a new line
				Export expression: "INTERNAL 1.0  (FREE)" [G0]
				Export expression: 2 [I5]
			End line
			Export matrix: Evapotranspiration.EVT Extinction Depth [G0]
		End if
		# Export Layer number where ET is removed if NEVTOP=2
		If: ContinueSimulation&(NEVTOP=2)
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				Start a new line
					Export expression: "INTERNAL 1  (FREE)" [G0]
					Export expression: 9 [I5]
				End line
			End if
			If: ContinueSimulation
				If: 0
					Export matrix: ET Layer [I5]
				Else
					Loop for: Blocks
						Set Variable: ocflag:= 0
						If: Evapotranspiration.EVT Flux Stress1!=0&(ET Surface Elevation<=MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), 1)&ET Surface Elevation>MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), MODFLOW_NLAY()))
							Set Variable: M:= 0
							Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
								If: ocflag=0
									If: LayIndex=1
										Set Variable: M:= 0
									Else
										Set Variable: M:= M+MODFLOW_NDIV(LayIndex-1)*MODFLOW_SIMUL(LayIndex-1)
									End if
									If: ET Surface Elevation<=MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)&ET Surface Elevation>MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
										Set Variable: ocflag:= 1
										If: MODFLOW_SIMUL(LayIndex)!=0
											Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
												Set Variable: CellThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
												If: ET Surface Elevation<=(MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-(DivIndex-1)*CellThickness)&ET Surface Elevation>(MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)-DivIndex*CellThickness)
													Set Variable: k:= M+DivIndex
													Start a new line
														Export expression: k [I5]
													End line
												End if
											End loop
										Else
											Start a new line
												Set Variable: err_evt_1:= 1
												# Alert: "Evapotranspiration surface is located in a non-simulated geologic unit!"
												If: ShowWarnings
													Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("At column " + Column() + " and Row " + Row() +  ", the evapotranspiration surface is located in a non-simulated geologic unit!")
												End if
												Export expression: 999 [I5]
											End line
										End if
									End if
								End if
							End loop
						Else
							Start a new line
								Export expression: 1 [I5]
							End line
						End if
					End loop
				End if
			End if
		End if
		If: MODFLOW_NPER()>=2
			# Modified next line on June 16, 1997
			Loop for: Variable PeriodIndex from: 2 to: MODFLOW_NPER() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation
					If: SteadyEVT=0
						Start a new line
							Export expression: -1 [I5]
							Export expression: -1 [I5]
							Export expression: -1 [I5]
							Export expression: -1 [I5]
						End line
					Else
						Start a new line
							# assume ET surface and extinction depth do not change if NEVTOP=2
							Export expression: -1 [I5]
							Export expression: 1 [I5]
							Export expression: -1 [I5]
							Export expression: -1 [I5]
						End line
						# Export ET flux for stress period
						Start a new line
							Export expression: "INTERNAL 1.0  (FREE)" [G0]
							Export expression: 2 [I5]
						End line
						Export matrix: Evapotranspiration.EVT Flux Stress[PeriodIndex] [G0]
					End if
				End if
			End loop
		End if
	End file
End if
# 
# MF_GHB.met
# ----------------------------------------------------
# GHB Package
# ----------------------------------------------------
If: ContinueSimulation&(GeneralHeadChoice!=0&ExportGHB!=0)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("General-Head Boundary Package")
	Redirect output to: brook.ghb
	End file
	Set Variable: CurrentGHBCount:= 0
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Set Variable: LineLayerIsEmpty:= IsLayerEmpty(Line Gen Head Bound Unit[LayIndex].Conductance)
		Set Variable: AreaLayerIsEmpty:= IsLayerEmpty(Area Gen Head Bound Unit[LayIndex].Conductance)
		Set Variable: PointLayerIsEmpty:= IsLayerEmpty(Point Gen Head Bound Unit[LayIndex].Conductance)
		If: ContinueSimulation
			If: LayIndex=1
				Set Variable: M:= 0
			Else
				Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
			End if
			# 
			# 
			If: MODFLOW_SIMUL(LayIndex)!=0
				# 
				# Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
				# YBI moved this line into the loop to prevent array overflow
				# Set Variable: Block_Num:= (L-1)*NumRows()*NumColumns()
				Loop for: Blocks
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						Set Variable: AreaBoundaryInBlock:= 0
						# 
						# Set Variable: Block_Num:= Block_Num+1
						# If: Chk_BlockArrayGet(Block_Num)=1
						# 
						Set Variable: DumRow:= Row()
						Set Variable: DumCol:= Column()
						# 
					If: !PointLayerIsEmpty
						Loop for: Objects in layer: POINT GEN HEAD BOUND UNIT[LayIndex]
							Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								Set Variable: DumLay:= M+DivIndex
								Set Variable: CurrentGHBCount:= CurrentGHBCount + 1
								Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
									If: !(PeriodIndex>1&SteadyGHB=0)
										Redirect output to: TempGHBPer
											Start a new line
												Export expression: DumLay [I10]
												Export expression: DumRow [I10]
												Export expression: DumCol [I10]
												Export expression: Point Gen Head Bound Unit[LayIndex].Head Stress[PeriodIndex] [E13.5]
												Export expression: Point Gen Head Bound Unit[LayIndex].Conductance; [E13.5]
												# MODPATH
												If: MODPATHChoice
													Export expression: Point Gen Head Bound Unit[LayIndex].IFACE[PeriodIndex]; [G0]
												End if
												# MOC3D Data
												If: TransportFlag=1 & Transport>0
													Export expression: Point Gen Head Bound Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
												End if
											End line
										End file
										Evaluate expression: MODFLOW_Join_Files("TempGHBPer" + PeriodIndex, "TempGHBPer", "TempGHBPer" + PeriodIndex)
									End if
								End loop
							End loop
						End loop
					End if
					# 
					If: 0
						If: !LineLayerIsEmpty
							Set Variable: ThisConductance:= WSumObjectsInBlock(Line Gen Head Bound Unit[LayIndex].Conductance)
							If: ThisConductance<>0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Set Variable: DumLay:= M+DivIndex
									Set Variable: CurrentGHBCount:= CurrentGHBCount + 1
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyGHB=0)
											Redirect output to: TempGHBPer
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol [I10]
													Export expression: Line Gen Head Bound Unit[LayIndex].Head Stress[PeriodIndex] [E13.5]
													Export expression: ThisConductance; [E13.5]
													# MODPATH
													If: MODPATHChoice
														Export expression: Line Gen Head Bound Unit[LayIndex].IFACE[PeriodIndex] [G0]
													End if
													# MOC3D Data
													If: TransportFlag=1 & Transport>0
														Export expression: Line Gen Head Bound Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempGHBPer" + PeriodIndex, "TempGHBPer", "TempGHBPer" + PeriodIndex)
										End if
									End loop
								End loop
							End if
						End if
					Else
						If: !LineLayerIsEmpty
							Loop for: Objects in layer: LINE GEN HEAD BOUND UNIT[LayIndex]
								Set Variable: SegmentLength:= ContourIntersectLength()
								If: SegmentLength>0
									Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
										Set Variable: DumLay:= M+DivIndex
										Set Variable: CurrentGHBCount:= CurrentGHBCount + 1
										Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
											If: !(PeriodIndex>1&SteadyGHB=0)
												Redirect output to: TempGHBPer
													Start a new line
														Export expression: DumLay [I10]
														Export expression: DumRow [I10]
														Export expression: DumCol [I10]
														Export expression: Line Gen Head Bound Unit[LayIndex].Head Stress[PeriodIndex] [E13.5]
														Export expression: SegmentLength*Line Gen Head Bound Unit[LayIndex].Conductance; [E13.5]
														# MODPATH
														If: MODPATHChoice
															Export expression: Line Gen Head Bound Unit[LayIndex].IFACE[PeriodIndex] [G0]
														End if
														# MOC3D Data
														If: TransportFlag=1 & Transport>0
															Export expression: Line Gen Head Bound Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
														End if
													End line
												End file
												Evaluate expression: MODFLOW_Join_Files("TempGHBPer" + PeriodIndex, "TempGHBPer", "TempGHBPer" + PeriodIndex)
											End if
										End loop
									End loop
								End if
							End loop
						End if
						# 
						If: !AreaLayerIsEmpty
							Loop for: Objects in layer: AREA GEN HEAD BOUND UNIT[LayIndex]
								Set Variable: AreaBoundaryInBlock:= 1
								Set Variable: ContourArea:= ContourIntersectArea()
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Set Variable: DumLay:= M+DivIndex
									Set Variable: CurrentGHBCount:= CurrentGHBCount + 1
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyGHB=0)
											Redirect output to: TempGHBPer
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol [I10]
													Export expression: Area Gen Head Bound Unit[LayIndex].Head Stress[PeriodIndex] [E13.5]
													Export expression: ContourArea*Area Gen Head Bound Unit[LayIndex].Conductance; [E13.5]
													# MODPATH
													If: MODPATHChoice
														Export expression: Area Gen Head Bound Unit[LayIndex].IFACE[PeriodIndex]; [G0]
													End if
													# MOC3D Data
													If: TransportFlag=1 & Transport>0
														Export expression: Area Gen Head Bound Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempGHBPer" + PeriodIndex, "TempGHBPer", "TempGHBPer" + PeriodIndex)
										End if
									End loop
								End loop
							End loop
						End if
					End if
					If: (!AreaBoundaryInBlock)&(Area Gen Head Bound Unit[LayIndex].Conductance!=$N/A)
						Set Variable: ContourArea:= BlockArea()
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Set Variable: DumLay:= M+DivIndex
							Set Variable: CurrentGHBCount:= CurrentGHBCount + 1
							Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
								If: !(PeriodIndex>1&SteadyGHB=0)
									Redirect output to: TempGHBPer
										Start a new line
											Export expression: DumLay [I10]
											Export expression: DumRow [I10]
											Export expression: DumCol [I10]
											Export expression: Area Gen Head Bound Unit[LayIndex].Head Stress[PeriodIndex] [E13.5]
											Export expression: ContourArea*Area Gen Head Bound Unit[LayIndex].Conductance; [E13.5]
											# MODPATH
											If: MODPATHChoice
												Export expression: Area Gen Head Bound Unit[LayIndex].IFACE[PeriodIndex]; [G0]
											End if
											# MOC3D Data
											If: TransportFlag=1 & Transport>0
												Export expression: Area Gen Head Bound Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
											End if
										End line
									End file
									Evaluate expression: MODFLOW_Join_Files("TempGHBPer" + PeriodIndex, "TempGHBPer", "TempGHBPer" + PeriodIndex)
								End if
							End loop
						End loop
					End if
					End if
					# 
				End loop
			End if
		End if
	End loop
	If: ContinueSimulation
		Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
			Redirect output to: TempGHB1
				If: PeriodIndex>1&SteadyGHB=0
					Start a new line
						Export expression: -1 [I5]
					End line
				Else
					Start a new line
						Export expression: CurrentGHBCount [I5]
					End line
				End if
			End file
			If: CurrentGHBCount>MaxGHBs
				Set Variable: MaxGHBs:= CurrentGHBCount
			End if
			If: !(PeriodIndex>1&SteadyGHB=0)
				Evaluate expression: MODFLOW_Join_Files("TempGHB1", "TempGHBPer" + PeriodIndex, "TempGHB1")
				Evaluate expression: MODFLOW_Delete_File("TempGHBPer" + PeriodIndex)
			End if
			Evaluate expression: MODFLOW_Join_Files("brook.ghb", "TempGHB1", "brook.ghb")
			# End if
		End loop
		Redirect output to: TempGHB1
			Start a new line
				Export expression: MaxGHBs [I5]
				If: IGHBCB>0&OneCBCFile=1
					Export expression: 33 [I5]
				End if
				If: IGHBCB>0&OneCBCFile=0
					Export expression: 32 [I5]
				End if
				If: IGHBCB=0
					Export expression: 0 [I5]
				End if
				# MODPATH
				If: MODPATHChoice
					Export expression: " AUXILIARY IFACE" [G0]
				End if
				# MOC3D AUX parameter
				If: TransportFlag=1 & Transport>0
					Export expression: " CBCALLOCATE AUXILIARY CONCENTRATION" [G0]
				End if
			End line
		End file
		Evaluate expression: MODFLOW_Join_Files("TempGHB1", "brook.ghb", "brook.ghb")
		# 
		Evaluate expression: MODFLOW_Delete_File("TempGHB1")
		Evaluate expression: MODFLOW_Delete_File("TempGHBPer")
	End if
	# 
End if
# 
# MF_RIV.met
# ----------------------------------------------------
# River Package
# ----------------------------------------------------
If: ContinueSimulation&(RiverChoice!=0&ExportRIV!=0)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("River Package")
	Redirect output to: brook.riv
	End file
	# YBI syntax: Define->Set
	Set Variable: err_line:= 0
	Set Variable: err_area1:= 0
	Set Variable: err_area2:= 0
	Set Variable: RIV_MXRIVR:= 0
	Set Variable: CurrentRiverCount:= 0
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Set Variable: LineLayerIsEmpty:= IsLayerEmpty(Line River Unit[LayIndex].Conductance)
		Set Variable: AreaLayerIsEmpty:= IsLayerEmpty(Area River Unit[LayIndex].Conductance)
		Set Variable: PointLayerIsEmpty:= IsLayerEmpty(Point River Unit[LayIndex].Conductance)
		If: ContinueSimulation
			If: LayIndex=1
				Set Variable: M:= 0
			Else
				Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
			End if
			# 
			If: MODFLOW_SIMUL(LayIndex)!=0
				# 
				Loop for: Blocks
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						Set Variable: DumRow:= Row()
						Set Variable: DumCol:= Column()
						Set Variable: AreaBoundaryInBlock:= 0
					If: !PointLayerIsEmpty
						Loop for: Objects in layer: Point River Unit[LayIndex]
							Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								Set Variable: DumLay:= M+DivIndex
								Set Variable: CurrentRiverCount:= CurrentRiverCount + 1
								Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
									If: !(PeriodIndex>1&SteadyRiver=0)
										Redirect output to: TempRivPer
											Start a new line
												Export expression: DumLay [I10]
												Export expression: DumRow [I10]
												Export expression: DumCol [I10]
												Export expression: Point River Unit[LayIndex].Stage Stress[PeriodIndex] [E13.5]
												Export expression: Point River Unit[LayIndex].Conductance; [E13.5]
												# MODPATH
												If: MODPATHChoice
													Export expression: Point River Unit[LayIndex].IFACE[PeriodIndex]; [G0]
												End if
												# MOC3D Data
												If: TransportFlag=1 & Transport>0
													Export expression: Point River Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
												End if
											End line
										End file
											Evaluate expression: MODFLOW_Join_Files("TempRivPer" + PeriodIndex, "TempRivPer", "TempRivPer" + PeriodIndex)
									End if
								End loop
							End loop
						End loop
					End if
					# 
						If: 0
							If: !LineLayerIsEmpty
								Set Variable: ThisConductance:= WSumObjectsInBlock(Line River Unit[LayIndex].Conductance)
								If: ThisConductance<>0
									# If: WSumObjectsInBlock(Line River Unit[LayIndex].Conductance)!=0
									Set Variable: ThisElevation:= Line River Unit[LayIndex].Bottom Elevation
									If: ShowWarnings&(ThisElevation>=Line River Unit[LayIndex].Stage Stress1)
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Line River Unit" + LayIndex + ".Bottom Elevation>=Line River Unit" + LayIndex + ".Stage Stress1 at Row: " + DumRow + "; Column: " +DumCol)
									End if
									Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
									Set Variable: LayerBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, DumCol, DumRow, LayIndex)
									# Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
									# Set Variable: ocflag:= 0
									# Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									# 	If: Line River Unit[LayIndex].Bottom Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Line River Unit[LayIndex].Bottom Elevation>(LayerTop-DivIndex*LayerThickness)
									# 		Set Variable: ocflag:= DivIndex
									# 	End if
									# End loop
									# If: ocflag=0
									# 	Set Variable: ocflag:= 1
									# 	Set Variable: err_riv_3:= 1
									# 	Set Variable: DumLay:= M+ocflag
									If: ShowWarnings&((ThisElevation>LayerTop)|(ThisElevation<LayerBottom))
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Line river elevation does not lie within geologic unit: Line river is placed in nearest model layer in geologic unit.")
									End if
									# End if
									# Set Variable: DumLay:= M+ocflag
									Set Variable: DumLay:= MODFLOW_Layer(LayIndex, LayerTop, LayerBottom, ThisElevation)
									Set Variable: CurrentRiverCount:= CurrentRiverCount + 1
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyRiver=0)
											Redirect output to: TempRivPer
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol [I10]
													Export expression: Line River Unit[LayIndex].Stage Stress[PeriodIndex] [E13.5]
													Export expression: WSumObjectsInBlock(Line River Unit[LayIndex].Conductance) [E13.5]
													Export expression: ThisElevation; [E13.5]
													# MODPATH
													If: MODPATHChoice
														Export expression: Line River Unit[LayIndex].IFACE[PeriodIndex]; [G0]
													End if
													# MOC3D Data
													If: TransportFlag=1 & Transport>0
														Export expression: Line River Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempRivPer" + PeriodIndex, "TempRivPer", "TempRivPer" + PeriodIndex)
										End if
									End loop
								End if
							End if
						Else
							If: !LineLayerIsEmpty
								Loop for: Objects in layer: LINE RIVER UNIT[LayIndex]
									Set Variable: ThisElevation:= Line River Unit[LayIndex].Bottom Elevation
									If: ShowWarnings&(ThisElevation>=Line River Unit[LayIndex].Stage Stress1)
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Line River Unit" + LayIndex + ".Bottom Elevation>=Line River Unit" + LayIndex + ".Stage Stress1 at Row: " + DumRow + "; Column: " +DumCol)
									End if
									Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
									Set Variable: LayerBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, DumCol, DumRow, LayIndex)
									# Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
									Set Variable: SegmentLength:= ContourIntersectLength()
									If: SegmentLength>0
										# Set Variable: ocflag:= 0
										# Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
										# 	If: Line River Unit[LayIndex].Bottom Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Line River Unit[LayIndex].Bottom Elevation>(LayerTop-DivIndex*LayerThickness)
										# 		Set Variable: ocflag:= DivIndex
										# 	End if
										# End loop
										# If: ocflag=0
										# 	Set Variable: ocflag:= 1
										# 	Set Variable: err_riv_3:= 1
										# 	Set Variable: DumLay:= M+ocflag
										If: ShowWarnings&((ThisElevation>LayerTop)|(ThisElevation<LayerBottom))
											Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Line river elevation does not lie within geologic unit: Line river is placed in nearest model layer in geologic unit.")
										End if
										# End if
										# Set Variable: DumLay:= M+ocflag
										Set Variable: DumLay:= MODFLOW_Layer(LayIndex, LayerTop, LayerBottom, ThisElevation)
										Set Variable: CurrentRiverCount:= CurrentRiverCount + 1
										Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
											If: !(PeriodIndex>1&SteadyRiver=0)
												Redirect output to: TempRivPer
													Start a new line
														Export expression: DumLay [I10]
														Export expression: DumRow [I10]
														Export expression: DumCol [I10]
														Export expression: Line River Unit[LayIndex].Stage Stress[PeriodIndex] [E13.5]
														Export expression: SegmentLength*Line River Unit[LayIndex].Conductance [E13.5]
														Export expression: ThisElevation; [E13.5]
														# MODPATH
														If: MODPATHChoice
															Export expression: Line River Unit[LayIndex].IFACE[PeriodIndex]; [G0]
														End if
														# MOC3D Data
														If: TransportFlag=1 & Transport>0
															Export expression: Line River Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
														End if
													End line
												End file
												Evaluate expression: MODFLOW_Join_Files("TempRivPer" + PeriodIndex, "TempRivPer", "TempRivPer" + PeriodIndex)
											End if
										End loop
									End if
								End loop
							End if
							# 
							If: !AreaLayerIsEmpty
								Loop for: Objects in layer: AREA RIVER UNIT[LayIndex]
									Set Variable: ThisElevation:= Area River Unit[LayIndex].Bottom Elevation
									If: ShowWarnings&(ThisElevation>=Area River Unit[LayIndex].Stage Stress1)
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Area River Unit" + LayIndex + ".Bottom Elevation>=Area River Unit" + LayIndex + ".Stage Stress1 at Row: " + DumRow + "; Column: " +DumCol)
									End if
									Set Variable: AreaBoundaryInBlock:= 1
									Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
									Set Variable: LayerBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, DumCol, DumRow, LayIndex)
									# Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
									# Set Variable: ocflag:= 0
									# Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									# 	If: Area River Unit[LayIndex].Bottom Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Area River Unit[LayIndex].Bottom Elevation>(LayerTop-DivIndex*LayerThickness)
									# 		Set Variable: ocflag:= DivIndex
									# 	End if
									# End loop
									# If: ocflag=0
									# 	Set Variable: ocflag:= 1
									# 	Set Variable: err_riv_4:= 1
									# If: err_area1=0
									# Alert: "Area river elevation does not lie within geologic unit: Area river is placed in uppermost model layer in geologic unit."
									If: ShowWarnings&((ThisElevation>LayerTop)|(ThisElevation<LayerBottom))
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Area river elevation does not lie within geologic unit: Area river is placed in nearest model layer in geologic unit.")
									End if
									# Set Variable: err_area1:=1
									# End if
									# End if
									# Set Variable: DumLay:= M+ocflag
									Set Variable: DumLay:= MODFLOW_Layer(LayIndex, LayerTop, LayerBottom, ThisElevation)
									Set Variable: CurrentRiverCount:= CurrentRiverCount + 1
									Set Variable: ContourArea:= ContourIntersectArea()
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyRiver=0)
											Redirect output to: TempRivPer
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol [I10]
													Export expression: Area River Unit[LayIndex].Stage Stress[PeriodIndex] [E13.5]
													Export expression: ContourArea*Area River Unit[LayIndex].Conductance [E13.5]
													Export expression: ThisElevation; [E13.5]
													# MODPATH
													If: MODPATHChoice
														Export expression: Area River Unit[LayIndex].IFACE[PeriodIndex]; [G0]
													End if
													# MOC3D Data
													If: TransportFlag=1 & Transport>0
														Export expression: Area River Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempRivPer" + PeriodIndex, "TempRivPer", "TempRivPer" + PeriodIndex)
										End if
									End loop
								End loop
							End if
						End if
						If: (!AreaBoundaryInBlock)&(Area River Unit[LayIndex].Conductance!=$N/A)
							Set Variable: ThisElevation:= Area River Unit[LayIndex].Bottom Elevation
							If: ShowWarnings&(ThisElevation>=Area River Unit[LayIndex].Stage Stress1)
								Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Area River Unit" + LayIndex + ".Bottom Elevation>=Area River Unit" + LayIndex + ".Stage Stress1 at Row: " + DumRow + "; Column: " +DumCol)
							End if
							Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
							Set Variable: LayerBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, DumCol, DumRow, LayIndex)
							# Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
							# Set Variable: ocflag:= 0
							# Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							# 	If: Area River Unit[LayIndex].Bottom Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Area River Unit[LayIndex].Bottom Elevation>(LayerTop-DivIndex*LayerThickness)
							# 		Set Variable: ocflag:= DivIndex
							# 	End if
							# End loop
							# If: ocflag=0
							# 	Set Variable: ocflag:= 1
							# 	Set Variable: err_riv_4:= 1
							If: ShowWarnings&((ThisElevation>LayerTop)|(ThisElevation<LayerBottom))
								Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Area river elevation does not lie within geologic unit: Area river is placed in nearest model layer in geologic unit.")
							End if
							# End if
							# Set Variable: DumLay:= M+ocflag
							Set Variable: DumLay:= MODFLOW_Layer(LayIndex, LayerTop, LayerBottom, ThisElevation)
							Set Variable: CurrentRiverCount:= CurrentRiverCount + 1
							Set Variable: ContourArea:= BlockArea()
							Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
								If: !(PeriodIndex>1&SteadyRiver=0)
									Redirect output to: TempRivPer
										Start a new line
											Export expression: DumLay [I10]
											Export expression: DumRow [I10]
											Export expression: DumCol [I10]
											Export expression: Area River Unit[LayIndex].Stage Stress[PeriodIndex] [E13.5]
											Export expression: ContourArea*Area River Unit[LayIndex].Conductance [E13.5]
											Export expression: ThisElevation; [E13.5]
											# MODPATH
											If: MODPATHChoice
												Export expression: Area River Unit[LayIndex].IFACE[PeriodIndex]; [G0]
											End if
											# MOC3D Data
											If: TransportFlag=1 & Transport>0
												Export expression: Area River Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
											End if
										End line
									End file
									Evaluate expression: MODFLOW_Join_Files("TempRivPer" + PeriodIndex, "TempRivPer", "TempRivPer" + PeriodIndex)
								End if
							End loop
						End if
						# 
					End if
				End loop
			End if
		End if
	End loop
	If: ContinueSimulation
		Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
			Redirect output to: TempRiver1
				If: PeriodIndex>1&SteadyRiver=0
					Start a new line
						Export expression: -1 [I5]
					End line
				Else
					Start a new line
						Export expression: CurrentRiverCount [I5]
					End line
				End if
			End file
			If: CurrentRiverCount>MaxRivers
				Set Variable: MaxRivers:= CurrentRiverCount
			End if
			If: !(PeriodIndex>1&SteadyRiver=0)
				Evaluate expression: MODFLOW_Join_Files("TempRiver1", "TempRivPer" + PeriodIndex, "TempRiver1")
				Evaluate expression: MODFLOW_Delete_File("TempRivPer" + PeriodIndex)
			End if
			Evaluate expression: MODFLOW_Join_Files("brook.riv", "TempRiver1", "brook.riv")
			# End if
		End loop
		Redirect output to: TempRiver1
			Start a new line
				Export expression: MaxRivers [I5]
				If: IRIVCB>0&OneCBCFile=1
					Export expression: 33 [I5]
				End if
				If: IRIVCB>0&OneCBCFile=0
					Export expression: 27 [I5]
				End if
				If: IRIVCB=0
					Export expression: 0 [I5]
				End if
				# MODPATH
				If: MODPATHChoice
					Export expression: " AUXILIARY IFACE" [G0]
				End if
				# MOC3D AUX parameter
				If: TransportFlag=1 & Transport>0
					Export expression: " CBCALLOCATE AUXILIARY CONCENTRATION" [G0]
				End if
			End line
		End file
		Evaluate expression: MODFLOW_Join_Files("TempRiver1", "brook.riv", "brook.riv")
		# 
		Evaluate expression: MODFLOW_Delete_File("TempRiver1")
		Evaluate expression: MODFLOW_Delete_File("TempRivPer")
	End if
End if
# 
# MF_DRN.met
# ----------------------------------------------------
# Drain Package
# ----------------------------------------------------
If: ContinueSimulation&(DrainChoice!=0&ExportDRN!=0)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Drain Package")
	Redirect output to: brook.drn
	End file
	Set Variable: MaxDrains:= 0
	Set Variable: err_line:= 0
	Set Variable: err_area1:= 0
	Set Variable: err_area2:= 0
	Set Variable: DRN_MXDRN:= 0
	Set Variable: CurrentDrainCount:= 0
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Set Variable: PointLayerIsEmpty:= IsLayerEmpty(Point Drain Unit[LayIndex].Conductance)
		Set Variable: LineLayerIsEmpty:= IsLayerEmpty(Line Drain Unit[LayIndex].Conductance)
		Set Variable: AreaLayerIsEmpty:= IsLayerEmpty(Area Drain Unit[LayIndex].Conductance)
		If: ContinueSimulation
			If: LayIndex=1
				Set Variable: M:= 0
			Else
				Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
			End if
			# 
			If: MODFLOW_SIMUL(LayIndex)!=0
				# 
				Loop for: Blocks
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						Set Variable: AreaBoundaryInBlock:= 0
						Set Variable: DumRow:= Row()
						Set Variable: DumCol:= Column()
						# 
					If: !PointLayerIsEmpty
						Loop for: Objects in layer: Point Drain Unit[LayIndex]
									Set Variable: ThisElevation:= Point Drain Unit[LayIndex].Elevation
									Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
									Set Variable: LayerBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, DumCol, DumRow, LayIndex)
									Set Variable: DumLay:= MODFLOW_Layer(LayIndex, LayerTop, LayerBottom, ThisElevation)
									If: ShowWarnings&((ThisElevation>LayerTop)|(ThisElevation<LayerBottom))
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Point drain elevation does not lie within geologic unit: Point drain is placed in nearest model layer in geologic unit.")
									End if
									Set Variable: CurrentDrainCount:= CurrentDrainCount + 1
								Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
									If: !(PeriodIndex>1&SteadyDrain=0)
										Redirect output to: TempDrainPer
											Start a new line
												Export expression: DumLay [I10]
												Export expression: DumRow [I10]
												Export expression: DumCol [I10]
													If: Point Drain Unit[LayIndex].On or Off Stress[PeriodIndex]
														Export expression: ThisElevation [E13.5]
													Else
														Export expression: 1.e49 [E13.5]
													End if
													Export expression: Point Drain Unit[LayIndex].Conductance; [E13.5]
													# MODPATH
													If: MODPATHChoice
														Export expression: Point Drain Unit[LayIndex].IFACE[PeriodIndex] [G0]
													End if

											End line
										End file
										Evaluate expression: MODFLOW_Join_Files("TempDrainPer" + PeriodIndex, "TempDrainPer", "TempDrainPer" + PeriodIndex)
									End if
								End loop
						End loop
					End if
						If: 0
							If: !LineLayerIsEmpty
								Set Variable: ThisConductance:= WSumObjectsInBlock(Line Drain Unit[LayIndex].Conductance)
								If: ThisConductance<>0
									# If: WSumObjectsInBlock(Line Drain Unit[LayIndex].Conductance)!=0
									Set Variable: ThisElevation:= Line Drain Unit[LayIndex].Elevation
									Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
									Set Variable: LayerBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, DumCol, DumRow, LayIndex)
									# Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
									# Set Variable: ocflag:= 0
									# Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									# 	If: Line Drain Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Line Drain Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
									# 		Set Variable: ocflag:= DivIndex
									# 	End if
									# End loop
									# If: ocflag=0
									# 	Set Variable: ocflag:= 1
									# 	Set Variable: err_drn_3:= 1
									If: ShowWarnings&((ThisElevation>LayerTop)|(ThisElevation<LayerBottom))
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Line drain elevation does not lie within geologic unit: Line drain is placed in nearest model layer in geologic unit.")
									End if
									# End if
									# Set Variable: DumLay:= M+ocflag
									Set Variable: DumLay:= MODFLOW_Layer(LayIndex, LayerTop, LayerBottom, ThisElevation)
									Set Variable: CurrentDrainCount:= CurrentDrainCount + 1
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyDrain=0)
											Redirect output to: TempDrainPer
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol [I10]
													If: Line Drain Unit[LayIndex].On or Off Stress[PeriodIndex]
														Export expression: ThisElevation [E13.5]
													Else
														Export expression: 1.e49 [E13.5]
													End if
													Export expression: WSumObjectsInBlock(Line Drain Unit[LayIndex].Conductance); [E13.5]
													# MODPATH
													If: MODPATHChoice
														Export expression: Line Drain Unit[LayIndex].IFACE[PeriodIndex] [G0]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempDrainPer" + PeriodIndex, "TempDrainPer", "TempDrainPer" + PeriodIndex)
										End if
									End loop
								End if
							End if
							# 
						Else
							If: !LineLayerIsEmpty
								Loop for: Objects in layer: LINE DRAIN UNIT[LayIndex]
									Set Variable: ThisElevation:= Line Drain Unit[LayIndex].Elevation
									Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
									Set Variable: LayerBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, DumCol, DumRow, LayIndex)
									# Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
									Set Variable: SegmentLength:= ContourIntersectLength()
									If: SegmentLength>0
										# Set Variable: ocflag:= 0
										# Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
										# 	If: Line Drain Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Line Drain Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
										# 		Set Variable: ocflag:= DivIndex
										# 	End if
										# End loop
										# If: ocflag=0
										# 	Set Variable: ocflag:= 1
										# 	Set Variable: err_drn_3:= 1
										If: ShowWarnings&((ThisElevation>LayerTop)|(ThisElevation<LayerBottom))
											Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Line drain elevation does not lie within geologic unit: Line drain is placed in nearest model layer in geologic unit.")
										End if
										# End if
										# Set Variable: DumLay:= M+ocflag
										Set Variable: DumLay:= MODFLOW_Layer(LayIndex, LayerTop, LayerBottom, ThisElevation)
										# Set Variable: SegmentLength:= ContourIntersectLength()
										Set Variable: CurrentDrainCount:= CurrentDrainCount + 1
										Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
											If: !(PeriodIndex>1&SteadyDrain=0)
												Redirect output to: TempDrainPer
													Start a new line
														Export expression: DumLay [I10]
														Export expression: DumRow [I10]
														Export expression: DumCol [I10]
														If: Line Drain Unit[LayIndex].On or Off Stress[PeriodIndex]
															Export expression: ThisElevation [E13.5]
														Else
															Export expression: 1.e49 [E13.5]
														End if
														Export expression: SegmentLength*Line Drain Unit[LayIndex].Conductance; [E13.5]
														# MODPATH
														If: MODPATHChoice
															Export expression: Line Drain Unit[LayIndex].IFACE[PeriodIndex] [G0]
														End if
													End line
												End file
												Evaluate expression: MODFLOW_Join_Files("TempDrainPer" + PeriodIndex, "TempDrainPer", "TempDrainPer" + PeriodIndex)
											End if
										End loop
									End if
								End loop
							End if
							# 
							If: !AreaLayerIsEmpty
								Loop for: Objects in layer: AREA DRAIN UNIT[LayIndex]
									Set Variable: AreaBoundaryInBlock:= 1
									Set Variable: ThisElevation:= Area Drain Unit[LayIndex].Elevation
									Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
									Set Variable: LayerBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, DumCol, DumRow, LayIndex)
									# Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
									# Set Variable: ocflag:= 0
									# Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									# 	If: Area Drain Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Area Drain Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
									# 		Set Variable: ocflag:= DivIndex
									# 	End if
									# End loop
									# If: ocflag=0
									# 	Set Variable: ocflag:= 1
									# 	Set Variable: err_drn_4:= 1
									If: ShowWarnings&((ThisElevation>LayerTop)|(ThisElevation<LayerBottom))
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Area drain elevation does not lie within geologic unit: Area drain is placed in uppermost model layer in geologic unit.")
									End if
									# End if
									Set Variable: CurrentDrainCount:= CurrentDrainCount + 1
									Set Variable: ContourArea:= ContourIntersectArea()
									# Set Variable: DumLay:= M+ocflag
									Set Variable: DumLay:= MODFLOW_Layer(LayIndex, LayerTop, LayerBottom, ThisElevation)
									Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
										If: !(PeriodIndex>1&SteadyDrain=0)
											Redirect output to: TempDrainPer
												Start a new line
													Export expression: DumLay [I10]
													Export expression: DumRow [I10]
													Export expression: DumCol [I10]
													If: Area Drain Unit[LayIndex].On or Off Stress[PeriodIndex]
														Export expression: ThisElevation [E13.5]
													Else
														Export expression: 1.e49 [E13.5]
													End if
													Export expression: ContourArea*Area Drain Unit[LayIndex].Conductance; [E13.5]
													# MODPATH
													If: MODPATHChoice
														Export expression: Area Drain Unit[LayIndex].IFACE[PeriodIndex] [G0]
													End if
												End line
											End file
											Evaluate expression: MODFLOW_Join_Files("TempDrainPer" + PeriodIndex, "TempDrainPer", "TempDrainPer" + PeriodIndex)
										End if
									End loop
								End loop
							End if
						End if
						Set Variable: ThisConductance:= AREA Drain Unit[LayIndex].Conductance
						If: (!AreaBoundaryInBlock)&(ThisConductance!=$N/A)
							Set Variable: ThisElevation:= Area Drain Unit[LayIndex].Elevation
							Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
							Set Variable: LayerBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, DumCol, DumRow, LayIndex)
							# Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
							# Set Variable: ocflag:= 0
							# Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							# 	If: Area Drain Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Area Drain Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
							# 		Set Variable: ocflag:= DivIndex
							# 	End if
							# End loop
							# If: ocflag=0
							# 	Set Variable: ocflag:= 1
							# 	Set Variable: err_drn_4:= 1
							If: ShowWarnings&((ThisElevation>LayerTop)|(ThisElevation<LayerBottom))
								Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Area drain elevation does not lie within geologic unit: Area drain is placed in uppermost model layer in geologic unit.")
							End if
							# End if
							Set Variable: CurrentDrainCount:= CurrentDrainCount + 1
							Set Variable: ContourArea:= BlockArea()
							# Set Variable: DumLay:= M+ocflag
							Set Variable: DumLay:= MODFLOW_Layer(LayIndex, LayerTop, LayerBottom, ThisElevation)
							Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
								If: !(PeriodIndex>1&SteadyDrain=0)
									Redirect output to: TempDrainPer
										Start a new line
											Export expression: DumLay [I10]
											Export expression: DumRow [I10]
											Export expression: DumCol [I10]
											If: Area Drain Unit[LayIndex].On or Off Stress[PeriodIndex]
												Export expression: ThisElevation [E13.5]
											Else
												Export expression: 1.e49 [E13.5]
											End if
											Export expression: ContourArea*ThisConductance; [E13.5]
											# MODPATH
											If: MODPATHChoice
												Export expression: Area Drain Unit[LayIndex].IFACE[PeriodIndex] [G0]
											End if
										End line
									End file
									Evaluate expression: MODFLOW_Join_Files("TempDrainPer" + PeriodIndex, "TempDrainPer", "TempDrainPer" + PeriodIndex)
								End if
							End loop
						End if
					End if
				End loop
			End if
		End if
	End loop
	If: ContinueSimulation
		Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
			Redirect output to: TempDrain1
				If: PeriodIndex>1&SteadyDrain=0
					Start a new line
						Export expression: -1 [I5]
					End line
				Else
					Start a new line
						Export expression: CurrentDrainCount [I5]
					End line
				End if
			End file
			If: CurrentDrainCount>MaxDrains
				Set Variable: MaxDrains:= CurrentDrainCount
			End if
			If: !(PeriodIndex>1&SteadyDrain=0)
				Evaluate expression: MODFLOW_Join_Files("TempDrain1", "TempDrainPer" + PeriodIndex, "TempDrain1")
				Evaluate expression: MODFLOW_Delete_File("TempDrainPer" + PeriodIndex)
			End if
			Evaluate expression: MODFLOW_Join_Files("brook.drn", "TempDrain1", "brook.drn")
		End loop
		Redirect output to: TempDrain1
			Start a new line
				Export expression: MaxDrains [I5]
				If: IDRNCB>0&OneCBCFile=1
					Export expression: 33 [I5]
				End if
				If: IDRNCB>0&OneCBCFile=0
					Export expression: 27 [I5]
				End if
				If: IDRNCB=0
					Export expression: 0 [I5]
				End if
				# MODPATH
				If: MODPATHChoice
					Export expression: " AUXILIARY IFACE" [G0]
				End if
				# MOC3D CBC parameter
				If: TransportFlag=1 & Transport>0
					Export expression: " CBCALLOCATE" [G0]
				End if
			End line
		End file
		Evaluate expression: MODFLOW_Join_Files("TempDrain1", "brook.drn", "brook.drn")
		Evaluate expression: MODFLOW_Delete_File("TempDrain1")
		Evaluate expression: MODFLOW_Delete_File("TempDrainPer")
	End if
End if
#
# MF_WEL.met
# ----------------------------------------------------
# Well Package
# ----------------------------------------------------
If: ContinueSimulation&(WellChoice!=0&ExportWEL!=0)
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Well Package")
	Redirect output to: brook.wel
	End file
	Set Variable: MaxWells:= 0
	Set Variable: CurrentWellCount:= 0
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Set Variable: PointLayerIsEmpty:= IsLayerEmpty(Wells Unit[LayIndex].Top Elevation)
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation
			If: LayIndex=1
				Set Variable: M:= 0
			Else
				Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
			End if
			# 
			If: MODFLOW_SIMUL(LayIndex)
				# 
				Loop for: Blocks
					# 
					If: ContinueSimulation
						Set Variable: DumRow:= Row()
						Set Variable: DumCol:= Column()
						If: !PointLayerIsEmpty
							Loop for: Objects in layer: WELLS UNIT[LayIndex]
								Set Variable: WT:= Wells Unit[LayIndex].Top Elevation
								Set Variable: WB:= Wells Unit[LayIndex].Bottom Elevation
								# YBI: Pre calculate elevation top and thickness
								Set Variable: TempValue2:= Elevation Top Unit[LayIndex]
								Set Variable: TempValue4:= Elevation Bottom Unit[LayIndex]
								If: (WT>TempValue2)|(WT<=TempValue4)
									If: ShowWarnings
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Top Elevation in a well in Unit: " + LayIndex + "; Row: " + DumRow + "; Column: " + DumCol + " is outside the limits of the unit, it will be treated as if the top of the well screen were at the top of the unit.")
									End if
									Set Variable: WT:= TempValue2
								End if
								If: (WB>TempValue2)|(WB<TempValue4)
									If: ShowWarnings
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Bottom Elevation in a well in Unit: " + LayIndex + "; Row: " + DumRow + "; Column: " + DumCol + " is outside the limits of the unit, it will be treated as if the bottom of the well screen were at the bottom of the unit.")
									End if
									Set Variable: WB:= TempValue4
								End if
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Set Variable: DumLay:= M+DivIndex
									Set Variable: TempValue3:= (TempValue2-TempValue4)/MODFLOW_NDIV(LayIndex)
									Set Variable: TML:= TempValue2-(DivIndex-1)*TempValue3
									Set Variable: BML:= TempValue2-DivIndex*TempValue3
									If: ((WT>TML)&(WB>=TML))|WT<=BML
									Else
										Set Variable: ocflag:= 0
										If: (WT<=TML&WT>BML)&(WB<TML&WB>=BML)
											Set Variable: ocflag:= 1
											Set Variable: TempValue1:= WT-WB
										End if
										If: ocflag=0
											If: (WT<=TML&WT>BML)&(WB<=BML)
												Set Variable: ocflag:= 1
												Set Variable: TempValue1:= WT-BML
											End if
										End if
										If: ocflag=0
											If: (WT>=TML)&(WB<TML&WB>=BML)
												Set Variable: ocflag:= 1
												Set Variable: TempValue1:= TML-WB
											End if
										End if
										If: ocflag=0
											If: (WT>TML)&(WB<BML)
												Set Variable: ocflag:= 1
												Set Variable: TempValue1:= TML-BML
											End if
										End if
										Set Variable: CurrentWellCount:= CurrentWellCount + 1
										Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
											If: !(PeriodIndex>1&SteadyWell=0)
												Redirect output to: TempWellPer
													Set Variable: TempValue2:= TempValue1*Wells Unit[LayIndex].Stress[PeriodIndex]/(WT-WB)
													Start a new line
														Export expression: DumLay [I10]
														Export expression: DumRow [I10]
														Export expression: DumCol [I10]
														Export expression: TempValue2; [E13.5]
														# MODPATH
														If: MODPATHChoice
															Export expression: Wells Unit[LayIndex].IFACE[PeriodIndex] [G0]
														End if
														# MOC3D Data
														If: TransportFlag=1 & Transport>0
															Export expression: Wells Unit[LayIndex].Concentration[PeriodIndex] [E13.5]
														End if
													End line
												End file
												Evaluate expression: MODFLOW_Join_Files("TempWellPer" + PeriodIndex, "TempWellPer", "TempWellPer" + PeriodIndex)
											End if
										End loop
									End if
								End loop
							End loop
						End if
					End if
				End loop
			End if
		End if
	End loop
	If: ContinueSimulation
		If: CurrentWellCount > MaxWells
			Set Variable: MaxWells:= CurrentWellCount
		End if
		Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
			Redirect output to: TempWell1
				If: PeriodIndex>1&SteadyWell=0
					Start a new line
						Export expression: -1 [I5]
					End line
				Else
					Start a new line
						Export expression: CurrentWellCount [I5]
					End line
				End if
			End file
			If: !(PeriodIndex>1&SteadyWell=0)
				Evaluate expression: MODFLOW_Join_Files("TempWell1", "TempWellPer" + PeriodIndex, "TempWell1")
				Evaluate expression: MODFLOW_Delete_File("TempWellPer" + PeriodIndex)
			End if
			Evaluate expression: MODFLOW_Join_Files("brook.wel", "TempWell1", "brook.wel")
		End loop
		Evaluate expression: MODFLOW_Delete_File("TempWellPer")
		Redirect output to: TempWell1
			Start a new line
				Export expression: MaxWells [I5]
				If: IWELCB>0&OneCBCFile=1
					Export expression: 33 [I5]
				End if
				If: IWELCB>0&OneCBCFile=0
					Export expression: 29 [I5]
				End if
				If: IWELCB=0
					Export expression: 0 [I5]
				End if
				# MODPATH
				If: MODPATHChoice
					Export expression: " AUXILIARY IFACE" [G0]
				End if
				# MOC3D AUX parameter
				If: TransportFlag=1 & Transport>0
					Export expression: " CBCALLOCATE AUXILIARY CONCENTRATION" [G0]
				End if
			End line
		End file
		Evaluate expression: MODFLOW_Join_Files("TempWell1", "brook.wel", "brook.wel")
		Evaluate expression: MODFLOW_Delete_File("TempWell1")
	End if
	# 
End if
# 
# 
# MF_STR.met
# ----------------------------------------------------
# Stream Package
# ----------------------------------------------------
If: ContinueSimulation&(StreamChoice&ExportStreams)
	Redirect output to: brook.str
	End file
	Evaluate expression: MODFLOW_BL_InitializeGridInformation("MODFLOW FD Grid", 0)
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
			Evaluate expression: MODFLOW_BL_AddVertexLayer("Stream Unit" + LayIndex)
			Loop for: Objects in layer: Stream Unit[LayIndex]
				Evaluate expression: MODFLOW_L_AddToList(StreamSegmentList, Segment Number)
				Evaluate expression: MODFLOW_L_AddToList(SortedStreamSegmentList, Segment Number)
				Evaluate expression: MODFLOW_L_AddToList(StreamUnitList, LayIndex)
				If: UseDiversions
					Evaluate expression: MODFLOW_L_AddToList(StreamTributaryList, Stream Unit[LayIndex].Upstream Diversion Segment Number)
				End if
			End loop
		End if
	End loop
	Evaluate expression: MODFLOW_L_SortList(SortedStreamSegmentList)
	Evaluate expression: MODFLOW_L_EliminateDuplicates(SortedStreamSegmentList)
	Set Variable: StreamSegmentCount:= MODFLOW_L_GetListSize(SortedStreamSegmentList)
	Set Variable: Tributary2DArray:= MODFLOW_L_CreateNew3DList(StreamSegmentCount, TributaryMaxAllowed + 2, 1)
	Set Variable: StreamProperties3DArray:= MODFLOW_L_CreateNew3DList(StreamSegmentCount, MODFLOW_NPER()+1, InterpolateWidth+1)
	# 
	Set Variable: StreamIndex:= 0
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation&MODFLOW_SIMUL(LayIndex)!=0
			Loop for: Objects in layer: Stream Unit[LayIndex]
				If: ContourType()=2
					Evaluate expression: MODFLOW_L_Set3DListItem(Tributary2DArray, StreamIndex, TributaryMaxAllowed+1, 0, 1)
				End if
				Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
					Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, FlowIndex, Flow[PeriodIndex])
					Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, UpstreamStageIndex, Upstream Stage[PeriodIndex])
					If: Downstream Stage[PeriodIndex]!=$N/A
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, DownstreamStageIndex, Downstream Stage[PeriodIndex])
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateStage, 1)
					Else
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateStage, 0)
					End if
					Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, ConductivityIndex, Stream Unit[LayIndex].Streambed hydraulic conductivity)
					Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, UpstreamTopElevIndex, Upstream top elevation[PeriodIndex])
					If: Downstream top elevation[PeriodIndex]!=$N/A
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, DownstreamTopElevIndex, Downstream top elevation[PeriodIndex])
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateTopElev, 1)
					Else
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateTopElev, 0)
					End if
					Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, UpstreamBotElevIndex, Upstream bottom elevation[PeriodIndex])
					If: Downstream bottom elevation[PeriodIndex]!=$N/A
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, DownstreamBotElevIndex, Downstream bottom elevation[PeriodIndex])
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateBottomElev, 1)
					Else
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateBottomElev, 0)
					End if
					Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, UpstreamWidthIndex, Upstream width[PeriodIndex])
					If: Downstream width[PeriodIndex]!=$N/A
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, DownstreamWidthIndex, Downstream width[PeriodIndex])
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateWidth, 1)
					Else
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, InterpolateWidth, 0)
					End if
					If: ICALC
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, SlopeIndex, Slope[PeriodIndex])
						Evaluate expression: MODFLOW_L_Set3DListItem(StreamProperties3DArray, StreamIndex, PeriodIndex, RoughnessIndex, Mannings roughness[PeriodIndex])
					End if
				End loop
				Set Variable: StreamIndex:= StreamIndex+1
				If: UseTributaries
					If: Downstream Segment Number!=$N/A
						If: Downstream Segment Number>0
							Set Variable: TributaryIndex:= MODFLOW_L_UnsortedIndexOf(StreamSegmentList, Downstream Segment Number)
							If: TributaryIndex<0
								# Error
							Else
								Set Variable: TributaryCount:= MODFLOW_L_GetFrom3DList(Tributary2DArray, TributaryIndex, 0, 0)
								If: TributaryCount=TributaryMaxAllowed
									# Error
								Else
									Set Variable: TributaryCount:= TributaryCount + 1
									Evaluate expression: MODFLOW_L_Set3DListItem(Tributary2DArray, TributaryIndex, 0, 0, TributaryCount)
									Evaluate expression: MODFLOW_L_Set3DListItem(Tributary2DArray, TributaryIndex, TributaryCount, 0, TributaryIndex + 1)
									Evaluate expression: MODFLOW_L_Set3DListItem(Tributary2DArray, TributaryIndex, TributaryCount, 0, MODFLOW_L_UnsortedIndexOf(SortedStreamSegmentList, Segment Number) + 1)
								End if
							End if
						End if
					End if
				End if
			End loop
		End if
	End loop
	# 
	# 
	# Check for close contours or point objects. Display a warning if any are detected.
	If: ContinueSimulation&ShowWarnings&(StreamSegmentCount!=MODFLOW_L_GetListSize(StreamSegmentList))
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: One or more stream segment numbers are not unique.")
	End if
	If: ShowWarnings&ContinueSimulation
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
				Loop for: Objects in layer: Stream Unit[LayIndex]
					If: (ContourType()=1)
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: Point object on stream layer. Point Object Segment Number: " + Stream Unit[LayIndex].Segment Number)
					End if
					If: (ContourType()=3)
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: Close contour on stream layer. Close Contour Segment Number: " + Stream Unit[LayIndex].Segment Number)
					End if
				End loop
			End if
		End loop
	End if
	# 
	# Check that no segment numbers are equal to 0.
	If: ShowWarnings&ContinueSimulation
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
				Loop for: Objects in layer: Stream Unit[LayIndex]
					If: Segment Number=0
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: Stream segment number = 0 on non-simulated layer Stream Unit" + LayIndex + " will be ignored.")
					End if
				End loop
			End if
		End loop
	End if
	# 
	# Check that no stream widths are less than or equal to 0.
	If: ContinueSimulation&ShowWarnings
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
				Loop for: Objects in layer: Stream Unit[LayIndex]
					Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
						If: Upstream width[PeriodIndex]<=0
							Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: Upstream width[" + PeriodIndex+ "] <= 0 in Stream Unit" + LayIndex)
						End if
						If: IsNumber(Downstream width[PeriodIndex])
							If: Downstream width[PeriodIndex]<=0
								Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: Downstream width[" + PeriodIndex+ "] <= 0 in Stream Unit" + LayIndex)
							End if
						End if
					End loop
					If: Segment Number=0
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: Stream segment number = 0 on non-simulated layer Stream Unit" + LayIndex + " will be ignored.")
					End if
				End loop
			End if
		End loop
	End if
	# 
	# Check that no two segments have the same segment number.
	If: ContinueSimulation&ShowWarnings
		Loop for: Variable SegmentIndex from: 0 to: StreamSegmentCount-1 step: 1
			If: MODFLOW_L_UnsortedIndexOf(StreamSegmentList, MODFLOW_L_GetFromList(StreamSegmentList, SegmentIndex))!=SegmentIndex
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error: Two or more Stream segments are assigned segment numbers of " + MODFLOW_L_GetFromList(StreamSegmentList, StreamIndex))
			End if
		End loop
	End if
	# 
	# Check that all downstream segments have higher segment numbers than upsteam segments.
	Set Variable: not_ok:= 0
	If: ContinueSimulation&ShowWarnings
		If: UseTributaries
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
					Loop for: Objects in layer: Stream Unit[LayIndex]
						If: (Downstream Segment Number<=Segment Number)&(Segment Number!=0)&(Downstream Segment Number!=0)
							Set Variable: not_ok:= 1
							Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Stream Segment Number " + Stream Unit[LayIndex].Segment Number + " has a downstream segment number " + Stream Unit[LayIndex].Downstream Segment Number + ".  Downstream segments must be higher than upstream segments.")
						End if
					End loop
				End if
			End loop
		End if
	End if
	# 
	# Check that all diversion segments have higher segment numbers than upsteam segments.
	If: ContinueSimulation&ShowWarnings
		If: UseDiversions
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
					Loop for: Objects in layer: Stream Unit[LayIndex]
						If: (Upstream Diversion Segment Number>=Segment Number)&(Segment Number!=0)&(Upstream Diversion Segment Number!=0)
							Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Segment Number " + Stream Unit[LayIndex].Segment Number + " is a diversion but it has a higher segment that the segment from which flow is diverted (" + Stream Unit[LayIndex].Upstream Diversion Segment Number + ").")
						End if
					End loop
				End if
			End loop
		End if
	End if
	# 
	# Check that all stream tops are higher than the corresponding stream bottoms.
	Set Variable: not_ok:= 0
	If: ContinueSimulation&ShowWarnings
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
				Loop for: Objects in layer: Stream Unit[LayIndex]
					Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
						If: (PeriodIndex=1)|!StreamsSteady
							Set Variable: StreamTop:= Upstream top elevation[PeriodIndex]
							Set Variable: StreamBottom:= Upstream bottom elevation[PeriodIndex]
							If: (StreamTop<=StreamBottom)
								Set Variable: not_ok:= 1
								Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Top <= Bottom in Stream Segment " + Stream Unit[LayIndex].Segment Number + " for period " + PeriodIndex)
							End if
							If: Downstream top elevation[PeriodIndex]!=$N/A
								Set Variable: StreamTop:= Downstream top elevation[PeriodIndex]
							End if
							If: Downstream bottom elevation[PeriodIndex]!=$N/A
								Set Variable: StreamBottom:= Downstream bottom elevation[PeriodIndex]
							End if
							If: (StreamTop<StreamBottom)&(Segment Number!=0)
								Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Top < Bottom in Stream Segment " + Stream Unit[LayIndex].Segment Number + " for period " + PeriodIndex)
							End if
						End if
					End loop
				End loop
			End if
		End loop
	End if
	# 
	# Check that all stream stages are higher than the corresponding stream bottoms.
	If: ContinueSimulation&ShowWarnings
		If: !ICALC
			Set Variable: not_ok:= 0
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
					Loop for: Objects in layer: Stream Unit[LayIndex]
						Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
							If: (PeriodIndex=1)|(!StreamsSteady)
								Set Variable: StreamStage:= Upstream Stage[PeriodIndex]
								Set Variable: StreamBottom:= Upstream bottom elevation[PeriodIndex]
								If: (StreamStage<StreamBottom)&(Segment Number!=0)
									Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Stage < Bottom in Stream Segment " + Stream Unit[LayIndex].Segment Number)
								End if
								If: Downstream Stage[PeriodIndex]!=$N/A
									Set Variable: StreamStage:= Downstream Stage[PeriodIndex]
								End if
								If: Downstream bottom elevation[PeriodIndex]!=$N/A
									Set Variable: StreamBottom:= Downstream bottom elevation[PeriodIndex]
								End if
								If: (StreamStage<StreamBottom)&(Segment Number!=0)
									Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Stage < Bottom in Stream Segment " + Stream Unit[LayIndex].Segment Number)
								End if
							End if
						End loop
					End loop
				End if
			End loop
		End if
	End if
	# 
	# Check that all stream stages are higher than the corresponding stream tops.
	If: ContinueSimulation&ShowWarnings
		If: !ICALC
			Set Variable: not_ok:= 0
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
					Loop for: Objects in layer: Stream Unit[LayIndex]
						Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
							If: (PeriodIndex =1)|(!StreamsSteady)
								Set Variable: StreamTop:= Upstream top elevation[PeriodIndex]
								Set Variable: StreamStage:= Upstream Stage[PeriodIndex]
								If: (StreamStage<StreamTop)&(Segment Number!=0)&(ICALC<=0)
									Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Stage < Top in Stream Segment " + Stream Unit[LayIndex].Segment Number)
								End if
								If: Downstream top elevation[PeriodIndex]!=$N/A
									Set Variable: StreamTop:= Downstream top elevation[PeriodIndex]
								End if
								If: Downstream Stage[PeriodIndex]!=$N/A
									Set Variable: StreamStage:= Downstream Stage[PeriodIndex]
								End if
								If: (StreamStage<StreamTop)&(Segment Number!=0)&(ICALC<=0)
									Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Stage < Top in Stream Segment " + Stream Unit[LayIndex].Segment Number)
								End if
							End if
						End loop
					End loop
				End if
			End loop
		End if
	End if
	# 
	# Check that all downstream segments exist.
	If: ContinueSimulation&ShowWarnings
		If: UseTributaries
			Set Variable: not_ok:= 0
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
					Loop for: Objects in layer: Stream Unit[LayIndex]
						If: Downstream Segment Number!=$N/A
							If: !(Downstream Segment Number=0)
								If: MODFLOW_L_UnsortedIndexOf(SortedStreamSegmentList, Downstream Segment Number)<0
									Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("The downstream segment for stream segment " + Stream Unit[LayIndex].Segment Number + " does not exist.")
								End if
							End if
						End if
					End loop
				End if
			End loop
		End if
	End if
	# 
	If: ContinueSimulation&ShowWarnings
		If: UseDiversions
			# Check that all upstream segments for diversions exist.
			Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
				If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)!=0)
					Loop for: Objects in layer: Stream Unit[LayIndex]
						If: Upstream Diversion Segment Number!=$N/A
							If: !(Upstream Diversion Segment Number=0)
								If: MODFLOW_L_UnsortedIndexOf(SortedStreamSegmentList, Upstream Diversion Segment Number)<0
									Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("In Stream segment " + Stream Unit[LayIndex].Segment Number + ", the segment from which flow is to be diverted (" + Stream Unit[LayIndex].Upstream Diversion Segment Number + ") does not exist.")
								End if
							End if
						End if
					End loop
				End if
			End loop
		End if
	End if
	# 
	# Check that no objects are on non-simulated layers
	If: ContinueSimulation&ShowWarnings
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation&(MODFLOW_SIMUL(LayIndex)=0)
				Set Variable: TempInteger:= 0
				Loop for: Objects in layer: Stream Unit[LayIndex]
					Set Variable: TempInteger:= TempInteger+1
				End loop
				If: TempInteger>0
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: Streams on non-simulated layer " + LayIndex + " will be ignored.")
				End if
			End if
		End loop
	End if
	Set Variable: NTRIB:= 0
	If: ContinueSimulation&UseTributaries
		Loop for: Variable StreamIndex from: 0 to: StreamSegmentCount-1 step: 1
			Set Variable: NTRIBCurrent:= MODFLOW_L_GetFrom3DList(Tributary2DArray, StreamIndex, 0, 0)
			If: NTRIBCurrent>NTRIB
				Set Variable: NTRIB:= NTRIBCurrent
			End if
		End loop
	End if
	If: ContinueSimulation&UseDiversions
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation&MODFLOW_SIMUL(LayIndex)
				Loop for: Objects in layer: Stream Unit[LayIndex]
					If: Upstream Diversion Segment Number>0
						Set Variable: NDIV:= 1
					End if
				End loop
			End if
		End loop
	End if
	Set Variable: MaxStreamReachCount:= 0
	Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation
			Set Variable: CurrentStreamReachCount:= 0
			Redirect output to: TempStream3
				Loop for: Variable StreamIndex from: 0 to: StreamSegmentCount-1 step: 1
					Set Variable: CurrentStream:= MODFLOW_L_GetFromList(SortedStreamSegmentList, StreamIndex)
					Set Variable: StreamIndex2:= MODFLOW_L_UnsortedIndexOf(StreamSegmentList, CurrentStream)
					# StreamIndex2 is now the index of the current stream segment and may be used to retrieve data about the current stream.
					Set Variable: BlockListCount:= MODFLOW_BL_GetCountOfACellList(StreamIndex2)
					If: BlockListCount>0
						Loop for: Variable BlockIndex from: 0 to: BlockListCount-1 step: 1
							Set Variable: StreamUnit:= MODFLOW_L_GetFromList(StreamUnitList, StreamIndex2)
							Set Variable: DumRow:= MODFLOW_BL_GetCellRow(StreamIndex2, BlockIndex)
							Set Variable: DumCol:= MODFLOW_BL_GetCellColumn(StreamIndex2, BlockIndex)
							Set Variable: BlockBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, DumCol, DumRow, StreamUnit)
							Set Variable: BlockTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, StreamUnit)
							Set Variable: StreamBottom:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, UpstreamBotElevIndex)
							If: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, InterpolateBottomElev)
								Set Variable: DownstreamStreamBottom:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, DownstreamBotElevIndex)
								Set Variable: StreamBottom:= StreamBottom - MODFLOW_BL_FractionOfLine(StreamIndex2, BlockIndex) * (StreamBottom - DownstreamStreamBottom)
							End if
							Set Variable: StreamStage:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, UpstreamStageIndex)
							Set Variable: StreamConductance:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, ConductivityIndex) * MODFLOW_BL_SumSegmentLengths(StreamIndex2, BlockIndex)
							If: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, InterpolateStage)
								Set Variable: DownstreamStreamStage:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, DownstreamStageIndex)
								Set Variable: StreamStage:= StreamStage - MODFLOW_BL_FractionOfLine(StreamIndex2, BlockIndex) * (StreamStage - DownstreamStreamStage)
							End if
							Set Variable: Width:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, UpstreamWidthIndex)
							If: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, InterpolateWidth)
								Set Variable: DownstreamWidth:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, DownstreamWidthIndex)
								Set Variable: Width:= Width - MODFLOW_BL_FractionOfLine(StreamIndex2, BlockIndex) * (Width - DownstreamWidth)
							End if
							Set Variable: StreamTop:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, UpstreamTopElevIndex)
							If: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, InterpolateTopElev)
								Set Variable: DownstreamStreamTop:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, DownstreamTopElevIndex)
								Set Variable: StreamTop:= StreamTop - MODFLOW_BL_FractionOfLine(StreamIndex2, BlockIndex) * (StreamTop - DownstreamStreamTop)
							End if
							Set Variable: StreamConductance:= StreamConductance * Width / (StreamTop - StreamBottom)
							Set Variable: CurrentStreamReachCount:= CurrentStreamReachCount + 1
							If: StreamsSteady
								Set Variable: Flow:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, 1, FlowIndex)
							Else
								Set Variable: Flow:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, FlowIndex)
							End if
							Start a new line
								Export expression: MODFLOW_Layer(StreamUnit, BlockTop, BlockBottom, StreamBottom) [I5]
								Export expression: DumRow [I5]
								Export expression: DumCol [I5]
								Export expression: StreamIndex + 1 [I5]
								Export expression: BlockIndex + 1 [I5]
								Export expression: Flow; [G15]
								Export expression: StreamStage; [G9]
								Export expression: StreamConductance; [G9]
								Export expression: StreamBottom; [G9]
								Export expression: StreamTop [G9]
							End line
						End loop
					End if
				End loop
				If: ICALC
					Loop for: Variable StreamIndex from: 0 to: StreamSegmentCount-1 step: 1
						Set Variable: CurrentStream:= MODFLOW_L_GetFromList(SortedStreamSegmentList, StreamIndex)
						Set Variable: StreamIndex2:= MODFLOW_L_UnsortedIndexOf(StreamSegmentList, CurrentStream)
						# StreamIndex2 is now the index of the current stream segment and may be used to retrieve data about the current stream.
						Set Variable: BlockListCount:= MODFLOW_BL_GetCountOfACellList(StreamIndex2)
						If: BlockListCount>0
							Loop for: Variable BlockIndex from: 0 to: BlockListCount-1 step: 1
								Set Variable: Width:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, UpstreamWidthIndex)
								If: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, InterpolateWidth)
									Set Variable: DownstreamWidth:= MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, DownstreamWidthIndex)
									Set Variable: Width:= Width - MODFLOW_BL_FractionOfLine(StreamIndex2, BlockIndex) * (Width - DownstreamWidth)
								End if
								Start a new line
									Export expression: Width [G10]
									Export expression: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, SlopeIndex) [G10]
									Export expression: MODFLOW_L_GetFrom3DList(StreamProperties3DArray, StreamIndex2, PeriodIndex, RoughnessIndex) [G10]
								End line
							End loop
						End if
					End loop
				End if
				If: NTRIB
					Loop for: Variable StreamIndex from: 0 to: StreamSegmentCount-1 step: 1
						Set Variable: CurrentStream:= MODFLOW_L_GetFromList(SortedStreamSegmentList, StreamIndex)
						Set Variable: StreamIndex2:= MODFLOW_L_UnsortedIndexOf(StreamSegmentList, CurrentStream)
						# StreamIndex2 is now the index of the current stream segment and may be used to retrieve data about the current stream.
						Start a new line
							# Loop for: Variable TributaryIndex from: 1 to: NTRIB step: 1
							Loop for: Variable TributaryIndex from: 1 to: 10 step: 1
								Export expression: MODFLOW_L_GetFrom3DList(Tributary2DArray, StreamIndex2, TributaryIndex , 0) [I5]
							End loop
						End line
					End loop
				End if
				If: NDIV
					Loop for: Variable StreamIndex from: 0 to: StreamSegmentCount-1 step: 1
						Set Variable: CurrentStream:= MODFLOW_L_GetFromList(SortedStreamSegmentList, StreamIndex)
						Set Variable: StreamIndex2:= MODFLOW_L_UnsortedIndexOf(StreamSegmentList, CurrentStream)
						# StreamIndex2 is now the index of the current stream segment and may be used to retrieve data about the current stream.
						Start a new line
							Export expression: MODFLOW_L_GetFromList(StreamTributaryList, StreamIndex2) [I10]
						End line
					End loop
				End if
			End file
			If: CurrentStreamReachCount>MaxStreamReachCount
				Set Variable: MaxStreamReachCount:= CurrentStreamReachCount
			End if
			Redirect output to: TempStream2
				Start a new line
					Export expression: CurrentStreamReachCount [I10]
					Export expression: 0 [I10]
					Export expression: 0 [I10]
				End line
			End file
			Evaluate expression: MODFLOW_Join_Files("TempStream2", "TempStream3", "TempStream2")\n
			Evaluate expression: MODFLOW_Join_Files("brook.str", "TempStream2", "brook.str")\n
		End if
	End loop
	If: ContinueSimulation
		Redirect output to: TempStream1
			Start a new line
				Export expression: MaxStreamReachCount [I10]
				Export expression: StreamSegmentCount [I10]
				Export expression: NTRIB [I10]
				Export expression: NDIV [I10]
				Export expression: ICALC [I10]
				Export expression: StreamCONST [G10]
				If: ISTCB1>0&OneCBCFile=1
					Export expression: 33 [I10]
				End if
				If: ISTCB1>0&OneCBCFile=0
					Export expression: 36 [I10]
				End if
				If: ISTCB1=0
					Export expression: -1 [I10]
				End if
				If: ISTCB2>0
					Export expression: 37 [I10]
				End if
				If: ISTCB2=0
					Export expression: 0 [I10]
				End if
			End line
		End file
		Evaluate expression: MODFLOW_Join_Files("TempStream1", "brook.str", "brook.str")\n
		Evaluate expression: MODFLOW_Delete_File("TempStream1")
		Evaluate expression: MODFLOW_Delete_File("TempStream2")
		Evaluate expression: MODFLOW_Delete_File("TempStream3")
	End if
End if
# 
# 
# MF_HFB.met
# ----------------------------------------------------
# Horizontal Flow Barrier Package
# ----------------------------------------------------
If: ContinueSimulation&HFBChoice&ExportHFB
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Horizontal Flow Barrier Package")
	Evaluate expression: MODFLOW_Delete_File("temphfb1")
	Evaluate expression: MODFLOW_Delete_File("temphfb2")
	Evaluate expression: MODFLOW_Delete_File("temphfb3")
	Redirect output to: brook.hfb
	End file
	Set Variable: TotalBarrierCount:= 0
	Evaluate expression: MODFLOW_BL_InitializeGridInformation("MODFLOW FD Grid")
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation&MODFLOW_SIMUL(LayIndex)
			Redirect output to: TempHFB3
				Evaluate expression: MODFLOW_BL_ReInitializeVertexList()
				Evaluate expression: MODFLOW_BL_AddVertexLayer("Horizontal Flow Barrier Unit" + LayIndex)
				Set Variable: CurrentBarrierCount:= 0
				If: MODFLOW_BL_GetCountOfCrossColumnLists()
					Set Variable: BarrierIndex:= -1
					Loop for: Objects in layer: Horizontal Flow Barrier Unit[LayIndex]
						Set Variable: BarrierIndex:= BarrierIndex + 1
						If: MODFLOW_BL_GetCountOfACrossColumnList(BarrierIndex)
							Loop for: Variable CellIndex from: 0 to: MODFLOW_BL_GetCountOfACrossColumnList(BarrierIndex)-1 step: 1
								Set Variable: Row1:= MODFLOW_BL_GetCrossColumnRow(BarrierIndex, CellIndex)
								Set Variable: Row2:= MODFLOW_BL_GetCrossColumnNeighborRow(BarrierIndex, CellIndex)
								Set Variable: Column1:= MODFLOW_BL_GetCrossColumnColumn(BarrierIndex, CellIndex)
								Set Variable: Column2:= Column1
								If: !((Row2>RowCount)|(Row2<1))
									If: (MODFLOW_LAYCON(LayIndex)=0)|(MODFLOW_LAYCON(LayIndex)=2)
										# need to take into account multiple layer per unit
										Set Variable: AverageCellThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column1, Row1, LayIndex)
										Set Variable: HYDCHR:= Barrier Hydraulic Conductivity * AverageCellThickness / Barrier Thickness
									Else
										Set Variable: HYDCHR:= Barrier Hydraulic Conductivity / Barrier Thickness
									End if
									Set Variable: HYDCHR:= HYDCHR * Abs(MODFLOW_BL_GetCrossColumnCompositeX(BarrierIndex, CellIndex) / MODFLOW_BL_GetCrossColumnCompositeLength(BarrierIndex, CellIndex))
									Set Variable: CurrentBarrierCount:= CurrentBarrierCount + 1
									Start a new line
										Export expression: Row1 [I10]
										Export expression: Column1 [I10]
										Export expression: Row2 [I10]
										Export expression: Column2 [I10]
										Export expression: HYDCHR [G10]
									End line
								End if
							End loop
						End if
					End loop
				End if
				If: MODFLOW_BL_GetCountOfCrossRowLists()
					Set Variable: BarrierIndex:= -1
					Loop for: Objects in layer: Horizontal Flow Barrier Unit[LayIndex]
						Set Variable: BarrierIndex:= BarrierIndex + 1
						If: MODFLOW_BL_GetCountOfACrossRowList(BarrierIndex)
							Loop for: Variable CellIndex from: 0 to: MODFLOW_BL_GetCountOfACrossRowList(BarrierIndex)-1 step: 1
								Set Variable: Row1:= MODFLOW_BL_GetCrossRowRow(BarrierIndex, CellIndex)
								Set Variable: Row2:= Row1
								Set Variable: Column1:= MODFLOW_BL_GetCrossRowColumn(BarrierIndex, CellIndex)
								Set Variable: Column2:= MODFLOW_BL_GetCrossRowNeighborColumn(BarrierIndex, CellIndex)
								If: !((Column2>ColumnCount)|(Column2<1))
									If: (MODFLOW_LAYCON(LayIndex)=0)|(MODFLOW_LAYCON(LayIndex)=2)
										Set Variable: AverageCellThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column1, Row1, LayIndex)
										Set Variable: HYDCHR:= Horizontal Flow Barrier Unit[LayIndex].Barrier Hydraulic Conductivity * AverageCellThickness / Horizontal Flow Barrier Unit[LayIndex].Barrier Thickness
									Else
										Set Variable: HYDCHR:= Horizontal Flow Barrier Unit[LayIndex].Barrier Hydraulic Conductivity / Horizontal Flow Barrier Unit[LayIndex].Barrier Thickness
									End if
									Set Variable: HYDCHR:= HYDCHR * Abs(MODFLOW_BL_GetCrossRowCompositeY(BarrierIndex, CellIndex) / MODFLOW_BL_GetCrossRowCompositeLength(BarrierIndex, CellIndex))
									Set Variable: CurrentBarrierCount:= CurrentBarrierCount + 1
									Start a new line
										Export expression: Row1 [I10]
										Export expression: Column1 [I10]
										Export expression: Row2 [I10]
										Export expression: Column2 [I10]
										Export expression: HYDCHR [G10]
									End line
								End if
							End loop
						End if
					End loop
				End if
				Evaluate expression: MODFLOW_BL_ReInitializeVertexList()
			End file
			Redirect output to: temphfb2
				Start a new line
					Export expression: CurrentBarrierCount [I10]
				End line
			End file
			Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
				Set Variable: TotalBarrierCount:= TotalBarrierCount + CurrentBarrierCount
				Evaluate expression: MODFLOW_Join_Files("brook.hfb", "temphfb2", "brook.hfb")
				Evaluate expression: MODFLOW_Join_Files("brook.hfb", "temphfb3", "brook.hfb")
			End loop
		End if
	End loop
	If: ContinueSimulation
		Redirect output to: temphfb1
			Start a new line
				Export expression: TotalBarrierCount [I10]
			End line
		End file
		Evaluate expression: MODFLOW_Join_Files("temphfb1", "brook.hfb", "brook.hfb")
		Evaluate expression: MODFLOW_Delete_File("temphfb1")
		Evaluate expression: MODFLOW_Delete_File("temphfb2")
		Evaluate expression: MODFLOW_Delete_File("temphfb3")
	End if
End if
# 
# 
# MF_FHB.met
# ----------------------------------------------------
# FHB Package
# ----------------------------------------------------
If: ContinueSimulation&FlowHeadChoice&ExportFHB
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Flow and Head Boundary Package")
	Evaluate expression: MODFLOW_BL_InitializeGridInformation("MODFLOW FD Grid")
	# initialize output file to an empty file
	Redirect output to: brook.fhb
	End file
	Set Variable: FlowBoundaryCount:= 0
	Set Variable: HeadBoundaryCount:= 0
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
		If: ContinueSimulation
			If: LayIndex=1
				Set Variable: M:= 0
			Else
				Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
			End if
			# 
			If: MODFLOW_SIMUL(LayIndex)!=0
				Evaluate expression: MODFLOW_BL_FreeVertexList()
				Evaluate expression: MODFLOW_BL_AddVertexLayer("Line FHB Unit" + LayIndex)
				# 
				Redirect output to: TempFHB5Line$LOOP$
					Set Variable: ContourIndex:= -1
					Loop for: Objects in layer: Line FHB Unit[LayIndex]
						Set Variable: ContourIndex:= ContourIndex + 1
						If: (Line FHB Unit[LayIndex].Flux per Length Time1!=$N/A)&MODFLOW_BL_GetCountOfACellList(ContourIndex)>0
							If: ShowWarnings&(Line FHB Unit[LayIndex].Start_Line Head Time1!=$N/A)
								Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: In Line FHB Unit" + LayIndex + ", both a specified head and specified flux are defined for the same contour. MODFLOW will ignore the specified flux." )
							End if
							Set Variable: TopUnitElev:= Elevation Top Unit[LayIndex]
							Set Variable: BottomUnitElev:= Elevation Bottom Unit[LayIndex]
							Set Variable: UnitThickness:= TopUnitElev - BottomUnitElev
							Set Variable: TopContourElev:= Line FHB Unit[LayIndex].Top Elev
							Set Variable: BottomContourElev:= Line FHB Unit[LayIndex].Bottom Elev
							If: TopContourElev>TopUnitElev
								Set Variable: TopContourElev:= TopUnitElev
								If: ShowWarnings
									Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("On the Line FHB Unit" + LayIndex + " layer, the top elevation (" + TopContourElev + ") is above the top of the unit (" + TopUnitElev + "). The top of the unit will be used instead.")
								End if
							End if
							If: BottomContourElev<BottomUnitElev
								Set Variable: BottomContourElev:= BottomUnitElev
								If: ShowWarnings
									Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("On the Line FHB Unit" + LayIndex + " layer, the bottom elevation (" + BottomContourElev + ") is below the bottom of the unit (" + BottomUnitElev + "). The bottom of the unit will be used instead.")
								End if
							End if
							Set Variable: ContourThickness:= TopContourElev - BottomContourElev
							# Error test check ContourThickness < 0
							If: ContourThickness=0
								Loop for: Variable CellIndex from: 0 to: MODFLOW_BL_GetCountOfACellList(ContourIndex) - 1 step: 1
									Set Variable: FlowBoundaryCount:= FlowBoundaryCount + 1
									Start a new line
										Export expression: MODFLOW_Layer(LayIndex, TopUnitElev, BottomUnitElev, TopContourElev); [G0]
										Export expression: MODFLOW_BL_GetCellRow(ContourIndex, CellIndex); [G0]
										Export expression: MODFLOW_BL_GetCellColumn(ContourIndex, CellIndex); [G0]
										Export expression: 0; [G0]
										Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
											Export expression: Line FHB Unit[LayIndex].Flux per Length Time[PeriodIndex] * MODFLOW_BL_SumSegmentLengths(ContourIndex, CellIndex); [G0]
										End loop
									End line
								End loop
							Else
								Loop for: Variable CellIndex from: 0 to: MODFLOW_BL_GetCountOfACellList(ContourIndex) - 1 step: 1
									If: MODFLOW_BL_SumSegmentLengths(ContourIndex, CellIndex)>0
										Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
											Set Variable: DumLay:= M+DivIndex
											Set Variable: TopDivElev:= TopUnitElev - (DivIndex - 1) * UnitThickness
											Set Variable: BottomDivElev:= TopUnitElev - DivIndex * UnitThickness
											Set Variable: DivThickness:= TopDivElev - BottomDivElev
											Set Variable: TopContourInDiv:= TopContourElev
											If: TopContourInDiv>TopDivElev
												Set Variable: TopContourInDiv:= TopDivElev
											End if
											Set Variable: BottomContourInDiv:= BottomContourElev
											If: BottomContourInDiv<BottomDivElev
												Set Variable: BottomContourInDiv:= BottomDivElev
											End if
											Set Variable: ThicknessContourInDiv:= TopContourInDiv - BottomContourInDiv
											If: ThicknessContourInDiv>0
												Set Variable: FlowBoundaryCount:= FlowBoundaryCount + 1
												Start a new line
													Export expression: DumLay; [G0]
													Export expression: MODFLOW_BL_GetCellRow(ContourIndex, CellIndex); [G0]
													Export expression: MODFLOW_BL_GetCellColumn(ContourIndex, CellIndex); [G0]
													Export expression: 0; [G0]
													Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
														Export expression: Line FHB Unit[LayIndex].Flux per Length Time[PeriodIndex] * MODFLOW_BL_SumSegmentLengths(ContourIndex, CellIndex) * ThicknessContourInDiv / DivThickness; [G0]
													End loop
												End line
											End if
										End loop
									End if
								End loop
								# End if
							End if
						End if
					End loop
					# 
				End file
				# 
				If: TransportFlag=1 & Transport>0
					Redirect output to: TempFHB6Line$LOOP$
						Set Variable: ContourIndex:= -1
						Loop for: Objects in layer: Line FHB Unit[LayIndex]
							Set Variable: ContourIndex:= ContourIndex + 1
							If: (Line FHB Unit[LayIndex].Flux per Length Time1!=$N/A)&MODFLOW_BL_GetCountOfACellList(ContourIndex)>0
								Set Variable: TopUnitElev:= Elevation Top Unit[LayIndex]
								Set Variable: BottomUnitElev:= Elevation Bottom Unit[LayIndex]
								Set Variable: UnitThickness:= TopUnitElev - BottomUnitElev
								Set Variable: TopContourElev:= Line FHB Unit[LayIndex].Top Elev
								Set Variable: BottomContourElev:= Line FHB Unit[LayIndex].Bottom Elev
								If: TopContourElev>TopUnitElev
									Set Variable: TopContourElev:= TopUnitElev
									If: ShowWarnings
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("On the Line FHB Unit" + LayIndex + " layer, the top elevation (" + TopContourElev + ") is above the top of the unit (" + TopUnitElev + "). The top of the unit will be used instead.")
									End if
								End if
								If: BottomContourElev<BottomUnitElev
									Set Variable: BottomContourElev:= BottomUnitElev
									If: ShowWarnings
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("On the Line FHB Unit" + LayIndex + " layer, the bottom elevation (" + BottomContourElev + ") is below the bottom of the unit (" + BottomUnitElev + "). The bottom of the unit will be used instead.")
									End if
								End if
								Set Variable: ContourThickness:= TopContourElev - BottomContourElev
								If: ContourThickness=0
									Loop for: Variable CellIndex from: 0 to: MODFLOW_BL_GetCountOfACellList(ContourIndex) - 1 step: 1
										Start a new line
											Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
												Export expression: Line FHB Unit[LayIndex].Flux Concentration Time[PeriodIndex]; [G0]
											End loop
										End line
									End loop
								Else
									# If: (Line FHB Unit[LayIndex].Flux per Length Time1!=$N/A)&MODFLOW_BL_GetCountOfACellList(ContourIndex)>0
									Loop for: Variable CellIndex from: 0 to: MODFLOW_BL_GetCountOfACellList(ContourIndex) - 1 step: 1
										If: MODFLOW_BL_SumSegmentLengths(ContourIndex, CellIndex)>0
											Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
												Set Variable: DumLay:= M+DivIndex
												Set Variable: TopDivElev:= TopUnitElev - (DivIndex - 1) * UnitThickness
												Set Variable: BottomDivElev:= TopUnitElev - DivIndex * UnitThickness
												Set Variable: DivThickness:= TopDivElev - BottomDivElev
												Set Variable: TopContourInDiv:= TopContourElev
												If: TopContourInDiv>TopDivElev
													Set Variable: TopContourInDiv:= TopDivElev
												End if
												Set Variable: BottomContourInDiv:= BottomContourElev
												If: BottomContourInDiv<BottomDivElev
													Set Variable: BottomContourInDiv:= BottomDivElev
												End if
												Set Variable: ThicknessContourInDiv:= TopContourInDiv - BottomContourInDiv
												If: ThicknessContourInDiv>0
													Start a new line
														Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
															Export expression: Line FHB Unit[LayIndex].Flux Concentration Time[PeriodIndex]; [G0]
														End loop
													End line
												End if
											End loop
										End if
									End loop
									# End if
								End if
							End if
						End loop
						# 
					End file
				End if
				Redirect output to: TempFHB7Line$LOOP$
					# 
					Set Variable: ContourIndex:= -1
					Loop for: Objects in layer: Line FHB Unit[LayIndex]
						Set Variable: ContourIndex:= ContourIndex + 1
						If: (Line FHB Unit[LayIndex].Start_Line Head Time1!=$N/A)&MODFLOW_BL_GetCountOfACellList(ContourIndex)>0
							Set Variable: TopUnitElev:= Elevation Top Unit[LayIndex]
							Set Variable: BottomUnitElev:= Elevation Bottom Unit[LayIndex]
							Set Variable: TopLayer:= MODFLOW_Layer(LayIndex, TopUnitElev, BottomUnitElev, Line FHB Unit[LayIndex].Top Elev)
							Set Variable: BottomLayer:= MODFLOW_Layer(LayIndex, TopUnitElev, BottomUnitElev, Line FHB Unit[LayIndex].Bottom Elev)
							If: (Line FHB Unit[LayIndex].Start_Line Head Time1!=$N/A)
								Loop for: Variable CellIndex from: 0 to: MODFLOW_BL_GetCountOfACellList(ContourIndex) - 1 step: 1
									If: MODFLOW_BL_SumSegmentLengths(ContourIndex, CellIndex)>0
										Set Variable: LineFraction:= MODFLOW_BL_FractionOfLine(ContourIndex, CellIndex)
										Loop for: Variable DivIndex from: TopLayer to: BottomLayer step: 1
											Set Variable: HeadBoundaryCount:= HeadBoundaryCount + 1
											Start a new line
												Export expression: DivIndex; [G0]
												Export expression: MODFLOW_BL_GetCellRow(ContourIndex, CellIndex); [G0]
												Export expression: MODFLOW_BL_GetCellColumn(ContourIndex, CellIndex); [G0]
												Export expression: 0; [G0]
												Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
													Set Variable: SBHED:= Line FHB Unit[LayIndex].Start_Line Head Time[PeriodIndex]
													Set Variable: EndSBHED:= Line FHB Unit[LayIndex].End_Line Head Time[PeriodIndex]
													If: IsNumber(EndSBHED)
														Set Variable: SBHED:= SBHED - (SBHED - EndSBHED) * LineFraction
													End if
													Export expression: SBHED; [G0]
												End loop
											End line
										End loop
									End if
								End loop
							End if
						End if
					End loop
					# 
					# 
				End file
				If: TransportFlag=1 & Transport>0
					Redirect output to: TempFHB8Line$LOOP$
						# 
						Set Variable: ContourIndex:= -1
						Loop for: Objects in layer: Line FHB Unit[LayIndex]
							Set Variable: ContourIndex:= ContourIndex + 1
							If: (Line FHB Unit[LayIndex].Start_Line Head Time1!=$N/A)&MODFLOW_BL_GetCountOfACellList(ContourIndex)>0
								Set Variable: TopUnitElev:= Elevation Top Unit[LayIndex]
								Set Variable: BottomUnitElev:= Elevation Bottom Unit[LayIndex]
								Set Variable: TopLayer:= MODFLOW_Layer(LayIndex, TopUnitElev, BottomUnitElev, Line FHB Unit[LayIndex].Top Elev)
								Set Variable: BottomLayer:= MODFLOW_Layer(LayIndex, TopUnitElev, BottomUnitElev, Line FHB Unit[LayIndex].Bottom Elev)
								Set Variable: ContourIndex:= -1
								Loop for: Objects in layer: Line FHB Unit[LayIndex]
									Set Variable: ContourIndex:= ContourIndex + 1
									If: (Line FHB Unit[LayIndex].Start_Line Head Time1!=$N/A)
										Loop for: Variable CellIndex from: 0 to: MODFLOW_BL_GetCountOfACellList(ContourIndex) - 1 step: 1
											If: MODFLOW_BL_SumSegmentLengths(ContourIndex, CellIndex)>0
												Loop for: Variable DivIndex from: TopLayer to: BottomLayer step: 1
													Start a new line
														Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
															Export expression: Line FHB Unit[LayIndex].Head Concentration Time[PeriodIndex]; [G0]
														End loop
													End line
												End loop
											End if
										End loop
									End if
								End loop
							End if
						End loop
						# 
					End file
				End if
			End if
		End if
	End loop
	If: ContinueSimulation
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
			If: ContinueSimulation
				If: LayIndex=1
					Set Variable: M:= 0
				Else
					Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
				End if
			End if
			# 
			If: ContinueSimulation&MODFLOW_SIMUL(LayIndex)
				# 
				Redirect output to: TempFHB5Point$LOOP$
					Loop for: Variable k from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						Set Variable: DumLay:= M+k
						Loop for: Blocks
							Set Variable: DumRow:= Row()
							Set Variable: DumCol:= Column()
							Loop for: Objects in layer: Point FHB Unit[LayIndex]
								# get from 3D list
								If: ContinueSimulation&(Point FHB Unit[LayIndex].Flux Time1!=$N/A)
									If: ShowWarnings&(Point FHB Unit[LayIndex].Head Time1!=$N/A)
										Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: In Point FHB Unit" + LayIndex + ", both a specified head and specified flux are defined for the same contour. MODFLOW will ignore the specified flux." )
									End if
									Set Variable: TopUnitElev:= Elevation Top Unit[LayIndex]
									Set Variable: BottomUnitElev:= Elevation Bottom Unit[LayIndex]
									Set Variable: UnitThickness:= TopUnitElev - BottomUnitElev
									Set Variable: TopContourElev:= Point FHB Unit[LayIndex].Top Elev
									Set Variable: BottomContourElev:= Point FHB Unit[LayIndex].Bottom Elev
									If: TopContourElev>TopUnitElev
										Set Variable: TopContourElev:= TopUnitElev
										If: ShowWarnings
											Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("On the Point FHB Unit" + LayIndex + " layer, the top elevation (" + TopContourElev + ") is above the top of the unit (" + TopUnitElev + "). The top of the unit will be used instead.")
										End if
									End if
									If: BottomContourElev<BottomUnitElev
										Set Variable: BottomContourElev:= BottomUnitElev
										If: ShowWarnings
											Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("On the Point FHB Unit" + LayIndex + " layer, the bottom elevation (" + BottomContourElev + ") is below the bottom of the unit (" + BottomUnitElev + "). The bottom of the unit will be used instead.")
										End if
									End if
									Set Variable: ContourThickness:= TopContourElev - BottomContourElev
									If: ContourThickness=0
										Set Variable: FlowBoundaryCount:= FlowBoundaryCount + 1
										Start a new line
											Export expression: MODFLOW_Layer(LayIndex, TopUnitElev, BottomUnitElev, TopContourElev); [G0]
											Export expression: DumRow; [G0]
											Export expression: DumCol; [G0]
											Export expression: 0; [G0]
											Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
												Export expression: Point FHB Unit[LayIndex].Flux Time[PeriodIndex]; [G0]
											End loop
										End line
									Else
										Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
											Set Variable: DumLay:= M+DivIndex
											Set Variable: TopDivElev:= TopUnitElev - (DivIndex - 1) * UnitThickness
											Set Variable: BottomDivElev:= TopUnitElev - DivIndex * UnitThickness
											Set Variable: DivThickness:= TopDivElev - BottomDivElev
											Set Variable: TopContourInDiv:= TopContourElev
											If: TopContourInDiv>TopDivElev
												Set Variable: TopContourInDiv:= TopDivElev
											End if
											Set Variable: BottomContourInDiv:= BottomContourElev
											If: BottomContourInDiv<BottomDivElev
												Set Variable: BottomContourInDiv:= BottomDivElev
											End if
											Set Variable: ThicknessContourInDiv:= TopContourInDiv - BottomContourInDiv
											If: ThicknessContourInDiv>0
												Set Variable: FlowBoundaryCount:= FlowBoundaryCount + 1
												Start a new line
													Export expression: DumLay; [G0]
													Export expression: DumRow; [G0]
													Export expression: DumCol; [G0]
													Export expression: 0; [G0]
													Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
														Export expression: Point FHB Unit[LayIndex].Flux Time[PeriodIndex] * ThicknessContourInDiv / DivThickness; [G0]
													End loop
												End line
											End if
										End loop
										# End if
									End if
								End if
							End loop
						End loop
						# 
					End loop
				End file
				# 
				If: TransportFlag=1 & Transport>0
					Redirect output to: TempFHB6Point$LOOP$
						Loop for: Variable k from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Set Variable: DumLay:= M+k
							Loop for: Blocks
								Set Variable: DumRow:= Row()
								Set Variable: DumCol:= Column()
								Loop for: Objects in layer: Point FHB Unit[LayIndex]
									# get from 3D list
									If: ContinueSimulation&(Point FHB Unit[LayIndex].Flux Time1!=$N/A)
										Set Variable: TopUnitElev:= Elevation Top Unit[LayIndex]
										Set Variable: BottomUnitElev:= Elevation Bottom Unit[LayIndex]
										Set Variable: UnitThickness:= TopUnitElev - BottomUnitElev
										Set Variable: TopContourElev:= Point FHB Unit[LayIndex].Top Elev
										Set Variable: BottomContourElev:= Point FHB Unit[LayIndex].Bottom Elev
										If: TopContourElev>TopUnitElev
											Set Variable: TopContourElev:= TopUnitElev
											If: ShowWarnings
												Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("On the Point FHB Unit" + LayIndex + " layer, the top elevation (" + TopContourElev + ") is above the top of the unit (" + TopUnitElev + "). The top of the unit will be used instead.")
											End if
										End if
										If: BottomContourElev<BottomUnitElev
											Set Variable: BottomContourElev:= BottomUnitElev
											If: ShowWarnings
												Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("On the Point FHB Unit" + LayIndex + " layer, the bottom elevation (" + BottomContourElev + ") is below the bottom of the unit (" + BottomUnitElev + "). The bottom of the unit will be used instead.")
											End if
										End if
										Set Variable: ContourThickness:= TopContourElev - BottomContourElev
										If: ContourThickness=0
											Start a new line
												Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
													Export expression: Point FHB Unit[LayIndex].Flux Concentration Time[PeriodIndex]; [G0]
												End loop
											End line
										Else
											Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
												Set Variable: DumLay:= M+DivIndex
												Set Variable: TopDivElev:= TopUnitElev - (DivIndex - 1) * UnitThickness
												Set Variable: BottomDivElev:= TopUnitElev - DivIndex * UnitThickness
												Set Variable: DivThickness:= TopDivElev - BottomDivElev
												Set Variable: TopContourInDiv:= TopContourElev
												If: TopContourInDiv>TopDivElev
													Set Variable: TopContourInDiv:= TopDivElev
												End if
												Set Variable: BottomContourInDiv:= BottomContourElev
												If: BottomContourInDiv<BottomDivElev
													Set Variable: BottomContourInDiv:= BottomDivElev
												End if
												Set Variable: ThicknessContourInDiv:= TopContourInDiv - BottomContourInDiv
												If: ThicknessContourInDiv>0
													Start a new line
														Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
															Export expression: Point FHB Unit[LayIndex].Flux Concentration Time[PeriodIndex]; [G0]
														End loop
													End line
												End if
											End loop
											# End if
										End if
									End if
								End loop
							End loop
							# 
						End loop
					End file
				End if
				# 
				# 
				Redirect output to: TempFHB7Point$LOOP$
					# 
					Loop for: Blocks
						Set Variable: DumRow:= Row()
						Set Variable: DumCol:= Column()
						Set Variable: TopUnitElev:= Elevation Top Unit[LayIndex]
						Set Variable: BottomUnitElev:= Elevation Bottom Unit[LayIndex]
						Set Variable: TopLayer:= MODFLOW_Layer(LayIndex, TopUnitElev, BottomUnitElev, Point FHB Unit[LayIndex].Top Elev)
						Set Variable: BottomLayer:= MODFLOW_Layer(LayIndex, TopUnitElev, BottomUnitElev, Point FHB Unit[LayIndex].Bottom Elev)
						Loop for: Objects in layer: Point FHB Unit[LayIndex]
							If: (Point FHB Unit[LayIndex].Head Time1!=$N/A)
								Loop for: Variable CellIndex from: 0 to: MODFLOW_BL_GetCountOfACellList(ContourIndex) - 1 step: 1
									Loop for: Variable DivIndex from: TopLayer to: BottomLayer step: 1
										Set Variable: HeadBoundaryCount:= HeadBoundaryCount + 1
										Start a new line
											Export expression: DivIndex; [G0]
											Export expression: DumRow; [G0]
											Export expression: DumCol; [G0]
											Export expression: 0; [G0]
											Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
												Export expression: Point FHB Unit[LayIndex].Head Time[PeriodIndex]; [G0]
											End loop
										End line
									End loop
								End loop
							End if
						End loop
					End loop
					# 
					# 
				End file
				# 
				If: TransportFlag=1 & Transport>0
					Redirect output to: TempFHB8Point$LOOP$
						# 
						Loop for: Blocks
							Loop for: Objects in layer: Point FHB Unit[LayIndex]
								If: (Point FHB Unit[LayIndex].Head Time1!=$N/A)
									Set Variable: TopUnitElev:= Elevation Top Unit[LayIndex]
									Set Variable: BottomUnitElev:= Elevation Bottom Unit[LayIndex]
									Set Variable: TopLayer:= MODFLOW_Layer(LayIndex, TopUnitElev, BottomUnitElev, Line FHB Unit[LayIndex].Top Elev)
									Set Variable: BottomLayer:= MODFLOW_Layer(LayIndex, TopUnitElev, BottomUnitElev, Line FHB Unit[LayIndex].Bottom Elev)
									If: (Point FHB Unit[LayIndex].Flux Time1!=$N/A)
										Loop for: Variable DivIndex from: TopLayer to: BottomLayer step: 1
											Start a new line
												Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
													Export expression: Point FHB Unit[LayIndex].Head Concentration Time[PeriodIndex]; [G0]
												End loop
											End line
										End loop
									End if
								End if
							End loop
						End loop
						# 
					End file
				End if
				# 
				Redirect output to: TempFHB5Area$LOOP$
					Loop for: Variable k from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						Set Variable: DumLay:= M+k
						Loop for: Blocks
							Set Variable: DumRow:= Row()
							Set Variable: DumCol:= Column()
							Loop for: Objects in layer: Area FHB Unit[LayIndex]
								Set Variable: ContourArea:= ContourIntersectArea()
								If: ContourArea
									Set Variable: FLWRAT:= Area FHB Unit[LayIndex].Flux per Area Time1 * ContourArea
									If: IsNumber(FLWRAT)
										Set Variable: FlowBoundaryCount:= FlowBoundaryCount + 1
										Start a new line
											Export expression: DumLay; [G0]
											Export expression: DumRow; [G0]
											Export expression: DumCol; [G0]
											Export expression: 0; [G0]
											Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
												Export expression: Area FHB Unit[LayIndex].Flux per Area Time[PeriodIndex] * ContourArea; [G0]
											End loop
										End line
									End if
								End if
							End loop
							# The following doesn't work now due to a bug in EffectiveValue()
							# Set Variable: FLWRAT:= EffectiveValue(Area FHB Unit[LayIndex].Flux per Area Time1)
							# If: IsNumber(FLWRAT)
							# 	Set Variable: FlowBoundaryCount:= FlowBoundaryCount + 1
							# 	Start a new line
							# 		Export expression: DumLay; [G0]
							# 		Export expression: DumRow; [G0]
							# 		Export expression: DumCol; [G0]
							# 		Export expression: 0; [G0]
							# 		Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
							# 			Export expression: EffectiveValue(Area FHB Unit[LayIndex].Flux per Area Time[PeriodIndex]); [G0]
							# 		End loop
							# 	End line
							# End if
						End loop
						# 
					End loop
				End file
				# 
				# 
				If: TransportFlag=1 & Transport>0
					Redirect output to: TempFHB6Area$LOOP$
						Loop for: Variable k from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Set Variable: DumLay:= M+k
							Loop for: Blocks
								Set Variable: DumRow:= Row()
								Set Variable: DumCol:= Column()
								Loop for: Objects in layer: Area FHB Unit[LayIndex]
									If: ContinueSimulation
										Set Variable: ContourArea:= ContourIntersectArea()
										If: ContourArea
											Set Variable: FLWRAT:= Area FHB Unit[LayIndex].Flux per Area Time1 * ContourIntersectArea()
											If: IsNumber(FLWRAT)
												If: ShowWarnings&(Area FHB Unit[LayIndex].Head Time1!=$N/A)
													Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning: In Area FHB Unit" + LayIndex + ", both a specified head and specified flux are defined for the same contour. MODFLOW will ignore the specified flux." )
												End if
												Start a new line
													Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
														Export expression: Area FHB Unit[LayIndex].Flux Concentration Time[PeriodIndex]; [G0]
													End loop
												End line
											End if
										End if
									End if
								End loop
								# The following doesn't work now due to a bug in EffectiveValue()
								# Set Variable: FLWRAT:= EffectiveValue(Area FHB Unit[LayIndex].Flux per Area Time1)
								# If: IsNumber(FLWRAT)
								# 	Start a new line
								# 		Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
								# 			Export expression: Area FHB Unit[LayIndex].Flux Concentration Time[PeriodIndex] [G0]
								# 		End loop
								# 	End line
								# End if
							End loop
							# 
						End loop
					End file
				End if
				# 
				# 
				Redirect output to: TempFHB7Area$LOOP$
					Loop for: Variable k from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						Set Variable: DumLay:= M+k
						Loop for: Blocks
							Set Variable: DumRow:= Row()
							Set Variable: DumCol:= Column()
							Set Variable: SBHED:= Area FHB Unit[LayIndex].Head Time1
							If: IsNumber(SBHED)
								Set Variable: HeadBoundaryCount:= HeadBoundaryCount + 1
								Start a new line
									Export expression: DumLay; [G0]
									Export expression: DumRow; [G0]
									Export expression: DumCol; [G0]
									Export expression: 0; [G0]
									Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
										Export expression: Area FHB Unit[LayIndex].Head Time[PeriodIndex]; [G0]
									End loop
								End line
							End if
						End loop
						# 
					End loop
				End file
				# 
				# 
				If: TransportFlag=1 & Transport>0
					Redirect output to: TempFHB8Area$LOOP$
						Loop for: Variable k from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Set Variable: DumLay:= M+k
							Loop for: Blocks
								Set Variable: DumRow:= Row()
								Set Variable: DumCol:= Column()
								Set Variable: SBHED:= Area FHB Unit[LayIndex].Head Time1
								If: IsNumber(SBHED)
									Start a new line
										Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
											Export expression: Area FHB Unit[LayIndex].Head Concentration Time[PeriodIndex]; [G0]
										End loop
									End line
								End if
							End loop
							# 
						End loop
					End file
				End if
				# 
				# 
			End if
		End loop
	End if
	Redirect output to: brook.fhb
		Start a new line
			Export expression: NBDTIM; [G0]
			Export expression: FlowBoundaryCount; [G0]
			Export expression: HeadBoundaryCount; [G0]
			Export expression: IFHBSS; [G0]
			Export expression: IFHBCB; [G0]
			If: TransportFlag=1 & Transport>0
				Export expression: 1; [G0]
				Export expression: 1; [G0]
			Else
				Export expression: 0; [G0]
				Export expression: 0; [G0]
			End if
		End line
		If: TransportFlag=1 & Transport>0
			Start a new line
				Export expression: "CONCENTRATION"; [G0]
				Export expression: 0.5; [G0]
			End line
			Start a new line
				Export expression: "CONCENTRATION"; [G0]
				Export expression: 0.5; [G0]
			End line
		End if
		Start a new line
			Export expression: IFHBUN; [G0]
			Export expression: 1.; [G0]
			Export expression: 1; [G0]
		End line
		Start a new line
			Loop for: Variable PeriodIndex from: 1 to: NBDTIM step: 1
				Export expression: MODFLOW_FHB_Time(PeriodIndex); [G0]
			End loop
		End line
		If: FlowBoundaryCount
			Start a new line
				Export expression: IFHBUN; [G0]
				Export expression: 1.; [G0]
				Export expression: 1; [G0]
			End line
		End if
	End file
	Loop for: Variable LayIndex from: 0 to: MODFLOW_NLAY()-1 step: 1
		If: MODFLOW_SIMUL(LayIndex+1)!=0
			Evaluate expression: MODFLOW_Join_Files("brook.fhb", "TempFHB5Line" + LayIndex, "brook.fhb")
			Evaluate expression: MODFLOW_Join_Files("brook.fhb", "TempFHB5Point" + LayIndex, "brook.fhb")
			Evaluate expression: MODFLOW_Join_Files("brook.fhb", "TempFHB5Area" + LayIndex, "brook.fhb")
			Evaluate expression: MODFLOW_Delete_File("TempFHB5Line" + LayIndex)
			Evaluate expression: MODFLOW_Delete_File("TempFHB5Point" + LayIndex)
			Evaluate expression: MODFLOW_Delete_File("TempFHB5Area" + LayIndex)
		End if
	End loop
	If: TransportFlag=1 & Transport>0
		If: FlowBoundaryCount
			Redirect output to: FHBTemp
				Start a new line
					Export expression: IFHBUN; [G0]
					Export expression: 1.; [G0]
					Export expression: 1; [G0]
				End line
			End file
			Evaluate expression: MODFLOW_Join_Files("brook.fhb", "FHBTemp", "brook.fhb")
		End if
		Loop for: Variable LayIndex from: 0 to: MODFLOW_NLAY()-1 step: 1
			If: MODFLOW_SIMUL(LayIndex+1)!=0
				Evaluate expression: MODFLOW_Join_Files("brook.fhb", "TempFHB6Line" + LayIndex, "brook.fhb")
				Evaluate expression: MODFLOW_Join_Files("brook.fhb", "TempFHB6Point" + LayIndex, "brook.fhb")
				Evaluate expression: MODFLOW_Join_Files("brook.fhb", "TempFHB6Area" + LayIndex, "brook.fhb")
				Evaluate expression: MODFLOW_Delete_File("TempFHB6Line" + LayIndex)
				Evaluate expression: MODFLOW_Delete_File("TempFHB6Point" + LayIndex)
				Evaluate expression: MODFLOW_Delete_File("TempFHB6Area" + LayIndex)
			End if
		End loop
	End if
	If: HeadBoundaryCount
		Redirect output to: FHBTemp
			Start a new line
				Export expression: IFHBUN; [G0]
				Export expression: 1.; [G0]
				Export expression: 1; [G0]
			End line
		End file
		Evaluate expression: MODFLOW_Join_Files("brook.fhb", "FHBTemp", "brook.fhb")
	End if
	Loop for: Variable LayIndex from: 0 to: MODFLOW_NLAY()-1 step: 1
		If: MODFLOW_SIMUL(LayIndex+1)!=0
			Evaluate expression: MODFLOW_Join_Files("brook.fhb", "TempFHB7Line" + LayIndex, "brook.fhb")
			Evaluate expression: MODFLOW_Join_Files("brook.fhb", "TempFHB7Point" + LayIndex, "brook.fhb")
			Evaluate expression: MODFLOW_Join_Files("brook.fhb", "TempFHB7Area" + LayIndex, "brook.fhb")
			Evaluate expression: MODFLOW_Delete_File("TempFHB7Line" + LayIndex)
			Evaluate expression: MODFLOW_Delete_File("TempFHB7Point" + LayIndex)
			Evaluate expression: MODFLOW_Delete_File("TempFHB7Area" + LayIndex)
		End if
	End loop
	If: TransportFlag=1 & Transport>0
		If: HeadBoundaryCount
			Redirect output to: FHBTemp
				Start a new line
					Export expression: IFHBUN; [G0]
					Export expression: 1.; [G0]
					Export expression: 1; [G0]
				End line
			End file
			Evaluate expression: MODFLOW_Join_Files("brook.fhb", "FHBTemp", "brook.fhb")
		End if
		Loop for: Variable LayIndex from: 0 to: MODFLOW_NLAY()-1 step: 1
			If: MODFLOW_SIMUL(LayIndex+1)!=0
				Evaluate expression: MODFLOW_Join_Files("brook.fhb", "TempFHB8Line" + LayIndex, "brook.fhb")
				Evaluate expression: MODFLOW_Join_Files("brook.fhb", "TempFHB8Point" + LayIndex, "brook.fhb")
				Evaluate expression: MODFLOW_Join_Files("brook.fhb", "TempFHB8Area" + LayIndex, "brook.fhb")
				Evaluate expression: MODFLOW_Delete_File("TempFHB8Line" + LayIndex)
				Evaluate expression: MODFLOW_Delete_File("TempFHB8Point" + LayIndex)
				Evaluate expression: MODFLOW_Delete_File("TempFHB8Area" + LayIndex)
			End if
		End loop
	End if
	Evaluate expression: MODFLOW_Delete_File("FHBTemp")
	# 
End if
# begin modification
# ----------------------------------------------------
# Seepage Package
# ----------------------------------------------------
If: SeepageChoice!=0&ExportSPG!=0
	Evaluate expression: MODFLOW_ProgressBarSetMessage("Seepage Package")
	Redirect output to: brook.spg
	End file
	Set Variable: MaxSeepages:= 0
	Set Variable: err_line:= 0
	Set Variable: err_area1:= 0
	Set Variable: err_area2:= 0
	Set Variable: CurrentSeepageCount:= 0
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Evaluate expression: MODFLOW_ProgressBarAdvance()
		If: LayIndex=1
			Set Variable: M:= 0
		Else
			Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
		End if
		# 
		If: MODFLOW_SIMUL(LayIndex)!=0
			# 
			Loop for: Blocks
				Set Variable: AreaBoundaryInBlock:= 0
				# 
				Set Variable: DumRow:= Row()
				Set Variable: DumCol:= Column()
				# 
				If: 0
					If: CountObjectsInBlock(Line Seepage Unit[LayIndex].Elevation)!=0
						Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
						Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
						Set Variable: ocflag:= 0
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							If: Line Seepage Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Line Seepage Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
								Set Variable: ocflag:= DivIndex
							End if
						End loop
						If: ocflag=0
							Set Variable: ocflag:= 1
							Set Variable: err_spg_3:= 1
							Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Line seepage elevation does not lie within geologic unit: Line seepage is placed in uppermost model layer in geologic unit.")
						End if
						Set Variable: DumLay:= M+ocflag
						Set Variable: CurrentSeepageCount:= CurrentSeepageCount + 1
						Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
							If: !(PeriodIndex>1&SteadySeepage=0)
								Redirect output to: TempSeepagePer
									Start a new line
										Export expression: DumLay [I10]
										Export expression: DumRow [I10]
										Export expression: DumCol [I10]
										If: Line Seepage Unit[LayIndex].On or Off Stress[PeriodIndex]
											Export expression: Line Seepage Unit[LayIndex].Elevation [E13.5]
										Else
											Export expression: 1.e49 [E13.5]
										End if
										Export expression: 0; [E13.5]
										# MODPATH
										# If: MODPATHChoice
										#	Export expression: Line Seepage Unit[LayIndex].IFACE[PeriodIndex] [G0]
										# End if
									End line
								End file
								Evaluate expression: MODFLOW_Join_Files("TempSeepagePer" + PeriodIndex, "TempSeepagePer", "TempSeepagePer" + PeriodIndex)
							End if
						End loop
						# End if
					End if
					# 
					Set Variable: ThisElevation:= AREA Seepage Unit[LayIndex].Elevation
					If: (ThisElevation!=$N/A)
						Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
						Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
						Set Variable: ocflag:= 0
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							If: ThisElevation<=(LayerTop-(DivIndex-1)*LayerThickness)&ThisElevation>(LayerTop-DivIndex*LayerThickness)
								Set Variable: ocflag:= DivIndex
							End if
						End loop
						If: ocflag=0
							Set Variable: ocflag:= 1
							Set Variable: err_spg_4:= 1
							Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Area seepage elevation does not lie within geologic unit: Area seepage is placed in uppermost model layer in geologic unit.")
						End if
						Set Variable: CurrentSeepageCount:= CurrentSeepageCount + 1
						Set Variable: DumLay:= M+ocflag
						Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
							If: !(PeriodIndex>1&SteadySeepage=0)
								Redirect output to: TempSeepagePer
									Start a new line
										Export expression: DumLay [I10]
										Export expression: DumRow [I10]
										Export expression: DumCol [I10]
										If: Area Seepage Unit[LayIndex].On or Off Stress[PeriodIndex]
											Export expression: ThisElevation [E13.5]
										Else
											Export expression: 1.e49 [E13.5]
										End if
										Export expression: 0; [E13.5]
										# MODPATH
										# If: MODPATHChoice
										# 	Export expression: Area Seepage Unit[LayIndex].IFACE[PeriodIndex] [G0]
										# End if
									End line
								End file
								Evaluate expression: MODFLOW_Join_Files("TempSeepagePer" + PeriodIndex, "TempSeepagePer", "TempSeepagePer" + PeriodIndex)
							End if
						End loop
					End if
				Else
					Loop for: Objects in layer: LINE SEEPAGE UNIT[LayIndex]
						Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
						Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
							Set Variable: ocflag:= 0
							Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								If: Line Seepage Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Line Seepage Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
									Set Variable: ocflag:= DivIndex
								End if
							End loop
							If: ocflag=0
								Set Variable: ocflag:= 1
								Set Variable: err_spg_3:= 1
								Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Line seepage elevation does not lie within geologic unit: Line seepage is placed in uppermost model layer in geologic unit.")
							End if
							Set Variable: DumLay:= M+ocflag
							Set Variable: CurrentSeepageCount:= CurrentSeepageCount + 1
							Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
								If: !(PeriodIndex>1&SteadySeepage=0)
									Redirect output to: TempSeepagePer
										Start a new line
											Export expression: DumLay [I10]
											Export expression: DumRow [I10]
											Export expression: DumCol [I10]
											If: Line Seepage Unit[LayIndex].On or Off Stress[PeriodIndex]
												Export expression: Line Seepage Unit[LayIndex].Elevation [E13.5]
											Else
												Export expression: 1.e49 [E13.5]
											End if
											Export expression: 0; [E13.5]
											# MODPATH
											# If: MODPATHChoice
											# 	Export expression: Line Seepage Unit[LayIndex].IFACE[PeriodIndex] [G0]
											# End if
										End line
									End file
									Evaluate expression: MODFLOW_Join_Files("TempSeepagePer" + PeriodIndex, "TempSeepagePer", "TempSeepagePer" + PeriodIndex)
								End if
							End loop
					End loop
					# 
					Loop for: Objects in layer: AREA SEEPAGE UNIT[LayIndex]
						Set Variable: AreaBoundaryInBlock:= 1
						Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
						Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
						Set Variable: ocflag:= 0
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							If: Area Seepage Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Area Seepage Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
								Set Variable: ocflag:= DivIndex
							End if
						End loop
						If: ocflag=0
							Set Variable: ocflag:= 1
							Set Variable: err_spg_4:= 1
							Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Area seepage elevation does not lie within geologic unit: Area seepage is placed in uppermost model layer in geologic unit.")
						End if
						Set Variable: CurrentSeepageCount:= CurrentSeepageCount + 1
						Set Variable: DumLay:= M+ocflag
						Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
							If: !(PeriodIndex>1&SteadySeepage=0)
								Redirect output to: TempSeepagePer
									Start a new line
										Export expression: DumLay [I10]
										Export expression: DumRow [I10]
										Export expression: DumCol [I10]
										If: Area Seepage Unit[LayIndex].On or Off Stress[PeriodIndex]
											Export expression: Area Seepage Unit[LayIndex].Elevation [E13.5]
										Else
											Export expression: 1.e49 [E13.5]
										End if
										Export expression: 0; [E13.5]
										# MODPATH
										# If: MODPATHChoice
										# 	Export expression: Area Seepage Unit[LayIndex].IFACE[PeriodIndex] [G0]
										# End if
									End line
								End file
								Evaluate expression: MODFLOW_Join_Files("TempSeepagePer" + PeriodIndex, "TempSeepagePer", "TempSeepagePer" + PeriodIndex)
							End if
						End loop
					End loop
					Set Variable: ThisElevation:= AREA Seepage Unit[LayIndex].Elevation
					If: (!AreaBoundaryInBlock)&(ThisElevation!=$N/A)
						Set Variable: LayerTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, DumCol, DumRow, LayIndex)
						Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, DumCol, DumRow, LayIndex)
						Set Variable: ocflag:= 0
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							If: Area Seepage Unit[LayIndex].Elevation<=(LayerTop-(DivIndex-1)*LayerThickness)&Area Seepage Unit[LayIndex].Elevation>(LayerTop-DivIndex*LayerThickness)
								Set Variable: ocflag:= DivIndex
							End if
						End loop
						If: ocflag=0
							Set Variable: ocflag:= 1
							Set Variable: err_spg_4:= 1
							Evaluate expression: MODFLOW_ProgressBarAddLine("At column " + DumCol + " Row " + DumRow + " and Layer " + DumLay + ", Area seepage elevation does not lie within geologic unit: Area seepage is placed in uppermost model layer in geologic unit.")
						End if
						Set Variable: CurrentSeepageCount:= CurrentSeepageCount + 1
						Set Variable: DumLay:= M+ocflag
						Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
							If: !(PeriodIndex>1&SteadySeepage=0)
								Redirect output to: TempSeepagePer
									Start a new line
										Export expression: DumLay [I10]
										Export expression: DumRow [I10]
										Export expression: DumCol [I10]
										If: Area Seepage Unit[LayIndex].On or Off Stress[PeriodIndex]
											Export expression: ThisElevation [E13.5]
										Else
											Export expression: 1.e49 [E13.5]
										End if
										Export expression: 0; [E13.5]
										# MODPATH
										# If: MODPATHChoice
										# 	Export expression: Area Seepage Unit[LayIndex].IFACE[PeriodIndex] [G0]
										# End if
									End line
								End file
								Evaluate expression: MODFLOW_Join_Files("TempSeepagePer" + PeriodIndex, "TempSeepagePer", "TempSeepagePer" + PeriodIndex)
							End if
						End loop
					End if
				End if
			End loop
		End if
	End loop
	Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
		Redirect output to: TempSeepage1
			If: PeriodIndex>1&SteadySeepage=0
				Start a new line
					Export expression: -1 [I5]
				End line
			Else
				Start a new line
					Export expression: CurrentSeepageCount [I5]
				End line
			End if
		End file
		If: CurrentSeepageCount>MaxSeepages
			Set Variable: MaxSeepages:= CurrentSeepageCount
		End if
		If: !(PeriodIndex>1&SteadySeepage=0)
			Evaluate expression: MODFLOW_Join_Files("TempSeepage1", "TempSeepagePer" + PeriodIndex, "TempSeepage1")
			Evaluate expression: MODFLOW_Delete_File("TempSeepagePer" + PeriodIndex)
		End if
		Evaluate expression: MODFLOW_Join_Files("brook.spg", "TempSeepage1", "brook.spg")
	End loop
	Redirect output to: TempSeepage1
		Start a new line
			Export expression: MaxSeepages [I5]
			If: ISPGCB>0&OneCBCFile=1
				Export expression: 33 [I5]
			End if
			If: ISPGCB>0&OneCBCFile=0
				Export expression: 69 [I5]
			End if
			If: ISPGCB=0
				Export expression: 0 [I5]
			End if
			# MODPATH
			# If: MODPATHChoice
			# 	Export expression: " AUXILIARY IFACE" [G0]
			# End if
			# MOC3D CBC parameter
			If: TransportFlag=1 & Transport>0
				Export expression: " CBCALLOCATE" [G0]
			End if
		End line
	End file
	Evaluate expression: MODFLOW_Join_Files("TempSeepage1", "brook.spg", "brook.spg")
	# 
	Evaluate expression: MODFLOW_Delete_File("TempSeepage1")
	Evaluate expression: MODFLOW_Delete_File("TempSeepagePer")
End if

# ----------------------------------------------------
# Lake Package version 2.2:
# ----------------------------------------------------
If: LakeChoice&ExportLAK
	Evaluate expression: MODFLOW_ProgressBarSetMessage("Lake Package")
	Set Variable: LakeElevations3DList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), 2)
	Set Variable: MasterLakeList:= MODFLOW_L_CreateNewList()
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		If: MODFLOW_SIMUL(LayIndex)
			Loop for: Objects in layer: Lake Unit[LayIndex]
				Evaluate expression: MODFLOW_L_AddToList(MasterLakeList,Lake Unit[LayIndex].Lake Number)
			End loop
		End if
	End loop
	Evaluate expression: MODFLOW_L_SortList(MasterLakeList)
	Evaluate expression: MODFLOW_L_EliminateDuplicates(MasterLakeList)
	Set Variable: MasterLakeListSize:= MODFLOW_L_GetListSize(MasterLakeList)
	Set Variable: LakeColumnListsStart:= MasterLakeList + 1
	Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
		Set Variable: LakeRowListsStart:= MODFLOW_L_CreateNewList() + 1
	End loop
	Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
		Set Variable: LakeLayerListStart:= MODFLOW_L_CreateNewList() + 1
	End loop
	Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
		Set Variable: LakeTopElevListStart:= MODFLOW_L_CreateNewList() + 1
	End loop
	Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
		Set Variable: LakeBotElevListStart:= MODFLOW_L_CreateNewList() + 1
	End loop
	Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
		Set Variable: LakeAreaListStart:= MODFLOW_L_CreateNewList() + 1
	End loop
	Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
		Set Variable: LakeHydCondListStart:= MODFLOW_L_CreateNewList() + 1
	End loop
	Loop for: Variable ListIndex from: 1 to: MasterLakeListSize step: 1
		Evaluate expression: MODFLOW_L_CreateNewList()
	End loop
	Set Variable: FoundLakeBottomCell3DList:= MODFLOW_L_CreateNew3DList(NumColumns(), NumRows(), 1)
	Set Variable: ModflowLayer:= 0
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Evaluate expression: MODFLOW_ProgressBarAdvance()
		If: MODFLOW_SIMUL(LayIndex)
			Loop for: Blocks
				Evaluate expression: MODFLOW_L_SetOneBased3DListItem(LakeElevations3DList, Column(), Row(), 1, Lakebed Top Unit[LayIndex])
				Evaluate expression: MODFLOW_L_SetOneBased3DListItem(LakeElevations3DList, Column(), Row(), 2, Lakebed Bottom Unit[LayIndex])
			End loop
			Set Variable: ModflowLayer:= ModflowLayer + MODFLOW_NDIV(LayIndex)
			Loop for: Blocks
				Set Variable: LakeNumber:= Lake To Right Unit[LayIndex]
				Set Variable: LocalKz:= Kx Unit[LayIndex]
				If: LakeNumber
					Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,LakeNumber)
					Set Variable: UnitTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)
					Set Variable: UnitBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
					Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
					Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						Set Variable: LayerTop:= UnitTop - (DivIndex - 1) * LayerThickness
						Set Variable: LakebedTop:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column() + 1, Row(), 1)
						If: LakebedTop<=LayerTop
							Set Variable: LayerBottom:= UnitTop - DivIndex * LayerThickness
							Set Variable: LakebedBottom:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column() + 1, Row(), 2)
							If: LayerBottom<LakebedTop
								Set Variable: LocalBottom:= LakebedTop
							Else
								Set Variable: LocalBottom:= LayerBottom
							End if
							Set Variable: CrossSectionalArea:= (LayerTop - LocalBottom) * NthBlockSideLength(0)
							Evaluate expression: MODFLOW_L_AddToList(LakeRowListsStart + LakeIndex,Row())
							Evaluate expression: MODFLOW_L_AddToList(LakeColumnListsStart + LakeIndex,Column())
							Evaluate expression: MODFLOW_L_AddToList(LakeLayerListStart + LakeIndex,ModflowLayer - MODFLOW_NDIV(LayIndex) + DivIndex)
							Evaluate expression: MODFLOW_L_AddToList(LakeTopElevListStart + LakeIndex,LakebedTop)
							Evaluate expression: MODFLOW_L_AddToList(LakeBotElevListStart + LakeIndex,LakebedBottom)
							# Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] * (LakebedTop - LakebedBottom) / (NthBlockSideLength(1) / 2))
							If: LakeSideCondChoice=0
								Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity / (LakebedTop - LakebedBottom)*CrossSectionalArea)
							Else
								If: LakeSideCondChoice=1
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] * MODFLOW_TRPY(LayIndex) / (NthBlockSideLength(1) / 2)*CrossSectionalArea)
								Else
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,(1 / ((LakebedTop - LakebedBottom) / Lake Unit[LayIndex].Lakebed hydraulic conductivity + (NthBlockSideLength(1) / 2) / (Kx Unit[LayIndex] * MODFLOW_TRPY(LayIndex))))*CrossSectionalArea )
								End if
							End if
							Evaluate expression: MODFLOW_L_AddToList(LakeAreaListStart + LakeIndex,CrossSectionalArea)
						End if
					End loop
				End if
				Set Variable: LakeNumber:= Lake To Left Unit[LayIndex]
				If: LakeNumber
					Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,LakeNumber)
					Set Variable: UnitTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)
					Set Variable: UnitBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
					Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
					Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						Set Variable: LayerTop:= UnitTop - (DivIndex - 1) * LayerThickness
						Set Variable: LakebedTop:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column()-1,Row(), 1)
						If: LakebedTop<=LayerTop
							Set Variable: LayerBottom:= UnitTop - DivIndex * LayerThickness
							Set Variable: LakebedBottom:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column()-1,Row(), 2)
							If: LayerBottom<LakebedTop
								Set Variable: LocalBottom:= LakebedTop
							Else
								Set Variable: LocalBottom:= LayerBottom
							End if
							Set Variable: CrossSectionalArea:= (LayerTop - LocalBottom) * NthBlockSideLength(0)
							Evaluate expression: MODFLOW_L_AddToList(LakeRowListsStart + LakeIndex,Row())
							Evaluate expression: MODFLOW_L_AddToList(LakeColumnListsStart + LakeIndex,Column())
							Evaluate expression: MODFLOW_L_AddToList(LakeLayerListStart + LakeIndex,ModflowLayer - MODFLOW_NDIV(LayIndex) + DivIndex)
							Evaluate expression: MODFLOW_L_AddToList(LakeTopElevListStart + LakeIndex,LakebedTop)
							Evaluate expression: MODFLOW_L_AddToList(LakeBotElevListStart + LakeIndex,LakebedBottom)
							# Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] * (LakebedTop - LakebedBottom) / (NthBlockSideLength(1) / 2))
							If: LakeSideCondChoice=0
								Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity / (LakebedTop - LakebedBottom)*CrossSectionalArea)
							Else
								If: LakeSideCondChoice=1
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] / (NthBlockSideLength(1) / 2)*CrossSectionalArea)
								Else
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,(1 / ((LakebedTop - LakebedBottom) / Lake Unit[LayIndex].Lakebed hydraulic conductivity + (NthBlockSideLength(1) / 2) / Kx Unit[LayIndex]))*CrossSectionalArea )
								End if
							End if
							Evaluate expression: MODFLOW_L_AddToList(LakeAreaListStart + LakeIndex,CrossSectionalArea)
						End if
					End loop
				End if
				Set Variable: LakeNumber:= Lake To North Unit[LayIndex]
				If: LakeNumber
					Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,LakeNumber)
					Set Variable: UnitTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)
					Set Variable: UnitBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
					Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
					Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						Set Variable: LayerTop:= UnitTop - (DivIndex - 1) * LayerThickness
						Set Variable: LakebedTop:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column(),Row() + 1, 1)
						If: LakebedTop<=LayerTop
							Set Variable: LayerBottom:= UnitTop - DivIndex * LayerThickness
							Set Variable: LakebedBottom:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column(),Row() + 1, 2)
							If: LayerBottom<LakebedTop
								Set Variable: LocalBottom:= LakebedTop
							Else
								Set Variable: LocalBottom:= LayerBottom
							End if
							Set Variable: CrossSectionalArea:= (LayerTop - LocalBottom) * NthBlockSideLength(1)
							Evaluate expression: MODFLOW_L_AddToList(LakeRowListsStart + LakeIndex,Row())
							Evaluate expression: MODFLOW_L_AddToList(LakeColumnListsStart + LakeIndex,Column())
							Evaluate expression: MODFLOW_L_AddToList(LakeLayerListStart + LakeIndex,ModflowLayer - MODFLOW_NDIV(LayIndex) + DivIndex)
							Evaluate expression: MODFLOW_L_AddToList(LakeTopElevListStart + LakeIndex,LakebedTop)
							Evaluate expression: MODFLOW_L_AddToList(LakeBotElevListStart + LakeIndex,LakebedBottom)
							# Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] * (LakebedTop - LakebedBottom) / (NthBlockSideLength(0) / 2))
							If: LakeSideCondChoice=0
								Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity / (LakebedTop - LakebedBottom)*CrossSectionalArea)
							Else
								If: LakeSideCondChoice=1
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] / (NthBlockSideLength(0) / 2)*CrossSectionalArea)
								Else
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,(1 / ((LakebedTop - LakebedBottom) / Lake Unit[LayIndex].Lakebed hydraulic conductivity + (NthBlockSideLength(0) / 2) / Kx Unit[LayIndex]))*CrossSectionalArea )
								End if
							End if
							Evaluate expression: MODFLOW_L_AddToList(LakeAreaListStart + LakeIndex,CrossSectionalArea)
						End if
					End loop
				End if
				Set Variable: LakeNumber:= Lake To South Unit[LayIndex]
				If: LakeNumber
					Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,LakeNumber)
					Set Variable: UnitTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)
					Set Variable: UnitBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
					Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
					Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						Set Variable: LayerTop:= UnitTop - (DivIndex - 1) * LayerThickness
						Set Variable: LakebedTop:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column(),Row() - 1, 1)
						If: LakebedTop<=LayerTop
							Set Variable: LayerBottom:= UnitTop - DivIndex * LayerThickness
							Set Variable: LakebedBottom:= MODFLOW_L_GetFromOneBased3DList(LakeElevations3DList, Column(),Row() - 1, 2)
							If: LayerBottom<LakebedTop
								Set Variable: LocalBottom:= LakebedTop
							Else
								Set Variable: LocalBottom:= LayerBottom
							End if
							Set Variable: CrossSectionalArea:= (LayerTop - LocalBottom) * NthBlockSideLength(1)
							Evaluate expression: MODFLOW_L_AddToList(LakeRowListsStart + LakeIndex,Row())
							Evaluate expression: MODFLOW_L_AddToList(LakeColumnListsStart + LakeIndex,Column())
							Evaluate expression: MODFLOW_L_AddToList(LakeLayerListStart + LakeIndex,ModflowLayer - MODFLOW_NDIV(LayIndex) + DivIndex)
							Evaluate expression: MODFLOW_L_AddToList(LakeTopElevListStart + LakeIndex,LakebedTop)
							Evaluate expression: MODFLOW_L_AddToList(LakeBotElevListStart + LakeIndex,LakebedBottom)
							# Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] * (LakebedTop - LakebedBottom) / (NthBlockSideLength(0) / 2))
							If: LakeSideCondChoice=0
								Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity / (LakebedTop - LakebedBottom)*CrossSectionalArea)
							Else
								If: LakeSideCondChoice=1
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Kx Unit[LayIndex] / (NthBlockSideLength(0) / 2)*CrossSectionalArea)
								Else
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,(1 / ((LakebedTop - LakebedBottom) / Lake Unit[LayIndex].Lakebed hydraulic conductivity + (NthBlockSideLength(0) / 2) / Kx Unit[LayIndex]))*CrossSectionalArea )
								End if
							End if
							Evaluate expression: MODFLOW_L_AddToList(LakeAreaListStart + LakeIndex,CrossSectionalArea)
						End if
					End loop
				End if
				Set Variable: LakeNumber:= LakeParam Unit[LayIndex]
				If: LakeNumber
					Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,LakeNumber)
					Set Variable: UnitTop:= MODFLOW_L_GetFromOneBased3DList(TopElevationList, Column(), Row(), LayIndex)
					Set Variable: UnitBottom:= MODFLOW_L_GetFromOneBased3DList(BottomElevationList, Column(), Row(), LayIndex)
					Set Variable: LayerThickness:= MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex)
					Set Variable: FoundLakeCell:= 0
					Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						If: !FoundLakeCell
							Set Variable: LayerTop:= UnitTop - (DivIndex - 1) * LayerThickness
							Set Variable: LakebedTop:= Lakebed Top Unit[LayIndex]
							Set Variable: LayerBottom:= UnitTop - DivIndex * LayerThickness
							Set Variable: LakebedBottom:= Lakebed Bottom Unit[LayIndex]
							If: LayerTop<=LakebedBottom
								Set Variable: FoundLakeCell:= 1
								Evaluate expression: MODFLOW_L_SetOneBased3DListItem(FoundLakeBottomCell3DList, Column(), Row(), 1, 1)
								Evaluate expression: MODFLOW_L_AddToList(LakeRowListsStart + LakeIndex,Row())
								Evaluate expression: MODFLOW_L_AddToList(LakeColumnListsStart + LakeIndex,Column())
								Evaluate expression: MODFLOW_L_AddToList(LakeLayerListStart + LakeIndex,ModflowLayer - MODFLOW_NDIV(LayIndex) + DivIndex)
								Evaluate expression: MODFLOW_L_AddToList(LakeTopElevListStart + LakeIndex,LakebedTop)
								Evaluate expression: MODFLOW_L_AddToList(LakeBotElevListStart + LakeIndex,LakebedBottom)
								Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity)
								If: LakeBotCondChoice=0
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity / (LakebedTop - LakebedBottom)*BlockArea())
								Else
									Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,(1 / ((LakebedTop - LakebedBottom) / Lake Unit[LayIndex].Lakebed hydraulic conductivity + (LakebedBottom - LayerBottom) / 2 / LocalKz))*BlockArea())
								End if
								Evaluate expression: MODFLOW_L_AddToList(LakeAreaListStart + LakeIndex,BlockArea())
							End if
						End if
					End loop
				End if
				Set Variable: LakeNumber:= Lake Above Unit[LayIndex]
				If: LakeNumber
					Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,LakeNumber)
					If: (MODFLOW_L_GetFromOneBased3DList(FoundLakeBottomCell3DList, Column(), Row(), 1)=0)&(LayIndex>1)
						Set Variable: LakebedTop:= Lakebed Top Unit[LayIndex-1]
						Set Variable: LakebedBottom:= Lakebed Bottom Unit[LayIndex-1]
						Evaluate expression: MODFLOW_L_SetOneBased3DListItem(FoundLakeBottomCell3DList, Column(), Row(), 1, 1)
						Evaluate expression: MODFLOW_L_AddToList(LakeRowListsStart + LakeIndex,Row())
						Evaluate expression: MODFLOW_L_AddToList(LakeColumnListsStart + LakeIndex,Column())
						Evaluate expression: MODFLOW_L_AddToList(LakeLayerListStart + LakeIndex,ModflowLayer - MODFLOW_NDIV(LayIndex) + 1)
						Evaluate expression: MODFLOW_L_AddToList(LakeTopElevListStart + LakeIndex,Lakebed Top Unit[LayIndex-1])
						Evaluate expression: MODFLOW_L_AddToList(LakeBotElevListStart + LakeIndex,Lakebed Bottom Unit[LayIndex-1])
						If: LakeBotCondChoice=0
							Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex-1].Lakebed hydraulic conductivity / (LakebedTop - LakebedBottom)*BlockArea())
						Else
							Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,(1 / ((LakebedTop - LakebedBottom) / Lake Unit[LayIndex-1].Lakebed hydraulic conductivity + (LakebedBottom - LayerBottom) / 2 / LocalKz))*BlockArea())
						End if
						# Evaluate expression: MODFLOW_L_AddToList(LakeHydCondListStart + LakeIndex,Lake Unit[LayIndex].Lakebed hydraulic conductivity)
						Evaluate expression: MODFLOW_L_AddToList(LakeAreaListStart + LakeIndex,BlockArea())
					Else
						# Error
					End if
				End if
			End loop
		End if
	End loop
	Redirect output to: TempLakePhysical
	End file
	Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
		Evaluate expression: MODFLOW_ProgressBarAdvance()
		If: MODFLOW_SIMUL(LayIndex)
			Loop for: Objects in layer: Lake Unit[LayIndex]
				Set Variable: NSTRIN:= 0
				Redirect output to: TempLake5
					If: MaxInflowSegments>0
						Loop for: Variable SegmentIndex from: 1 to: MaxInflowSegments step: 1
							If: IsNumber(Input Stream[SegmentIndex])
								Set Variable: NSTRIN:= NSTRIN + 1
								Start a new line
									Export expression: MODFLOW_L_UnsortedIndexOf(StreamSegmentList, Input Stream[SegmentIndex])+1 [I10]
								End line
							End if
						End loop
					End if
				End file
				Set Variable: NSTROUT:= 0
					If: MaxOutflowSegments>0
				Loop for: Variable SegmentIndex from: 1 to: MaxOutflowSegments step: 1
					Redirect output to: TempLake7
					End file
					Redirect output to: TempLake6
					End file
					If: IsNumber(Output Stream[SegmentIndex])
						Set Variable: NSTROUT:= NSTROUT + 1
						Set Variable: NRATEQ:= 0
						Redirect output to: TempLake7
							Loop for: Variable RateEqIndex from: 1 to: MaxRateEq step: 1
								If: IsNumber(Eq Cutoff[SegmentIndex * 10 + RateEqIndex])
									Set Variable: NRATEQ:= NRATEQ + 1
									Start a new line
										Export expression: Eq Cutoff[SegmentIndex * 10 + RateEqIndex] [G10]
										Export expression: Eq Const[SegmentIndex * 10 + RateEqIndex] [G10]
										Export expression: Eq Elev[SegmentIndex * 10 + RateEqIndex] [G10]
										Export expression: Eq exponent[SegmentIndex * 10 + RateEqIndex] [G10]
									End line
								End if
							End loop
						End file
						Redirect output to: TempLake6
							Start a new line
								Export expression: MODFLOW_L_UnsortedIndexOf(StreamSegmentList, Output Stream[SegmentIndex])+1 [I10]
								Export expression: NRATEQ [I10]
							End line
						End file
					End if
					Redirect output to: TempLake8
						Set Variable: LakeIndex:= MODFLOW_L_IndexOf(MasterLakeList,Lake Unit[LayIndex].Lake Number)
						Set Variable: NODES:= MODFLOW_L_GetListSize(LakeLayerListStart + LakeIndex)
						Loop for: Variable CellIndex from: 0 to: NODES-1 step: 1
							Start a new line
								Export expression: MODFLOW_L_GetFromList(LakeLayerListStart + LakeIndex, CellIndex) [I10]
								Export expression: MODFLOW_L_GetFromList(LakeRowListsStart + LakeIndex, CellIndex) [I10]
								Export expression: MODFLOW_L_GetFromList(LakeColumnListsStart + LakeIndex, CellIndex) [I10]
								Export expression: MODFLOW_L_GetFromList(LakeTopElevListStart + LakeIndex, CellIndex) [G10]
								Export expression: MODFLOW_L_GetFromList(LakeBotElevListStart + LakeIndex, CellIndex) [G10]
								Export expression: MODFLOW_L_GetFromList(LakeAreaListStart + LakeIndex, CellIndex) [G10]
								Export expression: MODFLOW_L_GetFromList(LakeHydCondListStart + LakeIndex, CellIndex) [G10]
							End line
						End loop
					End file
				End loop
				End if
				Redirect output to: TempLake4
					Start a new line
						Export expression: NODES [I10]
						Export expression: NSTRIN [I10]
						Export expression: NSTROUT [I10]
						Export expression: Maximum Lake Stage [G10]
						Export expression: 1 [I10]
					End line
				End file
				Evaluate expression: MODFLOW_Join_Files("TempLakePhysical", "TempLake4", "TempLakePhysical")
				Evaluate expression: MODFLOW_Join_Files("TempLakePhysical", "TempLake5", "TempLakePhysical")
				Evaluate expression: MODFLOW_Join_Files("TempLakePhysical", "TempLake6", "TempLakePhysical")
				Evaluate expression: MODFLOW_Join_Files("TempLakePhysical", "TempLake7", "TempLakePhysical")
				Evaluate expression: MODFLOW_Join_Files("TempLakePhysical", "TempLake8", "TempLakePhysical")
			End loop
		End if
	End loop
	Set Variable: NLAKES:= 0
	Redirect output to: TempLake3
		Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
			If: MODFLOW_SIMUL(LayIndex)
				Loop for: Objects in layer: Lake Unit[LayIndex]
					Set Variable: NLAKES:= NLAKES + 1
					Start a new line
						Export expression: Lake Name [G10]
						Export expression: Simulation mode [I10]
						Export expression: Starting Stage [G10]
						Export expression: Max Iterations [I10]
						Export expression: Stage Convergence Criterion [G10]
					End line
				End loop
			End if
		End loop
	End file
	Redirect output to: brook.lak
		Start a new line
			Export expression: "/*LAK2.2" [G0]
		End line
		Start a new line
			Export expression: NLAKES [I10]
			Export expression: ILKCBC [I10]
			Export expression: ILKOUT [I10]
			Export expression: 1 [I10]
			Export expression: NSUBSTEPS [I10]
		End line
	End file
	Evaluate expression: MODFLOW_Join_Files("brook.lak", "TempLake3", "brook.lak")
	Evaluate expression: MODFLOW_Join_Files("brook.lak", "TempLakePhysical", "brook.lak")
	Redirect output to: TempLake9
		Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
			Start a new line
				If: PeriodIndex=1
					Export expression: 1 [G0]
				Else
					Export expression: SteadyLake - 1 [G0]
				End if
			End line
			If: (PeriodIndex=1)|SteadyLake
				Loop for: Variable LayIndex from: 1 to: MODFLOW_NLAY() step: 1
					If: MODFLOW_SIMUL(LayIndex)
						Loop for: Objects in layer: Lake Unit[LayIndex]
							Start a new line
								Export expression: Precipitation[PeriodIndex] [G10]
								Export expression: Evapotranspiration[PeriodIndex] [G10]
								Export expression: Runoff[PeriodIndex] [G10]
								Export expression: Dry Recharge[PeriodIndex] [G10]
								Export expression: Output option[PeriodIndex] [I10]
								Export expression: Stage[PeriodIndex] [G10]
							End line
						End loop
					End if
				End loop
			End if
		End loop
	End file
	Evaluate expression: MODFLOW_Join_Files("brook.lak", "TempLake9", "brook.lak")
	Evaluate expression: MODFLOW_Delete_File("TempLake3")
	Evaluate expression: MODFLOW_Delete_File("TempLake4")
	Evaluate expression: MODFLOW_Delete_File("TempLake5")
	Evaluate expression: MODFLOW_Delete_File("TempLake6")
	Evaluate expression: MODFLOW_Delete_File("TempLake7")
	Evaluate expression: MODFLOW_Delete_File("TempLake8")
	Evaluate expression: MODFLOW_Delete_File("TempLake9")
	Evaluate expression: MODFLOW_Delete_File("TempLakePhysical")
End if
# 

# end modification
# 
# MF_SOL.met
# ----------------------------------------------------
# Successive Overrelaxation Solver
# ----------------------------------------------------
If: ContinueSimulation&(SolverChoice=3)&ExportSOL
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Successive Overrelaxation Solver")
	Redirect output to: brook.sor
		Start a new line
			Export expression: SOR_MXITER [I10]
		End line
		Start a new line
			# Begin change, RBW, Format changed from [E13.5] to [G13]
			Export expression: SOR_ACCL [G13]
			Export expression: SOR_HCLOSE [G13]
			# end change, RBW
			Export expression: SOR_IPRSOR [I10]
		End line
	End file
End if
# ----------------------------------------------------
# Strongly-implicit procedure Solver
# ----------------------------------------------------
If: ContinueSimulation&(SolverChoice=0)&ExportSOL
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Strongly-implicit procedure Solver")
	Redirect output to: brook.sip
		Start a new line
			Export expression: SIP_MXITER [I10]
			Export expression: SIP_NPARM [I10]
		End line
		Start a new line
			# Begin change, RBW, Format changed from [E13.5] to [G13]
			Export expression: SIP_ACCL [G13]
			Export expression: SIP_HCLOSE [G13]
			# end change, RBW
			Export expression: SIP_IPCALC [I10]
			Export expression: SIP_WSEED [G10]
			Export expression: SIP_IPRSIP [I10]
		End line
	End file
End if
# ----------------------------------------------------
# Preconditioned-Conjugate Gradient Solver
# ----------------------------------------------------
If: ContinueSimulation&(SolverChoice=2)&ExportSOL
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Preconditioned-Conjugate Gradient Solver")
	Redirect output to: brook.pcg
		Start a new line
			Export expression: PCG_MXITER [I10]
			Export expression: PCG_ITER1 [I10]
			Export expression: PCG_NPCOND [I10]
		End line
		Start a new line
			# Begin change, RBW, Format changed from [F10.4] to [G10]
			Export expression: PCG_HCLOSE [G10]
			Export expression: PCG_RCLOSE [G10]
			Export expression: PCG_RELAX [G10]
			# end change, RBW
			Export expression: PCG_NBPOL [I10]
			Export expression: PCG_IPRPCG [I10]
			Export expression: PCG_MUTPCG [I10]
			Export expression: PCG_DAMP [G10]
		End line
	End file
End if
# ----------------------------------------------------
# Direct solution with D4 ordering Solver
# ----------------------------------------------------
If: ContinueSimulation&(SolverChoice=1)&ExportSOL
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Direct solution with D4 ordering Solver")
	Redirect output to: brook.de4
		Start a new line
			Export expression: DE4_ITMX [I10]
			Export expression: DE4_MXUP [I10]
			Export expression: DE4_MXLOW [I10]
			Export expression: DE4_MXBW [I10]
		End line
		Start a new line
			Export expression: DE4_IFREQ [I10]
			Export expression: DE4_MUTD4 [I10]
			# Begin change, RBW, Format changed from [F10.4] to [G10]
			Export expression: DE4_ACCL [G10]
			Export expression: DE4_HCLOSE [G10]
			# end change, RBW
			Export expression: DE4_IPRD4 [I10]
		End line
	End file
End if
# 
# MF_MOC3D.met
# ----------------------------------------------------
# Solute Transport section
# ----------------------------------------------------
If: ContinueSimulation&(TransportFlag=1) & RunMoc3d
	Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Solute Transport")
	# ----------------------------------------------------
	# MOC3D Transport
	# ----------------------------------------------------
	If: Transport>0
		# MOC3D Name File
		Set Variable: j:= 0
		Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
			If: ContinueSimulation&MODFLOW_SIMUL(LayIndex)=0
				Set Variable: j:= 1
				If: ShowWarnings
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Layer " + LayIndex + " is non-simulated. Non simulated layers are not allowed in the MOC3D subgrid!")
				End if
			End if
		End loop
		If: j=1
			Set Variable: err_moc_1:= 1
			# Alert: "Non simulated layers are not allowed in the MOC3D subgrid!"
		End if
		If: ContinueSimulation
			Redirect output to: brook.mcn
				Start a new line
					# File for LISTING results of MOC3D simulation
					Export expression: "CLST 71 "+FileName+".out" [G0]
				End line
				If: Transport=1
					Start a new line
						# File for reading main MOC3D input data file
						Export expression: "MOC 72 "+FileName+".moc" [G0]
					End line
				Else
					If: Transport=2
						Start a new line
							# File for reading main MOCIMP input data file
							Export expression: "MOCIMP 72 "+FileName+".moc" [G0]
						End line
					End if
				End if
				If: RechargeChoice=1
					Start a new line
						# File for reading concentrations in recharge
						Export expression: "CRCH 73 "+FileName+".crc" [G0]
					End line
				End if
				If: MOC_CNC_OPT=1 | MOC_CNC_OPT=3
					Start a new line
						# File for writing concentration output (text)
						If: PrintMOC3DLocations
							Export expression: "CNCA 74 "+FileName+".cn2" [G0]
						Else
							Export expression: "CNCA 74 "+FileName+".cna" [G0]
						End if
					End line
				End if
				If: MOC_CNC_OPT=2 | MOC_CNC_OPT=3
					Start a new line
						# File for writing concentration output (binary)
						Export expression: "CNCB 75 "+FileName+".cnb" [G0]
					End line
				End if
				If: MOC_VEL_OPT=1 | MOC_VEL_OPT=3
					Start a new line
						# File for writing velocity output (text)
						Export expression: "VELA 76 "+FileName+".vla" [G0]
					End line
				End if
				If: MOC_VEL_OPT=2 | MOC_VEL_OPT=3
					Start a new line
						# File for writing velocity output (binary)
						Export expression: "VELB 77 "+FileName+".vlb" [G0]
					End line
				End if
				If: MOC_PRT_OPT=1 | MOC_PRT_OPT=3
					Start a new line
						# File for writing paricle location output (text)
						Export expression: "PRTA 78 "+FileName+".pta" [G0]
					End line
				End if
				If: MOC_PRT_OPT=2 | MOC_PRT_OPT=3
					Start a new line
						# File for writing paricle location output (binary)
						Export expression: "PRTB 79 "+FileName+".ptb" [G0]
					End line
				End if
				If: AgeChoice
					Start a new line
						Export expression: "AGE 81 " + FileName + ".age" [G0]
					End line
				End if
				If: DualPorosityChoice
					Start a new line
						Export expression: "DP 82 " + FileName + ".dp" [G0]
					End line
				End if
				If: SimpleReactionChoice
					Start a new line
						Export expression: "DK 83 " + FileName + ".dk" [G0]
					End line
				End if
				If: MOC_NUMOBS>0
					Start a new line
						# File for reading OBS package information
						Export expression: "OBS 80 "+FileName+".obs" [G0]
					End line
					If: MOC_IOBSFL>0
						Start a new line
							# File for writing observation well data (one file, IOBSFL must be > 0)
							Export expression: "DATA 100 "+FileName+".oba" [G0]
						End line
					Else
						Loop for: Variable i from: 1 to: MOC_NUMOBS step: 1
							Start a new line
								Export expression: "DATA "+(99+i)+" "+FileName+i+".oba" [G0]
							End line
						End loop
					End if
				End if
			End file
		End if
		# MOC3D Package:
		If: ContinueSimulation&(ExportTRANS!=0)
			Redirect output to: brook.moc
				Start a new line
					Export expression: Heading1 [G0]
				End line
				Start a new line
					Export expression: Heading2 [G0]
				End line
				Start a new line
					Export expression: FirstLay [I5]
					Export expression: LastLay [I5]
					Export expression: MOC_ISROW1 [I5]
					Export expression: MOC_ISROW2 [I5]
					Export expression: MOC_ISCOL1 [I5]
					Export expression: MOC_ISCOL2 [I5]
				End line
				Start a new line
					Export expression: MOC_NODISP [I5]
					Export expression: MOC_DECAY [E13.5]
					Export expression: MOC_DIFFUS [E13.5]
				End line
				Start a new line
					Export expression: MOC_NPMAX [I5]
					Export expression: if(MOC_NPCUST,-1,1)*MOC_NPTPND [I5]
				End line
				If: MOC_NPCUST
					# Custom particle positioning
					Loop for: Variable i from: 1 to: MOC_NPTPND step: 1
						Start a new line
							Export expression: MODFLOW_MOC_PNEWL(i) [E13.5]
							Export expression: MODFLOW_MOC_PNEWR(i) [E13.5]
							Export expression: MODFLOW_MOC_PNEWC(i) [E13.5]
						End line
					End loop
				End if
				Start a new line
					Export expression: MOC_CELDIS [E13.5]
					Export expression: MOC_FZERO [E13.5]
					Export expression: MOC_INTRPL [I5]
				End line
				If: Transport=2
					Start a new line
						Export expression: MOC_FDTMTH [E13.5]
						Export expression: MOC_NCXIT [I5]
						Export expression: MOC_IDIREC [I5]
						Export expression: MOC_EPSSLV [E13.5]
						Export expression: MOC_MAXIT [I5]
					End line
				End if
				Start a new line
					Export expression: if(MOC_NPNTCL<3,MOC_NPNTCL-2,MOC_NPNTCLN) [I5]
					If: PrintMOC3DLocations
						Export expression: -1 [I5]
					Else
						Export expression: 0 [I5]
					End if
					Export expression: if(MOC_NPNTVL<2,MOC_NPNTVL-1,MOC_NPNTVLN) [I5]
					Export expression: 0 [I5]
					Export expression: if(MOC_NPNTDL<3,MOC_NPNTDL-2,MOC_NPNTDLN) [I5]
					Export expression: 0 [I5]
					Export expression: if(!MOC_PRT_OPT,0,if(MOC_NPNTPL<3,MOC_NPNTPL-2,MOC_NPNTPLN)) [I5]
				End line
				Start a new line
					Export expression: MOC_CNOFLO [E13.5]
				End line
				Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation&MODFLOW_SIMUL(LayIndex)
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Start a new line
								Export expression: "INTERNAL 1 (FREE)" [G0]
								Export expression: 0 [I5]
							End line
							# only export the subgrid
							Set Variable: n:= 0
							Loop for: Blocks
								If: Row()>=MOC_ISROW1 & Row()<=MOC_ISROW2 & Column()>=MOC_ISCOL1 & Column()<=MOC_ISCOL2
									If: ((n=NColsSub)|(n=0))
										Export expression: MODFLOW FD Grid.Init Concentration Unit[LayIndex] [E13.5]
										Set Variable: n:= 0
									Else
										Export expression: MODFLOW FD Grid.Init Concentration Unit[LayIndex] [E13.5]
									End if
									Set Variable: n:= n+1
									If: (n=NColsSub)
										Start a new line
										End line
									End if
								End if
							End loop
						End loop
					End if
				End loop
				# cinfl array: size depends on subgrid existance and positioning
				If: ContinueSimulation&((MOC_ISROW1>1)|(MOC_ISROW2<NumRows())|(MOC_ISCOL1>1)|(MOC_ISCOL2<NumColumns())|(FirstMoc3DUnit>1)|(LastMoc3DUnit<MODFLOW_NLAY()))
					Start a new line
						Export expression: "INTERNAL 1.0 (FREE)" [G0]
						Export expression: 1 [I5]
					End line
					Start a new line
						If: (MOC_ISROW1>1)|(MOC_ISROW2<NumRows())|(MOC_ISCOL1>1)|(MOC_ISCOL2<NumColumns())
							Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
								If: MODFLOW_SIMUL(LayIndex)!=0
									Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
										Export expression: MODFLOW_MOC_CINFL(LayIndex) [8E13.5]
									End loop
								End if
							End loop
						End if
						If: FirstMoc3DUnit>1
							Export expression: MODFLOW_MOC_CINFL(FirstMoc3DUnit-1) [8E13.5]
						End if
						If: LastMoc3DUnit<MODFLOW_NLAY()
							Export expression: MODFLOW_MOC_CINFL(LastMoc3DUnit+1) [8E13.5]
						End if
					End line
				End if
				Start a new line
					Export expression: MODFLOW_L_GetListSize(ConcentrationList) [I5]
				End line
				If: MODFLOW_L_GetListSize(ConcentrationList)>0
					Loop for: Variable i from: 1 to: MODFLOW_L_GetListSize(ConcentrationList) step: 1
						Start a new line
							Export expression: -i [I5]
							Export expression: MODFLOW_L_GetFromList(ConcentrationList, i-1) [E13.5]
						End line
					End loop
				End if
				Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation&MODFLOW_SIMUL(LayIndex)
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Start a new line
								Export expression: "INTERNAL 1 (FREE)" [G0]
								Export expression: 7 [I5]
							End line
							# only export the subgrid
							Set Variable: n:= 0
							Loop for: Blocks
								If: Row()>=MOC_ISROW1 & Row()<=MOC_ISROW2 & Column()>=MOC_ISCOL1 & Column()<=MOC_ISCOL2
									If: ((n=NColsSub)|(n=0))
										Export expression: MODFLOW FD Grid.Particle Regeneration Unit[LayIndex] [I5]
										Set Variable: n:= 0
									Else
										Export expression: MODFLOW FD Grid.Particle Regeneration Unit[LayIndex] [I5]
									End if
									Set Variable: n:= n+1
									If: (n=NColsSub)
										Start a new line
										End line
									End if
								End if
							End loop
						End loop
					End if
				End loop
				If: MOC_NODISP=0
					Start a new line
						Export expression: "INTERNAL 1.0 (FREE)" [G0]
						Export expression: 1 [I5]
					End line
					Start a new line
						Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
							If: MODFLOW_SIMUL(LayIndex)!=0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Export expression: MODFLOW_MOC_ALONG(LayIndex) [8E13.5]
								End loop
							End if
						End loop
					End line
					Start a new line
						Export expression: "INTERNAL 1.0 (FREE)" [G0]
						Export expression: 1 [I5]
					End line
					Start a new line
						Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
							If: MODFLOW_SIMUL(LayIndex)!=0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Export expression: MODFLOW_MOC_ATRANH(LayIndex) [8E13.5]
								End loop
							End if
						End loop
					End line
					Start a new line
						Export expression: "INTERNAL 1.0 (FREE)" [G0]
						Export expression: 1 [I5]
					End line
					Start a new line
						Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
							If: MODFLOW_SIMUL(LayIndex)!=0
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Export expression: MODFLOW_MOC_ATRANV(LayIndex) [8E13.5]
								End loop
							End if
						End loop
					End line
				End if
				Start a new line
					Export expression: "INTERNAL 1.0 (FREE)" [G0]
					Export expression: 1 [I5]
				End line
				Start a new line
					Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
						If: MODFLOW_SIMUL(LayIndex)!=0
							Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								Export expression: MODFLOW_MOC_RF(LayIndex) [8E13.5]
							End loop
						End if
					End loop
				End line
				Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation&MODFLOW_SIMUL(LayIndex)
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Start a new line
								Export expression: "INTERNAL 1 (FREE)" [G0]
								Export expression: 0 [I5]
							End line
							# only export the subgrid
							Set Variable: n:= 0
							Loop for: Blocks
								If: Row()>=MOC_ISROW1 & Row()<=MOC_ISROW2 & Column()>=MOC_ISCOL1 & Column()<=MOC_ISCOL2
									If: ((n=NColsSub)|(n=0))
										Export expression: MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex) [E13.5]
										Set Variable: n:= 0
									Else
										Export expression: MODFLOW_L_GetFromOneBased3DList(ThicknessList, Column(), Row(), LayIndex) [E13.5]
									End if
									Set Variable: n:= n+1
									If: (n=NColsSub)
										Start a new line
										End line
									End if
								End if
							End loop
							Start a new line
								Export expression: "INTERNAL 1 (FREE)" [G0]
								Export expression: 5 [I5]
							End line
							# only export the subgrid
							Set Variable: n:= 0
							Loop for: Blocks
								If: Row()>=MOC_ISROW1 & Row()<=MOC_ISROW2 & Column()>=MOC_ISCOL1 & Column()<=MOC_ISCOL2
									If: ((n=NColsSub)|(n=0))
										Export expression: MODFLOW FD Grid.Porosity Unit[LayIndex] [E13.5]
										Set Variable: n:= 0
									Else
										Export expression: MODFLOW FD Grid.Porosity Unit[LayIndex] [E13.5]
									End if
									Set Variable: n:= n+1
									If: (n=NColsSub)
										Start a new line
										End line
									End if
								End if
							End loop
						End loop
					End if
				End loop
			End file
			# Evaluate expression: MODFLOW_MOC_EndZones()
			#  MOC3D Concentrations in recharge
			If: RechargeChoice!=0
				Redirect output to: brook.crc
					Start a new line
						Export expression: 0 [I5]
					End line
					# Export Recharge concentrations for stress period 1
					Start a new line
						Export expression: "INTERNAL 1.0  (FREE)" [G0]
						Export expression: 0 [I5]
					End line
					# only export the subgrid
					Set Variable: n:= 0
					Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
					If: ContinueSimulation
						Loop for: Blocks
							If: Row()>=MOC_ISROW1 & Row()<=MOC_ISROW2 & Column()>=MOC_ISCOL1 & Column()<=MOC_ISCOL2
								If: ((n=NColsSub)|(n=0))
									Export expression: Recharge Concentration.Concentration1 [E13.5]
									Set Variable: n:= 0
								Else
									Export expression: Recharge Concentration.Concentration1 [E13.5]
								End if
								Set Variable: n:= n+1
								If: (n=NColsSub)
									Start a new line
									End line
								End if
							End if
						End loop
					End if
					Loop for: Variable PeriodIndex from: 2 to: MODFLOW_NPER() step: 1
						Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
						If: ContinueSimulation
							Start a new line
								Export expression: MOC_INCRCH [I5]
							End line
							If: MOC_INCRCH=0
								Start a new line
									Export expression: "INTERNAL 1.0  (FREE)" [G0]
									Export expression: 0 [I5]
								End line
								# only export the subgrid
								Set Variable: n:= 0
								Loop for: Blocks
									If: Row()>=MOC_ISROW1 & Row()<=MOC_ISROW2 & Column()>=MOC_ISCOL1 & Column()<=MOC_ISCOL2
										If: ((n=NColsSub)|(n=0))
											Export expression: Recharge Concentration.Concentration[PeriodIndex] [E13.5]
											Set Variable: n:= 0
										Else
											Export expression: Recharge Concentration.Concentration[PeriodIndex] [E13.5]
										End if
										Set Variable: n:= n+1
										If: (n=NColsSub)
											Start a new line
											End line
										End if
									End if
								End loop
							End if
						End if
					End loop
				End file
			End if
		End if
		# MOC3D Observation well file
		If: ExportOBS!=0
			If: MOC_NUMOBS>0
				Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("MOC3D Observation well file")
				If: ContinueSimulation
					Redirect output to: brook.obs
						Start a new line
							Export expression: MOC_NUMOBS [I5]
							Export expression: MOC_IOBSFL [I5]
						End line
						Set Variable: n:= 1
						Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
							# Set Variable: ContinueSimulation:=  MODFLOW_ProgressBarAdvance()
							If: ContinueSimulation
								If: LayIndex=FirstMoc3DUnit
									Set Variable: M:= FirstMoc3DUnit-1
								Else
									Set Variable: M:= M+MODFLOW_SIMUL(LayIndex-1)*MODFLOW_NDIV(LayIndex-1)
								End if
							End if
							If: ContinueSimulation&MODFLOW_SIMUL(LayIndex)
								Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
									Loop for: Blocks
										Set Variable: DumRow:= Row()
										Set Variable: DumCol:= Column()
										Set Variable: DumLay:= M+DivIndex
										Loop for: Objects in layer: MOC3D Observation Wells
											Set Variable: LayerTop:= Elevation Top Unit[LayIndex]
											Set Variable: LayerThickness:= (LayerTop - Elevation Bottom Unit[LayIndex]) / MODFLOW_NDIV(LayIndex)
											Loop for: Variable i from: 1 to: 5 step: 1
												Set Variable: WD:= MOC3D Observation Wells.Elevation[i]
												If: WD!=$N/A
													Set Variable: TML:= LayerTop-(DivIndex-1)*LayerThickness
													Set Variable: BML:= LayerTop-DivIndex*LayerThickness
													If: TML>WD & BML<=WD
														Start a new line
															Export expression: DumLay [I5]
															Export expression: DumRow [I5]
															Export expression: DumCol [I5]
															Export expression: 99+n [I5]
														End line
														Set Variable: n:= n+1
													End if
												End if
											End loop
										End loop
									End loop
								End loop
							End if
						End loop
					End file
				End if
			End if
		End if
		If: AgeChoice
			Redirect output to: brook.age
				Start a new line
					Export expression: AGER8 [G0]
				End line
			End file
		End if
		If: DualPorosityChoice
			Redirect output to: brook.dp
				Start a new line
					Export expression: IDPFO; [G0]
					Export expression: IDPZO; [G0]
					Export expression: IDPTIM; [G0]
					Export expression: IDPPS; [G0]
				End line
				Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
					Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
						Start a new line
							Export expression: "OPEN/CLOSE brook.ic" + (LayIndex-1) + " 1.0 (FREE)"; [G0]
							Export expression: 12; [G0]
							Export expression: "DPCON" [G0]
						End line
						Start a new line
							Export expression: "OPEN/CLOSE brook.ip" + (LayIndex-1) + " 1.0 (FREE)"; [G0]
							Export expression: 12; [G0]
							Export expression: "DPPOR" [G0]
						End line
					End loop
					Redirect output to: brook.ic$LOOP$
						Export matrix: Immobile Init Concentration Unit[LayIndex] [G0]
					End file
					Redirect output to: brook.ip$LOOP$
						Export matrix: Immobile Porosity Unit[LayIndex] [G0]
					End file
				End loop
				If: IDPTIM
					Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
						Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
							Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								Start a new line
									Export expression: "INTERNAL 1.0 (FREE)"; [G0]
									Export expression: 12; [G0]
									Export expression: "DPXRAT" [G0]
								End line
								Export matrix: Lin Exch Coef Unit[LayIndex].Lin Exch Coef[PeriodIndex] [G0]
								If: IDPFO
									Start a new line
										Export expression: "INTERNAL 1.0 (FREE)"; [G0]
										Export expression: 12; [G0]
										Export expression: "DPFO" [G0]
									End line
									Export matrix: First Order Decay Coef Unit[LayIndex].First Order Decay Coef[PeriodIndex] [G0]
								End if
								If: IDPZO
									Start a new line
										Export expression: "INTERNAL 1.0 (FREE)"; [G0]
										Export expression: 12; [G0]
										Export expression: "DPZO" [G0]
									End line
									Export matrix: Zero Order Growth Rate Unit[LayIndex].Zero Order Growth Rate[PeriodIndex] [G0]
								End if
							End loop
						End loop
					End loop
				Else
					Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Start a new line
								Export expression: "OPEN/CLOSE brook.li" + (LayIndex-1) + " 1.0 (FREE)"; [G0]
								Export expression: 12; [G0]
								Export expression: "DPXRAT" [G0]
							End line
							If: IDPFO
								Start a new line
									Export expression: "OPEN/CLOSE brook.de" + (LayIndex-1) + " 1.0 (FREE)"; [G0]
									Export expression: 12; [G0]
									Export expression: "DPFO" [G0]
								End line
							End if
							If: IDPZO
								Start a new line
									Export expression: "OPEN/CLOSE brook.go" + (LayIndex-1) + " 1.0 (FREE)"; [G0]
									Export expression: 12; [G0]
									Export expression: "DPZO" [G0]
								End line
							End if
						End loop
						Redirect output to: brook.li$LOOP$
							Export matrix: Lin Exch Coef Unit[LayIndex].Lin Exch Coef [G0]
						End file
						If: IDPFO
							Redirect output to: brook.de$LOOP$
								Export matrix: First Order Decay Coef Unit[LayIndex].First Order Decay Coef [G0]
							End file
						End if
						If: IDPZO
							Redirect output to: brook.go$LOOP$
								Export matrix: Zero Order Growth Rate Unit[LayIndex].Zero Order Growth Rate [G0]
							End file
						End if
					End loop
				End if
			End file
		End if
		If: SimpleReactionChoice
			Redirect output to: brook.dk
				Start a new line
					Export expression: IDKRF; [G0]
					Export expression: IDKTIM; [G0]
					Export expression: IDKFO; [G0]
					Export expression: IDKFS; [G0]
					Export expression: IDKZO; [G0]
					Export expression: IDKZS; [G0]
				End line
				If: IDKRF
					Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							Start a new line
								Export expression: "OPEN/CLOSE brook.re" + (LayIndex-1) + " 1.0 (FREE)"; [G0]
								Export expression: 12; [G0]
								Export expression: "DKRF" [G0]
							End line
						End loop
						Redirect output to: brook.re$LOOP$
							Export matrix: Retardation Unit[LayIndex] [G0]
						End file
					End loop
				End if
				If: IDKTIM
					Loop for: Variable PeriodIndex from: 1 to: MODFLOW_NPER() step: 1
						Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
							Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
								If: IDKFO
									Start a new line
										Export expression: "INTERNAL 1.0 (FREE)"; [G0]
										Export expression: 12; [G0]
										Export expression: "DKFO" [G0]
									End line
									Export matrix: Decay Coef Unit[LayIndex].Decay Coef [G0]
								End if
								If: IDKFS
									Start a new line
										Export expression: "INTERNAL 1.0 (FREE)"; [G0]
										Export expression: 12; [G0]
										Export expression: "DKFS" [G0]
									End line
									Export matrix: Sorbed Decay Coef Unit[LayIndex].Sorbed Decay Coef [G0]
								End if
								If: IDKZO
									Start a new line
										Export expression: "INTERNAL 1.0 (FREE)"; [G0]
										Export expression: 12; [G0]
										Export expression: "DKZO" [G0]
									End line
									Export matrix: Growth Rate Unit[LayIndex].Growth Rate [G0]
								End if
								If: IDKZS
									Start a new line
										Export expression: "INTERNAL 1.0 (FREE)"; [G0]
										Export expression: 12; [G0]
										Export expression: "DKZS" [G0]
									End line
									Export matrix: Sorbed Zero Order Growth Rate Unit[LayIndex].Sorbed Zero Order Growth Rate [G0]
								End if
							End loop
						End loop
					End loop
				Else
					Loop for: Variable LayIndex from: FirstMoc3DUnit to: LastMoc3DUnit step: 1
						Loop for: Variable DivIndex from: 1 to: MODFLOW_NDIV(LayIndex) step: 1
							If: IDKFO
								Start a new line
									Export expression: "OPEN/CLOSE brook.dd" + (LayIndex-1) + " 1.0 (FREE)"; [G0]
									Export expression: 12; [G0]
									Export expression: "DKFO" [G0]
								End line
							End if
							If: IDKFS
								Start a new line
									Export expression: "OPEN/CLOSE brook.ds" + (LayIndex-1) + " 1.0 (FREE)"; [G0]
									Export expression: 12; [G0]
									Export expression: "DKFS" [G0]
								End line
							End if
							If: IDKZO
								Start a new line
									Export expression: "OPEN/CLOSE brook.gd" + (LayIndex-1) + " 1.0 (FREE)"; [G0]
									Export expression: 12; [G0]
									Export expression: "DKZO" [G0]
								End line
							End if
							If: IDKZS
								Start a new line
									Export expression: "OPEN/CLOSE brook.gs" + (LayIndex-1) + " 1.0 (FREE)"; [G0]
									Export expression: 12; [G0]
									Export expression: "DKZS" [G0]
								End line
							End if
						End loop
						If: IDKFO
							Redirect output to: brook.dd$LOOP$
								Export matrix: Decay Coef Unit[LayIndex].Decay Coef [G0]
							End file
						End if
						If: IDKFS
							Redirect output to: brook.ds$LOOP$
								Export matrix: Sorbed Decay Coef Unit[LayIndex].Sorbed Decay Coef [G0]
							End file
						End if
						If: IDKZO
							Redirect output to: brook.gd$LOOP$
								Export matrix: Growth Rate Unit[LayIndex].Growth Rate [G0]
							End file
						End if
						If: IDKZS
							Redirect output to: brook.gs$LOOP$
								Export matrix: Sorbed Zero Order Growth Rate Unit[LayIndex].Sorbed Zero Order Growth Rate [G0]
							End file
						End if
					End loop
				End if
			End file
		End if
	End if
End if
# 
# MF_Err.met
# ----------------------------------------------------
# Write error log for MODFLOW & MOC3D export
# ----------------------------------------------------
If: ShowWarnings&(err_geo=1|err_bcf_1=1|err_rch_1=1|err_evt_1=1|err_ghb_1=1|err_ghb_2=1|err_riv_1=1|err_riv_2=1|err_riv_3=1|err_riv_4=1|err_drn_1=1|err_drn_2=1|err_drn_3=1|err_drn_4=1|err_wel_1=1|err_wel_2=1|err_moc_1=1)
	If: err_geo=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error - Project Information: No geologic units are specified in simulation")
	End if
	If: err_bcf_1=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error - Project Information: Only the top simulated geologic unit can be unconfined")
	End if
	If: err_rch_1=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning - Recharge Information: Recharge elevation is located in a nonsimulated geologic unit - check recharge elevation and export Recharge package again")
	End if
	If: err_evt_1=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning - Evapotranspiration Information: Evapotranspiration surface is located in a nonsimulated geologic unit - check evapotranspiration surface and export Evapotranspiration package again")
	End if
	If: err_ghb_1=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error - The PIE Chk_LayArray.DLL is missing - results from General Head Boundary package will not be generated")
	End if
	If: err_ghb_2=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error - The PIE Chk_BlockArray.DLL is missing - results from General Head Boundary package will not be generated")
	End if
	If: err_riv_1=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error - The PIE Chk_LayArray.DLL is missing - results from River package will not be generated")
	End if
	If: err_riv_2=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error - The PIE Chk_BlockArray.DLL is missing - results from River package will not be generated")
	End if
	If: err_riv_3=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning - Line river elevation does not lie within the geologic unit - Line river is placed in the uppermost model layer of the geologic unit - Check line river elevations for possible errors")
	End if
	If: err_riv_4=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning - Area river elevation does not lie within the geologic unit - Area river is placed in the uppermost model layer of the geologic unit - Check area river elevations for possible errors")
	End if
	If: err_drn_1=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error - The PIE Chk_LayArray.DLL is missing - results from Drain package will not be generated")
	End if
	If: err_drn_2=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error - Project Information: No geologic units are specified in simulation")
	End if
	If: err_drn_3=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning - Line drain elevation does not lie within the geologic unit - Line drain is placed in the uppermost model layer of the geologic unit - Check line drain elevations for possible errors")
	End if
	If: err_drn_4=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Warning - Area drain elevation does not lie within the geologic unit - Area drain is placed in the uppermost model layer of the geologic unit - Check area drain elevations for possible errors")
	End if
	If: err_wel_1=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error - The PIE Chk_LayArray.DLL is missing - results from Well package will not be generated")
	End if
	If: err_wel_2=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error - The PIE Chk_BlockArray.DLL is missing - results from Well package will not be generated")
	End if
	If: err_moc_1=1
		Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAddLine("Error - Non simulated layers are not allowed in the MOC3D subgrid!")
	End if
End if
# 
# pie command: replace_file MF_Name.met
# pie command: replace_file MF_MOC_ini.met
# pie command: replace_file MF_BAS.met
# pie command: replace_file MF_OC.met
# pie command: replace_file MF_BCF.met
# pie command: replace_file MF_RCH.met
# pie command: replace_file MF_EVT.met
# pie command: replace_file MF_GHB.met
# pie command: replace_file MF_RIV.met
# pie command: replace_file MF_DRN.met
# pie command: replace_file MF_WEL.met
# pie command: replace_file MF_STR.met
# pie command: replace_file MF_HFB.met
# pie command: replace_file MF_FHB.met
# begin modification
# pie command: replace_file MF_SPG.met
# pie command: replace_file MF_GeoTLAK.met
# end modification
# pie command: replace_file MF_SOL.met
# pie command: replace_file MF_MOC3D.met
# pie command: replace_file MF_Err.met
# pie command: stop_replacing_files
# 
# 
# ----------------------------------------------------
# Run MODFLOW.EXE
# ----------------------------------------------------
# batch file to run MODFLOW
Set Variable: ContinueSimulation:= MODFLOW_ProgressBarSetMessage("Run MODFLOW or MOC3D")
Set Variable: ContinueSimulation:= MODFLOW_ProgressBarAdvance()
If: ContinueSimulation
	If: !RunMOC3D
		Redirect output to: MODFLOW.BAT
			Start a new line
				Export expression: "D:\PROGRA~1\ARGUSI~1\ArgusPIE\MT3D_GUI\MODFLW~1.EXE"; [G0]
				Export expression: "/wait"; [G0]
			End line
			If: UseCalibration
				Start a new line
					Export expression: GetMyDirectory() [G0]
					Export expression: "WaitForMe.exe"; [G0]
				End line
				Start a new line
					Export expression: GetMyDirectory() [G0]
					Export expression: "SelectChar.exe"; [G0]
				End line
			Else
				Start a new line
					Export expression: "Pause" [G0]
				End line
			End if
		End file
	Else
		# batch file to run MOC3D
		Redirect output to: MOC3D.BAT
			Start a new line
				Export expression: "D:\moc3dnew\fnew5\Moc3d.exe" [G0]
			End line
			If: UseCalibration
				Start a new line
					Export expression: GetMyDirectory() [G0]
					Export expression: "WaitForMe.exe"; [G0]
				End line
				Start a new line
					Export expression: GetMyDirectory() [G0]
					Export expression: "SelectChar.exe"; [G0]
				End line
			Else
				Start a new line
					Export expression: "Pause" [G0]
				End line
			End if
		End file
	End if
End if
# 
If: ContinueSimulation&RunMODFLOW
	If: !RunMOC3D
		Execute external code: "MODFLOW.BAT"
	Else
		Execute external code: "MOC3D.BAT"
	End if
End if
Set Variable: LineCount:= MODFLOW_ProgressBarSaveToFile("brook.err")
If: (LineCount>1)&ShowWarnings
	Alert: "Errors or Warnings while exporting!  See error file (brook.err)"
End if
If: (LineCount<0)&ShowWarnings
	Alert: "Error when attempting to save (brook.err) to disk."
End if
Evaluate expression: MODFLOW_ProgressBarFree()
Evaluate expression: MODFLOW_RF_Save_Files()
Evaluate expression: MODFLOW_RF_Clear_Files()
If: (MODFLOW_L_GetErrorCount()>0)&ShowWarnings
	Alert: "Error: There were errors in the List PIE. These could be due to unit thicknesses that were less than zero. If not, contact the PIE developer for assistance."
End if
If: (MODFLOW_BL_GetErrorCount()>0)&ShowWarnings
	Alert: "Error: There were errors in the BlockList PIE. Contact the PIE developer for assistance."
End if
Evaluate expression: MODFLOW_BL_FreeAllBlockLists()
Evaluate expression: MODFLOW_L_FreeAllLists()

